<README.md>
# 실시간 채팅 애플리케이션

이 프로젝트는 실시간 채팅을 위한 웹 애플리케이션으로, Node.js, Next.js, Redis, MongoDB를 활용하여 구현되었습니다.

## 주요 기능

### 인증 및 사용자 관리
- 이메일 기반의 사용자 인증 시스템
- 세션 관리 및 중복 로그인 처리
- 프로필 이미지 업로드 및 관리
- 비밀번호 암호화 및 보안 처리

### 채팅 기능
- 실시간 채팅 (Socket.IO)
- 마크다운 형식 지원
- 이모지 리액션 
- 멘션 기능 (@사용자)
- AI 챗봇 연동 (@wayneAI, @consultingAI)
- 메시지 읽음 상태 표시
- 파일 첨부 및 공유 기능

### 채팅방 관리
- 비밀번호 설정 가능한 채팅방 생성
- 참여자 관리
- 실시간 참여자 상태 표시

### 파일 처리
- 이미지, 비디오, 오디오, PDF 등 다양한 파일 형식 지원
- 파일 미리보기 기능
- 안전한 파일 업로드 및 다운로드
- 파일 형식별 크기 제한

## 설치 및 실행 가이드

### 1. 사전 요구사항 설치

```bash
# Node.js 설치 (v18 이상)
curl -fsSL https://deb.nodesource.com/setup_18.x | sudo -E bash -
sudo apt-get install -y nodejs

# MongoDB 설치 (v7.0)
sudo apt-get install -y mongodb

# Redis 설치
sudo apt-get install -y redis-server

# PM2 전역 설치
npm install -g pm2
```

### 2. 프로젝트 클론 및 패키지 설치

```bash
# 프로젝트 클론
git clone [repository-url]
cd bootcampchat

# 백엔드 패키지 설치
cd backend
npm install

# 프론트엔드 패키지 설치
cd ../frontend
npm install
```

### 3. 환경 변수 설정

#### 로컬 환경 설정
**backend/.env**
```env
MONGO_URI=mongodb://localhost:27017/bootcampchat
JWT_SECRET=your_jwt_secret
REDIS_HOST=localhost
REDIS_PORT=6379
OPENAI_API_KEY=your_openai_key
ENCRYPTION_KEY=your_encryption_key
PASSWORD_SALT=your_password_salt
```

**frontend/.env.local**
```env
NEXT_PUBLIC_API_URL=http://localhost:5000
NEXT_PUBLIC_ENCRYPTION_KEY=your_encryption_key
NEXT_PUBLIC_PASSWORD_SALT=your_password_salt
```

#### goormIDE 환경 설정
**backend/.env**
```env
MONGO_URI=mongodb://0.0.0.0:27017/bootcampchat
JWT_SECRET=your_jwt_secret
REDIS_HOST=0.0.0.0
REDIS_PORT=6379
OPENAI_API_KEY=your_openai_key
ENCRYPTION_KEY=your_encryption_key
PASSWORD_SALT=your_password_salt
NEXT_PUBLIC_API_URL=https://bootcampchat-be.run.goorm.site
```

**frontend/.env.local**
```env
NEXT_PUBLIC_API_URL=https://bootcampchat-be.run.goorm.site
NEXT_PUBLIC_ENCRYPTION_KEY=your_encryption_key
NEXT_PUBLIC_PASSWORD_SALT=your_password_salt
```

#### AWS 환경 설정
**backend/.env**
```env
MONGO_URI=mongodb://your-mongodb-uri
JWT_SECRET=your_jwt_secret
REDIS_HOST=your-redis-host
REDIS_PORT=6379
OPENAI_API_KEY=your_openai_key
ENCRYPTION_KEY=your_encryption_key
PASSWORD_SALT=your_password_salt
NEXT_PUBLIC_API_URL=https://api.your-domain.com
```

**frontend/.env.local**
```env
NEXT_PUBLIC_API_URL=https://api.your-domain.com
NEXT_PUBLIC_ENCRYPTION_KEY=your_encryption_key
NEXT_PUBLIC_PASSWORD_SALT=your_password_salt
```

### 4. 실행 스크립트 설정 및 실행

```bash
# 실행 스크립트 권한 설정
chmod +x run.sh

# 모든 서비스 시작
./run.sh start

# 서비스 상태 확인
./run.sh status

# 서비스 중지
./run.sh stop

# 서비스 재시작
./run.sh restart
```

## 서비스 접속 방법

### 로컬 환경
```
http://localhost:3000
```
- 로컬 개발 환경에서 실행 시 자동으로 해당 포트로 접속
- 환경 변수 설정: `NEXT_PUBLIC_API_URL=http://localhost:5000`

### goormIDE
1. 상단 메뉴의 "프로젝트" → "실행 URL과 포트" 클릭
2. 자동으로 생성된 URL 확인 (예: `https://chat.goorm-kdt-001.goorm.team`)
3. 터미널에서 실행:
   ```bash
   ./run.sh start
   ```

### AWS 배포
1. EC2 인스턴스의 퍼블릭 IP나 도메인 사용
   ```
   https://your-domain.com
   http://your-ec2-public-ip
   ```
2. EC2 보안그룹 설정:
   - 인바운드 규칙: TCP 3000(프론트엔드), 5000(백엔드) 포트 개방
   - HTTPS 사용 시 443 포트 개방

### 주의사항
1. **로컬 개발 환경**
   - Node.js, MongoDB, Redis가 로컬에 설치되어 있어야 함
   - 방화벽 설정에서 해당 포트 허용 필요

2. **goormIDE**
   - 컨테이너 생성 시 Node.js 템플릿 선택
   - 외부 접속을 위한 포트 설정 필요
   - CORS 설정 확인

3. **AWS 배포**
   - SSL 인증서 설정 권장
   - 로드밸런서 사용 시 웹소켓 설정 필요
   - MongoDB Atlas 사용 권장
   - Redis ElastiCache 고려

## 사용 방법 가이드

### 1. 회원가입 및 로그인

1. 서비스에 접속
2. 회원가입 버튼 클릭
3. 이름, 이메일, 비밀번호 입력하여 계정 생성
4. 생성된 계정으로 로그인

### 2. 프로필 설정

1. 상단 네비게이션 바의 프로필 아이콘 클릭
2. 프로필 설정 메뉴 선택
3. 프로필 이미지 업로드 및 이름 변경 가능
4. 필요시 비밀번호 변경 가능

### 3. 채팅방 생성 및 참여

1. 채팅방 목록에서 '새 채팅방' 버튼 클릭
2. 채팅방 이름 입력 (필수)
3. 필요시 비밀번호 설정 (선택)
4. 채팅방 생성 후 자동으로 입장
5. 기존 채팅방 참여시 비밀번호가 있는 경우 입력 필요

### 4. 채팅 기능 활용

#### 기본 채팅
- 하단 입력창에 메시지 입력 후 Enter 키로 전송
- Shift + Enter로 줄바꿈 가능

#### 마크다운 사용
- **굵게**: `**텍스트**` 또는 Ctrl+B
- *기울임*: `*텍스트*` 또는 Ctrl+I
- 코드 블록: ```언어명 또는 Ctrl+Shift+C
- 링크: `[텍스트](URL)` 또는 Ctrl+K

#### 멘션 기능
- '@' 입력 후 사용자 이름 입력
- AI 챗봇 멘션: @wayneAI 또는 @consultingAI
- 방향키로 멘션할 사용자 선택

#### 파일 공유
1. 클립 아이콘 클릭 또는 파일 드래그 앤 드롭
2. 지원 형식:
   - 이미지: jpg, jpeg, png, gif, webp (최대 10MB)
   - 비디오: mp4, webm, mov (최대 50MB)
   - 오디오: mp3, wav, ogg (최대 20MB)
   - 문서: pdf (최대 20MB)

#### 이모지 및 리액션
- 이모지 버튼 클릭하여 이모지 선택
- 메시지에 마우스 오버 시 리액션 추가 가능

### 5. 채팅방 관리

- 채팅방 참여자 목록 확인
- 이전 메시지 스크롤하여 로드
- 파일 및 미디어 미리보기
- 메시지 읽음 상태 확인

### 6. 보안 및 개인정보

- 주기적인 비밀번호 변경 권장
- 민감한 정보는 파일로 공유하지 않도록 주의
- 로그아웃 시 반드시 '로그아웃' 버튼 사용

### 7. 문제 해결

**채팅이 연결되지 않는 경우**
1. 네트워크 연결 상태 확인
2. 페이지 새로고침
3. 재로그인 시도

**파일 업로드 실패 시**
1. 파일 크기 및 형식 확인
2. 네트워크 상태 확인
3. 페이지 새로고침 후 재시도

**성능 최적화 팁**
- 대용량 파일은 압축하여 업로드
- 오래된 채팅방은 주기적으로 정리
- 불필요한 채팅방은 나가기 처리

## 기술 스택

### 프론트엔드
- Next.js
- React
- Socket.IO Client
- Vapor Components (@goorm-dev/vapor)
- Markdown 렌더링
- 모바일 최적화 UI

### 백엔드
- Node.js
- Express.js
- Socket.IO
- MongoDB & Mongoose
- Redis
- JWT 기반 인증

### 데이터베이스
- MongoDB: 사용자 정보, 채팅방, 메시지 저장
- Redis: 세션 관리, 실시간 상태 관리

### 인프라
- PM2: 프로세스 관리
- Docker 지원
- 환경 변수 기반 설정

<backend/config/keys.js>
// backend/config/keys.js
require('dotenv').config();

// 기본 키와 솔트 (개발 환경용)
const DEFAULT_ENCRYPTION_KEY = 'a'.repeat(64); // 32바이트를 hex로 표현
const DEFAULT_PASSWORD_SALT = 'b'.repeat(32); // 16바이트를 hex로 표현

module.exports = {
  mongoURI: process.env.MONGO_URI,
  jwtSecret: process.env.JWT_SECRET,
  encryptionKey: process.env.ENCRYPTION_KEY || DEFAULT_ENCRYPTION_KEY,
  passwordSalt: process.env.PASSWORD_SALT || DEFAULT_PASSWORD_SALT,
  redisHost: process.env.REDIS_HOST,
  redisPort: process.env.REDIS_PORT,
  openaiApiKey: process.env.OPENAI_API_KEY,
  vectorDbEndpoint: process.env.VECTOR_DB_ENDPOINT,
};

<backend/controllers/authController.js>
const User = require('../models/User');
const jwt = require('jsonwebtoken');
const { jwtSecret } = require('../config/keys');
const SessionService = require('../services/sessionService');

const authController = {
  async register(req, res) {
    try {
      console.log('Register request received:', req.body);
      
      const { name, email, password } = req.body;

      // Input validation
      if (!name || !email || !password) {
        return res.status(400).json({
          success: false,
          message: '모든 필드를 입력해주세요.'
        });
      }

      if (!email.match(/^[^\s@]+@[^\s@]+\.[^\s@]+$/)) {
        return res.status(400).json({
          success: false,
          message: '올바른 이메일 형식이 아닙니다.'
        });
      }

      if (password.length < 6) {
        return res.status(400).json({
          success: false,
          message: '비밀번호는 6자 이상이어야 합니다.'
        });
      }
      
      // Check existing user
      const existingUser = await User.findOne({ email });
      if (existingUser) {
        return res.status(409).json({
          success: false,
          message: '이미 등록된 이메일입니다.'
        });
      }
      
      // Create user
      const user = new User({
        name,
        email,
        password
      });

      await user.save();
      console.log('User created:', user._id);

      // Create session with metadata
      const sessionInfo = await SessionService.createSession(user._id, {
        userAgent: req.headers['user-agent'],
        ipAddress: req.ip,
        deviceInfo: req.headers['user-agent'],
        createdAt: Date.now()
      });
      
      if (!sessionInfo || !sessionInfo.sessionId) {
        throw new Error('Session creation failed');
      }

      // Generate token with additional claims
      const token = jwt.sign(
        { 
          user: { id: user._id },
          sessionId: sessionInfo.sessionId,
          iat: Math.floor(Date.now() / 1000)
        },
        jwtSecret,
        { 
          expiresIn: '24h',
          algorithm: 'HS256'
        }
      );

      res.status(201).json({
        success: true,
        message: '회원가입이 완료되었습니다.',
        token,
        sessionId: sessionInfo.sessionId,
        user: {
          _id: user._id,
          name: user.name,
          email: user.email
        }
      });

    } catch (error) {
      console.error('Register error:', error);
      
      if (error.name === 'ValidationError') {
        return res.status(400).json({
          success: false,
          message: '입력값이 올바르지 않습니다.',
          errors: Object.values(error.errors).map(err => err.message)
        });
      }
      
      res.status(500).json({
        success: false,
        message: '회원가입 처리 중 오류가 발생했습니다.'
      });
    }
  },

  async login(req, res) {
    try {
      const { email, password } = req.body;

      // Input validation
      if (!email || !password) {
        return res.status(400).json({
          success: false,
          message: '이메일과 비밀번호를 입력해주세요.'
        });
      }

      // 사용자 조회
      const user = await User.findOne({ email }).select('+password');
      if (!user) {
        return res.status(401).json({
          success: false,
          message: '이메일 또는 비밀번호가 올바르지 않습니다.'
        });
      }

      // 비밀번호 확인
      const isMatch = await user.matchPassword(password);
      if (!isMatch) {
        return res.status(401).json({
          success: false,
          message: '이메일 또는 비밀번호가 올바르지 않습니다.'
        });
      }

      // 기존 세션 확인 시도
      let existingSession = null;
      try {
        existingSession = await SessionService.getActiveSession(user._id);
      } catch (sessionError) {
        console.error('Session check error:', sessionError);
      }

      if (existingSession) {
        const io = req.app.get('io');
        
        if (io) {
          try {
            // 중복 로그인 이벤트 발생 시 더 자세한 정보 제공
            io.to(existingSession.socketId).emit('duplicate_login', {
              type: 'new_login_attempt',
              deviceInfo: req.headers['user-agent'],
              ipAddress: req.ip,
              timestamp: Date.now(),
              location: req.headers['x-forwarded-for'] || req.connection.remoteAddress,
              browser: req.headers['user-agent']
            });

            // Promise 기반의 응답 대기 로직 개선
            const response = await new Promise((resolve, reject) => {
              const timeout = setTimeout(() => {
                reject(new Error('DUPLICATE_LOGIN_TIMEOUT'));
              }, 60000); // 60초 타임아웃

              const cleanup = () => {
                clearTimeout(timeout);
                io.removeListener('force_login', handleForceLogin);
                io.removeListener('keep_existing_session', handleKeepSession);
              };

              const handleForceLogin = async (data) => {
                try {
                  if (data.token === existingSession.token) {
                    // 기존 세션 종료 및 소켓 연결 해제
                    await SessionService.removeSession(user._id, existingSession.sessionId);
                    io.to(existingSession.socketId).emit('session_terminated', {
                      reason: 'new_login',
                      message: '다른 기기에서 로그인하여 현재 세션이 종료되었습니다.'
                    });
                    resolve('force_login');
                  } else {
                    reject(new Error('INVALID_TOKEN'));
                  }
                } catch (error) {
                  reject(error);
                } finally {
                  cleanup();
                }
              };

              const handleKeepSession = () => {
                cleanup();
                resolve('keep_existing');
              };

              io.once('force_login', handleForceLogin);
              io.once('keep_existing_session', handleKeepSession);
            });

            // 응답에 따른 처리
            if (response === 'keep_existing') {
              return res.status(409).json({
                success: false,
                code: 'DUPLICATE_LOGIN_REJECTED',
                message: '기존 세션을 유지하도록 선택되었습니다.'
              });
            }

          } catch (error) {
            if (error.message === 'DUPLICATE_LOGIN_TIMEOUT') {
              return res.status(409).json({
                success: false,
                code: 'DUPLICATE_LOGIN_TIMEOUT',
                message: '중복 로그인 요청이 시간 초과되었습니다.'
              });
            }
            throw error;
          }
        } else {
          // Socket.IO 연결이 없는 경우 자동으로 기존 세션 종료
          await SessionService.removeAllUserSessions(user._id);
        }
      }

      // 새 세션 생성
      const sessionInfo = await SessionService.createSession(user._id, {
        userAgent: req.headers['user-agent'],
        ipAddress: req.ip,
        deviceInfo: req.headers['user-agent'],
        loginAt: Date.now(),
        browser: req.headers['user-agent'],
        platform: req.headers['sec-ch-ua-platform'],
        location: req.headers['x-forwarded-for'] || req.connection.remoteAddress
      });

      if (!sessionInfo || !sessionInfo.sessionId) {
        throw new Error('Session creation failed');
      }

      // JWT 토큰 생성
      const token = jwt.sign(
        { 
          user: { id: user._id },
          sessionId: sessionInfo.sessionId,
          iat: Math.floor(Date.now() / 1000)
        },
        jwtSecret,
        { 
          expiresIn: '24h',
          algorithm: 'HS256'
        }
      );

      // 응답 헤더 설정
      res.set({
        'Authorization': `Bearer ${token}`,
        'x-session-id': sessionInfo.sessionId
      });

      res.json({
        success: true,
        token,
        sessionId: sessionInfo.sessionId,
        user: {
          _id: user._id,
          name: user.name,
          email: user.email,
          profileImage: user.profileImage
        }
      });

    } catch (error) {
      console.error('Login error:', error);
      
      if (error.message === 'INVALID_TOKEN') {
        return res.status(401).json({
          success: false,
          message: '인증 토큰이 유효하지 않습니다.'
        });
      }
      
      res.status(500).json({
        success: false,
        message: '로그인 처리 중 오류가 발생했습니다.',
        code: error.code || 'UNKNOWN_ERROR'
      });
    }
  },

  async logout(req, res) {
    try {
      const sessionId = req.header('x-session-id');
      if (!sessionId) {
        return res.status(400).json({
          success: false,
          message: '세션 정보가 없습니다.'
        });
      }

      await SessionService.removeSession(req.user.id, sessionId);

      // Socket.IO 클라이언트에 로그아웃 알림
      const io = req.app.get('io');
      if (io) {
        const socketId = await SessionService.getSocketId(req.user.id, sessionId);
        if (socketId) {
          io.to(socketId).emit('session_ended', {
            reason: 'logout',
            message: '로그아웃되었습니다.'
          });
        }
      }
      
      // 쿠키 및 헤더 정리
      res.clearCookie('token');
      res.clearCookie('sessionId');
      
      res.json({
        success: true,
        message: '로그아웃되었습니다.'
      });
    } catch (error) {
      console.error('Logout error:', error);
      res.status(500).json({
        success: false,
        message: '로그아웃 처리 중 오류가 발생했습니다.'
      });
    }
  },

  async verifyToken(req, res) {
    try {
      const token = req.header('x-auth-token');
      const sessionId = req.header('x-session-id');

      if (!token || !sessionId) {
        console.log('Missing token or sessionId:', { token: !!token, sessionId: !!sessionId });
        return res.status(401).json({
          success: false,
          message: '인증 정보가 제공되지 않았습니다.'
        });
      }

      // JWT 토큰 검증
      const decoded = jwt.verify(token, jwtSecret);
      
      if (!decoded?.user?.id || !decoded?.sessionId) {
        return res.status(401).json({
          success: false,
          message: '유효하지 않은 토큰입니다.'
        });
      }

      // 토큰의 sessionId와 헤더의 sessionId 일치 여부 확인
      if (decoded.sessionId !== sessionId) {
        return res.status(401).json({
          success: false,
          message: '세션 정보가 일치하지 않습니다.'
        });
      }

      // 사용자 정보 조회
      const user = await User.findById(decoded.user.id);
      if (!user) {
        return res.status(404).json({
          success: false,
          message: '사용자를 찾을 수 없습니다.'
        });
      }

      // 세션 검증
      const validationResult = await SessionService.validateSession(user._id, sessionId);
      if (!validationResult.isValid) {
        console.log('Invalid session:', validationResult);
        return res.status(401).json({
          success: false,
          code: validationResult.error,
          message: validationResult.message
        });
      }

      // 세션 갱신
      await SessionService.refreshSession(user._id, sessionId);

      console.log('Token verification successful for user:', user._id);

      // 프로필 업데이트 필요 여부 확인
      if (validationResult.needsProfileRefresh) {
        res.set('X-Profile-Update-Required', 'true');
      }

      res.json({
        success: true,
        user: {
          _id: user._id,
          name: user.name,
          email: user.email,
          profileImage: user.profileImage
        }
      });

    } catch (error) {
      console.error('Token verification error:', error);

      if (error.name === 'JsonWebTokenError') {
        return res.status(401).json({
          success: false,
          message: '유효하지 않은 토큰입니다.'
        });
      }

      if (error.name === 'TokenExpiredError') {
        return res.status(401).json({
          success: false,
          message: '토큰이 만료되었습니다.',
          code: 'TOKEN_EXPIRED'
        });
      }

      res.status(500).json({
        success: false,
        message: '토큰 검증 중 오류가 발생했습니다.'
      });
    }
  },

  async refreshToken(req, res) {
    try {
      const oldSessionId = req.header('x-session-id');
      if (!oldSessionId) {
        return res.status(400).json({
          success: false,
          message: '세션 정보가 없습니다.'
        });
      }

      const user = await User.findById(req.user.id);
      if (!user) {
        return res.status(404).json({
          success: false,
          message: '사용자를 찾을 수 없습니다.'
        });
      }

      // 이전 세션 제거
      await SessionService.removeSession(user._id, oldSessionId);

      // 새 세션 생성
      const sessionInfo = await SessionService.createSession(user._id, {
        userAgent: req.headers['user-agent'],
        ipAddress: req.ip,
        deviceInfo: req.headers['user-agent'],
        refreshedAt: Date.now()
      });

      if (!sessionInfo || !sessionInfo.sessionId) {
        throw new Error('Failed to create new session');
      }

      // 새로운 JWT 토큰 생성
      const token = jwt.sign(
        { 
          user: { id: user._id },
          sessionId: sessionInfo.sessionId,
          iat: Math.floor(Date.now() / 1000)
        },
        jwtSecret,
        { 
          expiresIn: '24h',
          algorithm: 'HS256'
        }
      );

      res.json({
        success: true,
        message: '토큰이 갱신되었습니다.',
        token,
        sessionId: sessionInfo.sessionId,
        user: {
          _id: user._id,
          name: user.name,
          email: user.email,
          profileImage: user.profileImage
        }
      });

    } catch (error) {
      console.error('Token refresh error:', error);
      res.status(500).json({
        success: false,
        message: '토큰 갱신 중 오류가 발생했습니다.'
      });
    }
  }
};

module.exports = authController;

<backend/controllers/fileController.js>
const File = require('../models/File');
const Message = require('../models/Message');
const Room = require('../models/Room');
const { processFileForRAG } = require('../services/fileService');
const path = require('path');
const fs = require('fs');
const { promisify } = require('util');
const crypto = require('crypto');
const { uploadDir } = require('../middleware/upload');

const fsPromises = {
  writeFile: promisify(fs.writeFile),
  unlink: promisify(fs.unlink),
  access: promisify(fs.access),
  mkdir: promisify(fs.mkdir),
  rename: promisify(fs.rename)
};

const isPathSafe = (filepath, directory) => {
  const resolvedPath = path.resolve(filepath);
  const resolvedDirectory = path.resolve(directory);
  return resolvedPath.startsWith(resolvedDirectory);
};

const generateSafeFilename = (originalFilename) => {
  const ext = path.extname(originalFilename || '').toLowerCase();
  const timestamp = Date.now();
  const randomBytes = crypto.randomBytes(8).toString('hex');
  return `${timestamp}_${randomBytes}${ext}`;
};

// 개선된 파일 정보 조회 함수
const getFileFromRequest = async (req) => {
  try {
    const filename = req.params.filename;
    const token = req.headers['x-auth-token'] || req.query.token;
    const sessionId = req.headers['x-session-id'] || req.query.sessionId;
    
    if (!filename) {
      throw new Error('Invalid filename');
    }

    if (!token || !sessionId) {
      throw new Error('Authentication required');
    }

    const filePath = path.join(uploadDir, filename);
    if (!isPathSafe(filePath, uploadDir)) {
      throw new Error('Invalid file path');
    }

    await fsPromises.access(filePath, fs.constants.R_OK);

    const file = await File.findOne({ filename: filename });
    if (!file) {
      throw new Error('File not found in database');
    }

    // 채팅방 권한 검증을 위한 메시지 조회
    const message = await Message.findOne({ file: file._id });
    if (!message) {
      throw new Error('File message not found');
    }

    // 사용자가 해당 채팅방의 참가자인지 확인
    const room = await Room.findOne({
      _id: message.room,
      participants: req.user.id
    });

    if (!room) {
      throw new Error('Unauthorized access');
    }

    return { file, filePath };
  } catch (error) {
    console.error('getFileFromRequest error:', {
      filename: req.params.filename,
      error: error.message
    });
    throw error;
  }
};

exports.uploadFile = async (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({
        success: false,
        message: '파일이 선택되지 않았습니다.'
      });
    }

    const safeFilename = generateSafeFilename(req.file.originalname);
    const currentPath = req.file.path;
    const newPath = path.join(uploadDir, safeFilename);

    const file = new File({
      filename: safeFilename,
      originalname: req.file.originalname,
      mimetype: req.file.mimetype,
      size: req.file.size,
      user: req.user.id,
      path: newPath
    });

    await file.save();
    await fsPromises.rename(currentPath, newPath);

    res.status(200).json({
      success: true,
      message: '파일 업로드 성공',
      file: {
        _id: file._id,
        filename: file.filename,
        originalname: file.originalname,
        mimetype: file.mimetype,
        size: file.size,
        uploadDate: file.uploadDate
      }
    });

  } catch (error) {
    console.error('File upload error:', error);
    if (req.file?.path) {
      try {
        await fsPromises.unlink(req.file.path);
      } catch (unlinkError) {
        console.error('Failed to delete uploaded file:', unlinkError);
      }
    }
    res.status(500).json({
      success: false,
      message: '파일 업로드 중 오류가 발생했습니다.',
      error: error.message
    });
  }
};

exports.downloadFile = async (req, res) => {
  try {
    const { file, filePath } = await getFileFromRequest(req);
    const contentDisposition = file.getContentDisposition('attachment');

    res.set({
      'Content-Type': file.mimetype,
      'Content-Length': file.size,
      'Content-Disposition': contentDisposition,
      'Cache-Control': 'private, no-cache, no-store, must-revalidate',
      'Pragma': 'no-cache',
      'Expires': '0'
    });

    const fileStream = fs.createReadStream(filePath);
    fileStream.on('error', (error) => {
      console.error('File streaming error:', error);
      if (!res.headersSent) {
        res.status(500).json({
          success: false,
          message: '파일 스트리밍 중 오류가 발생했습니다.'
        });
      }
    });

    fileStream.pipe(res);

  } catch (error) {
    handleFileError(error, res);
  }
};

exports.viewFile = async (req, res) => {
  try {
    const { file, filePath } = await getFileFromRequest(req);

    if (!file.isPreviewable()) {
      return res.status(415).json({
        success: false,
        message: '미리보기를 지원하지 않는 파일 형식입니다.'
      });
    }

    const contentDisposition = file.getContentDisposition('inline');
        
    res.set({
      'Content-Type': file.mimetype,
      'Content-Disposition': contentDisposition,
      'Content-Length': file.size,
      'Cache-Control': 'public, max-age=31536000, immutable'
    });

    const fileStream = fs.createReadStream(filePath);
    fileStream.on('error', (error) => {
      console.error('File streaming error:', error);
      if (!res.headersSent) {
        res.status(500).json({
          success: false,
          message: '파일 스트리밍 중 오류가 발생했습니다.'
        });
      }
    });

    fileStream.pipe(res);

  } catch (error) {
    handleFileError(error, res);
  }
};

const handleFileStream = (fileStream, res) => {
  fileStream.on('error', (error) => {
    console.error('File streaming error:', error);
    if (!res.headersSent) {
      res.status(500).json({
        success: false,
        message: '파일 스트리밍 중 오류가 발생했습니다.'
      });
    }
  });

  fileStream.pipe(res);
};

const handleFileError = (error, res) => {
  console.error('File operation error:', {
    message: error.message,
    stack: error.stack
  });

  // 에러 상태 코드 및 메시지 매핑
  const errorResponses = {
    'Invalid filename': { status: 400, message: '잘못된 파일명입니다.' },
    'Authentication required': { status: 401, message: '인증이 필요합니다.' },
    'Invalid file path': { status: 400, message: '잘못된 파일 경로입니다.' },
    'File not found in database': { status: 404, message: '파일을 찾을 수 없습니다.' },
    'File message not found': { status: 404, message: '파일 메시지를 찾을 수 없습니다.' },
    'Unauthorized access': { status: 403, message: '파일에 접근할 권한이 없습니다.' },
    'ENOENT': { status: 404, message: '파일을 찾을 수 없습니다.' }
  };

  const errorResponse = errorResponses[error.message] || {
    status: 500,
    message: '파일 처리 중 오류가 발생했습니다.'
  };

  res.status(errorResponse.status).json({
    success: false,
    message: errorResponse.message
  });
};

exports.deleteFile = async (req, res) => {
  try {
    const file = await File.findById(req.params.id);
    
    if (!file) {
      return res.status(404).json({
        success: false,
        message: '파일을 찾을 수 없습니다.'
      });
    }

    if (file.user.toString() !== req.user.id) {
      return res.status(403).json({
        success: false,
        message: '파일을 삭제할 권한이 없습니다.'
      });
    }

    const filePath = path.join(uploadDir, file.filename);

    if (!isPathSafe(filePath, uploadDir)) {
      return res.status(403).json({
        success: false,
        message: '잘못된 파일 경로입니다.'
      });
    }
    
    try {
      await fsPromises.access(filePath, fs.constants.W_OK);
      await fsPromises.unlink(filePath);
    } catch (unlinkError) {
      console.error('File deletion error:', unlinkError);
    }

    await file.deleteOne();

    res.json({
      success: true,
      message: '파일이 삭제되었습니다.'
    });
  } catch (error) {
    console.error('File deletion error:', error);
    res.status(500).json({
      success: false,
      message: '파일 삭제 중 오류가 발생했습니다.',
      error: error.message
    });
  }
};

<backend/controllers/userController.js>
const bcrypt = require('bcryptjs');
const User = require('../models/User');
const { upload } = require('../middleware/upload');
const path = require('path');
const fs = require('fs').promises;

// 회원가입
exports.register = async (req, res) => {
  try {
    const { name, email, password } = req.body;

    // 입력값 검증
    const validationErrors = [];
    
    if (!name || name.trim().length === 0) {
      validationErrors.push({
        field: 'name',
        message: '이름을 입력해주세요.'
      });
    } else if (name.length < 2) {
      validationErrors.push({
        field: 'name',
        message: '이름은 2자 이상이어야 합니다.'
      });
    }

    if (!email) {
      validationErrors.push({
        field: 'email',
        message: '이메일을 입력해주세요.'
      });
    } else if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) {
      validationErrors.push({
        field: 'email',
        message: '올바른 이메일 형식이 아닙니다.'
      });
    }

    if (!password) {
      validationErrors.push({
        field: 'password',
        message: '비밀번호를 입력해주세요.'
      });
    } else if (password.length < 6) {
      validationErrors.push({
        field: 'password',
        message: '비밀번호는 6자 이상이어야 합니다.'
      });
    }

    if (validationErrors.length > 0) {
      return res.status(400).json({
        success: false,
        errors: validationErrors
      });
    }

    // 사용자 중복 확인
    const existingUser = await User.findOne({ email });
    if (existingUser) {
      return res.status(409).json({
        success: false,
        message: '이미 가입된 이메일입니다.'
      });
    }

    // 비밀번호 암호화 및 사용자 생성
    const newUser = new User({ 
      name, 
      email, 
      password,
      profileImage: '' // 기본 프로필 이미지 없음
    });

    const salt = await bcrypt.genSalt(10);
    newUser.password = await bcrypt.hash(password, salt);
    await newUser.save();

    res.status(201).json({
      success: true,
      message: '회원가입이 완료되었습니다.',
      user: {
        id: newUser._id,
        name: newUser.name,
        email: newUser.email,
        profileImage: newUser.profileImage
      }
    });

  } catch (error) {
    console.error('Registration error:', error);
    res.status(500).json({
      success: false,
      message: '회원가입 처리 중 오류가 발생했습니다.'
    });
  }
};

// 프로필 조회
exports.getProfile = async (req, res) => {
  try {
    const user = await User.findById(req.user.id).select('-password');
    if (!user) {
      return res.status(404).json({
        success: false,
        message: '사용자를 찾을 수 없습니다.'
      });
    }

    res.json({
      success: true,
      user: {
        id: user._id,
        name: user.name,
        email: user.email,
        profileImage: user.profileImage
      }
    });

  } catch (error) {
    console.error('Get profile error:', error);
    res.status(500).json({
      success: false,
      message: '프로필 조회 중 오류가 발생했습니다.'
    });
  }
};

// 프로필 업데이트
exports.updateProfile = async (req, res) => {
  try {
    const { name } = req.body;

    if (!name || name.trim().length === 0) {
      return res.status(400).json({
        success: false,
        message: '이름을 입력해주세요.'
      });
    }

    const user = await User.findById(req.user.id);
    if (!user) {
      return res.status(404).json({
        success: false,
        message: '사용자를 찾을 수 없습니다.'
      });
    }

    user.name = name.trim();
    await user.save();

    res.json({
      success: true,
      message: '프로필이 업데이트되었습니다.',
      user: {
        id: user._id,
        name: user.name,
        email: user.email,
        profileImage: user.profileImage
      }
    });

  } catch (error) {
    console.error('Update profile error:', error);
    res.status(500).json({
      success: false,
      message: '프로필 업데이트 중 오류가 발생했습니다.'
    });
  }
};

// 프로필 이미지 업로드
exports.uploadProfileImage = async (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({
        success: false,
        message: '이미지가 제공되지 않았습니다.'
      });
    }

    // 파일 유효성 검사
    const fileSize = req.file.size;
    const fileType = req.file.mimetype;
    const maxSize = 5 * 1024 * 1024; // 5MB

    if (fileSize > maxSize) {
      // 업로드된 파일 삭제
      await fs.unlink(req.file.path);
      return res.status(400).json({
        success: false,
        message: '파일 크기는 5MB를 초과할 수 없습니다.'
      });
    }

    if (!fileType.startsWith('image/')) {
      // 업로드된 파일 삭제
      await fs.unlink(req.file.path);
      return res.status(400).json({
        success: false,
        message: '이미지 파일만 업로드할 수 있습니다.'
      });
    }

    const user = await User.findById(req.user.id);
    if (!user) {
      // 업로드된 파일 삭제
      await fs.unlink(req.file.path);
      return res.status(404).json({
        success: false,
        message: '사용자를 찾을 수 없습니다.'
      });
    }

    // 기존 프로필 이미지가 있다면 삭제
    if (user.profileImage) {
      const oldImagePath = path.join(__dirname, '..', user.profileImage);
      try {
        await fs.access(oldImagePath);
        await fs.unlink(oldImagePath);
      } catch (error) {
        console.error('Old profile image delete error:', error);
      }
    }

    // 새 이미지 경로 저장
    const imageUrl = `/uploads/${req.file.filename}`;
    user.profileImage = imageUrl;
    await user.save();

    res.json({
      success: true,
      message: '프로필 이미지가 업데이트되었습니다.',
      imageUrl: user.profileImage
    });

  } catch (error) {
    console.error('Profile image upload error:', error);
    // 업로드 실패 시 파일 삭제
    if (req.file) {
      try {
        await fs.unlink(req.file.path);
      } catch (unlinkError) {
        console.error('File delete error:', unlinkError);
      }
    }
    res.status(500).json({
      success: false,
      message: '이미지 업로드 중 오류가 발생했습니다.'
    });
  }
};

// 프로필 이미지 삭제
exports.deleteProfileImage = async (req, res) => {
  try {
    const user = await User.findById(req.user.id);
    if (!user) {
      return res.status(404).json({
        success: false,
        message: '사용자를 찾을 수 없습니다.'
      });
    }

    if (user.profileImage) {
      const imagePath = path.join(__dirname, '..', user.profileImage);
      try {
        await fs.access(imagePath);
        await fs.unlink(imagePath);
      } catch (error) {
        console.error('Profile image delete error:', error);
      }

      user.profileImage = '';
      await user.save();
    }

    res.json({
      success: true,
      message: '프로필 이미지가 삭제되었습니다.'
    });

  } catch (error) {
    console.error('Delete profile image error:', error);
    res.status(500).json({
      success: false,
      message: '프로필 이미지 삭제 중 오류가 발생했습니다.'
    });
  }
};

// 회원 탈퇴
exports.deleteAccount = async (req, res) => {
  try {
    const user = await User.findById(req.user.id);
    if (!user) {
      return res.status(404).json({
        success: false,
        message: '사용자를 찾을 수 없습니다.'
      });
    }

    // 프로필 이미지가 있다면 삭제
    if (user.profileImage) {
      const imagePath = path.join(__dirname, '..', user.profileImage);
      try {
        await fs.access(imagePath);
        await fs.unlink(imagePath);
      } catch (error) {
        console.error('Profile image delete error:', error);
      }
    }

    await user.deleteOne();

    res.json({
      success: true,
      message: '회원 탈퇴가 완료되었습니다.'
    });

  } catch (error) {
    console.error('Delete account error:', error);
    res.status(500).json({
      success: false,
      message: '회원 탈퇴 처리 중 오류가 발생했습니다.'
    });
  }
};

module.exports = exports;

<backend/middleware/auth.js>
// backend/middleware/auth.js

const jwt = require('jsonwebtoken');
const { jwtSecret } = require('../config/keys');
const SessionService = require('../services/sessionService');

const auth = async (req, res, next) => {
  try {
    // 헤더 또는 쿼리 파라미터에서 토큰과 세션ID 가져오기
    const token = req.header('x-auth-token') || req.query.token;
    const sessionId = req.header('x-session-id') || req.query.sessionId;

    if (!token || !sessionId) {
      return res.status(401).json({
        success: false,
        message: '인증 토큰이 없습니다.'
      });
    }

    try {
      // 토큰 검증
      const decoded = jwt.verify(token, jwtSecret);
      req.user = decoded.user;

      // 세션 검증
      const validationResult = await SessionService.validateSession(decoded.user.id, sessionId);
      
      if (!validationResult.isValid) {
        return res.status(401).json({
          success: false,
          code: validationResult.error,
          message: validationResult.message
        });
      }

      next();
    } catch (err) {
      if (err.name === 'TokenExpiredError') {
        return res.status(401).json({
          success: false,
          message: '토큰이 만료되었습니다.'
        });
      }

      if (err.name === 'JsonWebTokenError') {
        return res.status(401).json({
          success: false,
          message: '유효하지 않은 토큰입니다.'
        });
      }

      throw err;
    }
  } catch (err) {
    console.error('Auth middleware error:', err);
    res.status(500).json({
      success: false,
      message: '서버 오류가 발생했습니다.'
    });
  }
};

module.exports = auth;

<backend/middleware/upload.js>
// backend/middleware/upload.js
const multer = require('multer');
const path = require('path');
const fs = require('fs');
const crypto = require('crypto');

// uploads 디렉토리 절대 경로 설정
const uploadDir = path.join(__dirname, '../uploads');

// uploads 디렉토리 생성 및 권한 설정
if (!fs.existsSync(uploadDir)) {
  fs.mkdirSync(uploadDir, { recursive: true });
  fs.chmodSync(uploadDir, '0755');
}

// MIME 타입과 확장자 매핑
const ALLOWED_TYPES = {
  'image/jpeg': ['.jpg', '.jpeg'],
  'image/png': ['.png'],
  'image/gif': ['.gif'],
  'image/webp': ['.webp'],
  'video/mp4': ['.mp4'],
  'video/webm': ['.webm'],
  'video/quicktime': ['.mov'],
  'audio/mpeg': ['.mp3'],
  'audio/wav': ['.wav'],
  'audio/ogg': ['.ogg'],
  'application/pdf': ['.pdf'],
  'application/msword': ['.doc'],
  'application/vnd.openxmlformats-officedocument.wordprocessingml.document': ['.docx']
};

// 파일 타입별 크기 제한 설정
const FILE_SIZE_LIMITS = {
  image: 10 * 1024 * 1024,  // 10MB for images
  video: 50 * 1024 * 1024,  // 50MB for videos
  audio: 20 * 1024 * 1024,  // 20MB for audio
  document: 20 * 1024 * 1024 // 20MB for documents
};

const storage = multer.diskStorage({
  destination: function (req, file, cb) {
    if (!fs.existsSync(uploadDir)) {
      fs.mkdirSync(uploadDir, { recursive: true });
    }
    cb(null, uploadDir);
  },
  filename: function (req, file, cb) {
    try {
      // 원본 파일명을 버퍼로 변환하여 UTF-8로 디코딩
      const originalname = Buffer.from(file.originalname, 'binary').toString('utf8');
      
      // 원본 파일명을 req 객체에 저장
      req.originalFileName = originalname;

      // 파일 확장자 추출
      const ext = path.extname(originalname).toLowerCase();
      
      // 안전한 파일명 생성 (타임스탬프 + 랜덤 문자열 + 확장자)
      const timestamp = Date.now();
      const randomString = crypto.randomBytes(8).toString('hex');
      const safeFilename = `${timestamp}_${randomString}${ext}`;

      // 파일 확장자 검증
      const allowedExtensions = Object.values(ALLOWED_TYPES).flat();
      if (!allowedExtensions.includes(ext)) {
        return cb(new Error('지원하지 않는 파일 확장자입니다.'));
      }

      cb(null, safeFilename);
    } catch (error) {
      console.error('Filename processing error:', error);
      cb(new Error('파일명 처리 중 오류가 발생했습니다.'));
    }
  }
});

const getFileType = (mimetype) => {
  const typeMap = {
    'image': '이미지',
    'video': '동영상',
    'audio': '오디오',
    'application': '문서'
  };
  const type = mimetype.split('/')[0];
  return typeMap[type] || '파일';
};

const validateFileSize = (file) => {
  const type = file.mimetype.split('/')[0];
  const limit = FILE_SIZE_LIMITS[type] || FILE_SIZE_LIMITS.document;
  
  if (file.size > limit) {
    const limitInMB = Math.floor(limit / 1024 / 1024);
    throw new Error(`${getFileType(file.mimetype)} 파일은 ${limitInMB}MB를 초과할 수 없습니다.`);
  }
  return true;
};

const fileFilter = (req, file, cb) => {
  try {
    // 파일명을 UTF-8로 디코딩
    const originalname = Buffer.from(file.originalname, 'binary').toString('utf8');
    
    // MIME 타입 검증
    if (!ALLOWED_TYPES[file.mimetype]) {
      const fileType = getFileType(file.mimetype);
      return cb(new Error(`지원하지 않는 ${fileType} 형식입니다.`), false);
    }

    // Content-Length 헤더 검증
    const declaredSize = parseInt(req.headers['content-length']);
    if (declaredSize > 50 * 1024 * 1024) {
      return cb(new Error('파일 크기는 50MB를 초과할 수 없습니다.'), false);
    }

    // 파일명 길이 검증 (UTF-8 바이트 길이 기준)
    const filenameBytes = Buffer.from(originalname, 'utf8').length;
    if (filenameBytes > 255) {
      return cb(new Error('파일명이 너무 깁니다.'), false);
    }

    // 파일 확장자와 MIME 타입 일치 여부 확인
    const ext = path.extname(originalname).toLowerCase();
    if (!ALLOWED_TYPES[file.mimetype].includes(ext)) {
      const fileType = getFileType(file.mimetype);
      return cb(new Error(`${fileType} 확장자가 올바르지 않습니다.`), false);
    }

    // 원본 파일명을 multer의 file 객체에 저장
    file.originalname = originalname;

    cb(null, true);
  } catch (error) {
    console.error('File filter error:', error);
    cb(error);
  }
};

// multer 인스턴스 생성
const uploadMiddleware = multer({
  storage: storage,
  limits: {
    fileSize: 50 * 1024 * 1024, // 50MB
    files: 1 // 한 번에 하나의 파일만 업로드 가능
  },
  fileFilter: fileFilter
});

// 에러 핸들러 미들웨어
const errorHandler = (error, req, res, next) => {
  console.error('File upload error:', {
    error: error.message,
    stack: error.stack,
    file: req.file
  });

  // 업로드된 파일이 있다면 삭제
  if (req.file) {
    try {
      fs.unlinkSync(req.file.path);
    } catch (unlinkError) {
      console.error('Failed to delete uploaded file:', unlinkError);
    }
  }

  if (error instanceof multer.MulterError) {
    switch (error.code) {
      case 'LIMIT_FILE_SIZE':
        return res.status(413).json({
          success: false,
          message: '파일 크기는 50MB를 초과할 수 없습니다.'
        });
      case 'LIMIT_FILE_COUNT':
        return res.status(400).json({
          success: false,
          message: '한 번에 하나의 파일만 업로드할 수 있습니다.'
        });
      case 'LIMIT_UNEXPECTED_FILE':
        return res.status(400).json({
          success: false,
          message: '잘못된 형식의 파일입니다.'
        });
      default:
        return res.status(400).json({
          success: false,
          message: `파일 업로드 오류: ${error.message}`
        });
    }
  }
  
  if (error) {
    return res.status(400).json({
      success: false,
      message: error.message || '파일 업로드 중 오류가 발생했습니다.'
    });
  }
  
  next();
};

// 파일 경로 검증 함수
const isPathSafe = (filepath) => {
  try {
    const resolvedPath = path.resolve(filepath);
    const resolvedUploadDir = path.resolve(uploadDir);
    return resolvedPath.startsWith(resolvedUploadDir);
  } catch (error) {
    console.error('Path validation error:', error);
    return false;
  }
};

module.exports = {
  upload: uploadMiddleware,
  errorHandler,
  uploadDir,
  isPathSafe,
  validateFileSize,
  ALLOWED_TYPES,
  getFileType
};

<backend/models/File.js>
const mongoose = require('mongoose');

const FileSchema = new mongoose.Schema({
  filename: { 
    type: String, 
    required: true,
    index: true,
    validate: {
      validator: function(v) {
        return /^[0-9]+_[a-f0-9]+\.[a-z0-9]+$/.test(v);
      },
      message: '올바르지 않은 파일명 형식입니다.'
    }
  },
  originalname: { 
    type: String,
    required: true,
    set: function(name) {
      try {
        if (!name) return '';
        
        // 파일명에서 경로 구분자 제거
        const sanitizedName = name.replace(/[\/\\]/g, '');
        
        // 유니코드 정규화 (NFC)
        return sanitizedName.normalize('NFC');
      } catch (error) {
        console.error('Filename sanitization error:', error);
        return name;
      }
    },
    get: function(name) {
      try {
        if (!name) return '';
        
        // 유니코드 정규화된 형태로 반환
        return name.normalize('NFC');
      } catch (error) {
        console.error('Filename retrieval error:', error);
        return name;
      }
    }
  },
  mimetype: { 
    type: String,
    required: true
  },
  size: { 
    type: Number,
    required: true,
    min: 0
  },
  user: { 
    type: mongoose.Schema.Types.ObjectId, 
    ref: 'User',
    required: true,
    index: true
  },
  path: { 
    type: String,
    required: true
  },
  uploadDate: { 
    type: Date, 
    default: Date.now,
    index: true
  }
}, {
  timestamps: true,
  toJSON: { getters: true },
  toObject: { getters: true }
});

// 복합 인덱스
FileSchema.index({ filename: 1, user: 1 }, { unique: true });

// 파일 삭제 전 처리
FileSchema.pre('remove', async function(next) {
  try {
    const fs = require('fs').promises;
    if (this.path) {
      await fs.unlink(this.path);
    }
    next();
  } catch (error) {
    console.error('File removal error:', error);
    next(error);
  }
});

// URL 안전한 파일명 생성을 위한 유틸리티 메서드
FileSchema.methods.getSafeFilename = function() {
  return this.filename;
};

// Content-Disposition 헤더를 위한 파일명 인코딩 메서드
FileSchema.methods.getEncodedFilename = function() {
  try {
    const filename = this.originalname;
    if (!filename) return '';

    // RFC 5987에 따른 인코딩
    const encodedFilename = encodeURIComponent(filename)
      .replace(/'/g, "%27")
      .replace(/\(/g, "%28")
      .replace(/\)/g, "%29")
      .replace(/\*/g, "%2A");

    return {
      legacy: filename.replace(/[^\x20-\x7E]/g, ''), // ASCII only for legacy clients
      encoded: `UTF-8''${encodedFilename}` // RFC 5987 format
    };
  } catch (error) {
    console.error('Filename encoding error:', error);
    return {
      legacy: this.filename,
      encoded: this.filename
    };
  }
};

// 파일 URL 생성을 위한 유틸리티 메서드
FileSchema.methods.getFileUrl = function(type = 'download') {
  return `/api/files/${type}/${encodeURIComponent(this.filename)}`;
};

// 다운로드용 Content-Disposition 헤더 생성 메서드
FileSchema.methods.getContentDisposition = function(type = 'attachment') {
  const { legacy, encoded } = this.getEncodedFilename();
  return `${type}; filename="${legacy}"; filename*=${encoded}`;
};

// 파일 MIME 타입 검증 메서드
FileSchema.methods.isPreviewable = function() {
  const previewableTypes = [
    'image/jpeg', 'image/png', 'image/gif', 'image/webp',
    'video/mp4', 'video/webm',
    'audio/mpeg', 'audio/wav',
    'application/pdf'
  ];
  return previewableTypes.includes(this.mimetype);
};

module.exports = mongoose.model('File', FileSchema);

<backend/models/Message.js>
const mongoose = require('mongoose');

const MessageSchema = new mongoose.Schema({
  room: { 
    type: String, 
    required: [true, '채팅방 ID는 필수입니다.'],
    index: true
  },
  content: { 
    type: String,
    required: function() {
      return this.type !== 'file';
    },
    trim: true,
    maxlength: [10000, '메시지는 10000자를 초과할 수 없습니다.']
  },
  sender: { 
    type: mongoose.Schema.Types.ObjectId, 
    ref: 'User',
    index: true 
  },
  type: { 
    type: String, 
    enum: ['text', 'system', 'ai', 'file'], 
    default: 'text',
    index: true
  },
  file: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'File',
    required: function() {
      return this.type === 'file';
    }
  },
  aiType: {
    type: String,
    enum: ['wayneAI', 'consultingAI'],
    required: function() { 
      return this.type === 'ai'; 
    }
  },
  mentions: [{ 
    type: String,
    trim: true
  }],
  timestamp: { 
    type: Date, 
    default: Date.now,
    index: true 
  },
  readers: [{
    userId: { 
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User',
      required: true
    },
    readAt: { 
      type: Date,
      default: Date.now,
      required: true
    }
  }],
  reactions: {
    type: Map,
    of: [{
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User'
    }],
    default: new Map()
  },
  metadata: {
    type: Map,
    of: mongoose.Schema.Types.Mixed,
    default: new Map()
  },
  isDeleted: {
    type: Boolean,
    default: false,
    index: true
  }
}, {
  timestamps: true,
  toJSON: { 
    virtuals: true,
    getters: true 
  },
  toObject: { 
    virtuals: true,
    getters: true 
  }
});

// 복합 인덱스 설정
MessageSchema.index({ room: 1, timestamp: -1 });
MessageSchema.index({ room: 1, isDeleted: 1 });
MessageSchema.index({ 'readers.userId': 1 });
MessageSchema.index({ sender: 1 });
MessageSchema.index({ type: 1 });
MessageSchema.index({ timestamp: -1 });
MessageSchema.index({ 'reactions.userId': 1 });

// 읽음 처리 Static 메소드 개선
MessageSchema.statics.markAsRead = async function(messageIds, userId) {
  if (!messageIds?.length || !userId) return;

  const bulkOps = messageIds.map(messageId => ({
    updateOne: {
      filter: {
        _id: messageId,
        isDeleted: false,
        'readers.userId': { $ne: userId }
      },
      update: {
        $push: {
          readers: {
            userId: new mongoose.Types.ObjectId(userId),
            readAt: new Date()
          }
        }
      }
    }
  }));

  try {
    const result = await this.bulkWrite(bulkOps, { ordered: false });
    return result.modifiedCount;
  } catch (error) {
    console.error('Mark as read error:', {
      error,
      messageIds,
      userId
    });
    throw error;
  }
};

// 리액션 처리 메소드 개선
MessageSchema.methods.addReaction = async function(emoji, userId) {
  try {
    if (!this.reactions) {
      this.reactions = new Map();
    }

    const userReactions = this.reactions.get(emoji) || [];
    if (!userReactions.includes(userId)) {
      userReactions.push(userId);
      this.reactions.set(emoji, userReactions);
      await this.save();
    }
    
    return this.reactions.get(emoji);
  } catch (error) {
    console.error('Add reaction error:', {
      error,
      messageId: this._id,
      emoji,
      userId
    });
    throw error;
  }
};

MessageSchema.methods.removeReaction = async function(emoji, userId) {
  try {
    if (!this.reactions || !this.reactions.has(emoji)) return;

    const userReactions = this.reactions.get(emoji) || [];
    const updatedReactions = userReactions.filter(id => 
      id.toString() !== userId.toString()
    );
    
    if (updatedReactions.length === 0) {
      this.reactions.delete(emoji);
    } else {
      this.reactions.set(emoji, updatedReactions);
    }
    
    await this.save();
    return this.reactions.get(emoji);
  } catch (error) {
    console.error('Remove reaction error:', {
      error,
      messageId: this._id,
      emoji,
      userId
    });
    throw error;
  }
};

// 메시지 소프트 삭제 메소드 추가
MessageSchema.methods.softDelete = async function() {
  this.isDeleted = true;
  await this.save();
};

// 메시지 삭제 전 후크 개선
MessageSchema.pre('remove', async function(next) {
  try {
    if (this.type === 'file' && this.file) {
      const File = mongoose.model('File');
      await File.findByIdAndDelete(this.file);
    }
    next();
  } catch (error) {
    console.error('Message pre-remove error:', {
      error,
      messageId: this._id,
      type: this.type
    });
    next(error);
  }
});

// 메시지 저장 전 후크 개선
MessageSchema.pre('save', function(next) {
  try {
    if (this.content && this.type !== 'file') {
      this.content = this.content.trim();
    }

    if (this.mentions?.length) {
      this.mentions = [...new Set(this.mentions)];
    }

    next();
  } catch (error) {
    console.error('Message pre-save error:', {
      error,
      messageId: this._id
    });
    next(error);
  }
});

// JSON 변환 메소드 개선
MessageSchema.methods.toJSON = function() {
  try {
    const obj = this.toObject();
    
    // 불필요한 필드 제거
    delete obj.__v;
    delete obj.updatedAt;
    delete obj.isDeleted;
    
    // reactions Map을 일반 객체로 변환
    if (obj.reactions) {
      obj.reactions = Object.fromEntries(obj.reactions);
    }

    return obj;
  } catch (error) {
    console.error('Message toJSON error:', {
      error,
      messageId: this._id
    });
    return {};
  }
};

const Message = mongoose.model('Message', MessageSchema);
module.exports = Message;

<backend/models/Room.js>
const mongoose = require('mongoose');
const bcrypt = require('bcryptjs');

const RoomSchema = new mongoose.Schema({
  name: {
    type: String,
    required: true,
    trim: true
  },
  creator: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  hasPassword: {
    type: Boolean,
    default: false
  },
  password: {
    type: String,
    select: false
  },
  createdAt: {
    type: Date,
    default: Date.now
  },
  participants: [{
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User'
  }]
});

// 비밀번호 해싱 미들웨어
RoomSchema.pre('save', async function(next) {
  if (this.isModified('password') && this.password) {
    const salt = await bcrypt.genSalt(10);
    this.password = await bcrypt.hash(this.password, salt);
    this.hasPassword = true;
  }
  if (!this.password) {
    this.hasPassword = false;
  }
  next();
});

// 비밀번호 확인 메서드
RoomSchema.methods.checkPassword = async function(password) {
  if (!this.hasPassword) return true;
  const room = await this.constructor.findById(this._id).select('+password');
  return await bcrypt.compare(password, room.password);
};

module.exports = mongoose.model('Room', RoomSchema);

<backend/models/User.js>
const mongoose = require('mongoose');
const bcrypt = require('bcryptjs');
const { encryptionKey, passwordSalt } = require('../config/keys');
const crypto = require('crypto');

const UserSchema = new mongoose.Schema({
  name: {
    type: String,
    required: [true, '이름은 필수 입력 항목입니다.'],
    trim: true,
    minlength: [2, '이름은 2자 이상이어야 합니다.']
  },
  email: {
    type: String,
    required: [true, '이메일은 필수 입력 항목입니다.'],
    unique: true,
    trim: true,
    lowercase: true,
    match: [
      /^[^\s@]+@[^\s@]+\.[^\s@]+$/,
      '올바른 이메일 형식이 아닙니다.'
    ]
  },
  encryptedEmail: {
    type: String,
    unique: true,
    sparse: true
  },
  password: {
    type: String,
    required: [true, '비밀번호는 필수 입력 항목입니다.'],
    minlength: [6, '비밀번호는 6자 이상이어야 합니다.'],
    select: false
  },
  profileImage: {
    type: String,
    default: ''
  },
  createdAt: {
    type: Date,
    default: Date.now
  },
  lastActive: {
    type: Date,
    default: Date.now
  }
});

// 이메일 암호화 함수
function encryptEmail(email) {
  if (!email) return null;
  try {
    const iv = crypto.randomBytes(16);
    const cipher = crypto.createCipheriv('aes-256-cbc', Buffer.from(encryptionKey, 'hex'), iv);
    let encrypted = cipher.update(email, 'utf8', 'hex');
    encrypted += cipher.final('hex');
    return iv.toString('hex') + ':' + encrypted;
  } catch (error) {
    console.error('Email encryption error:', error);
    return null;
  }
}

// 비밀번호 해싱 및 이메일 암호화 미들웨어
UserSchema.pre('save', async function(next) {
  try {
    // 비밀번호 변경 시에만 해싱
    if (this.isModified('password')) {
      const salt = await bcrypt.genSalt(10);
      this.password = await bcrypt.hash(this.password, salt);
    }

    // 이메일 변경 시에만 암호화
    if (this.isModified('email')) {
      this.encryptedEmail = encryptEmail(this.email);
    }

    next();
  } catch (error) {
    next(error);
  }
});

// 비밀번호 비교 메서드
UserSchema.methods.matchPassword = async function(enteredPassword) {
  try {
    const user = await this.constructor.findById(this._id).select('+password');
    if (!user || !user.password) {
      return false;
    }
    return await bcrypt.compare(enteredPassword, user.password);
  } catch (error) {
    console.error('Password match error:', error);
    return false;
  }
};

// 토큰 생성 메서드
UserSchema.methods.generateVerificationToken = function() {
  const crypto = require('crypto');
  const token = crypto.randomBytes(32).toString('hex');
  return token;
};

// 활성 상태 업데이트 메서드
UserSchema.methods.updateLastActive = async function() {
  this.lastActive = new Date();
  return this.save();
};

// 사용자 정보 변경 메서드
UserSchema.methods.updateProfile = async function(updateData) {
  const allowedUpdates = ['name', 'profileImage'];
  const updates = {};

  Object.keys(updateData).forEach(key => {
    if (allowedUpdates.includes(key)) {
      updates[key] = updateData[key];
    }
  });

  Object.assign(this, updates);
  return this.save();
};

// 비밀번호 변경 메서드
UserSchema.methods.changePassword = async function(currentPassword, newPassword) {
  try {
    // 현재 비밀번호 확인
    const isMatch = await this.matchPassword(currentPassword);
    if (!isMatch) {
      throw new Error('현재 비밀번호가 일치하지 않습니다.');
    }

    // 새 비밀번호 설정
    this.password = newPassword;
    return this.save();
  } catch (error) {
    throw error;
  }
};

// 계정 삭제 메서드
UserSchema.methods.deleteAccount = async function() {
  try {
    // 연결된 데이터 삭제 로직 추가
    await this.constructor.deleteOne({ _id: this._id });
    return true;
  } catch (error) {
    throw error;
  }
};

// 이메일 복호화 메서드
UserSchema.methods.decryptEmail = function() {
  if (!this.encryptedEmail) return null;
  
  try {
    const [ivHex, encryptedHex] = this.encryptedEmail.split(':');
    const iv = Buffer.from(ivHex, 'hex');
    const decipher = crypto.createDecipheriv('aes-256-cbc', Buffer.from(encryptionKey, 'hex'), iv);
    let decrypted = decipher.update(encryptedHex, 'hex', 'utf8');
    decrypted += decipher.final('utf8');
    return decrypted;
  } catch (error) {
    console.error('Email decryption error:', error);
    return null;
  }
};

// 인덱스 생성
UserSchema.index({ email: 1 });
UserSchema.index({ encryptedEmail: 1 }, { unique: true, sparse: true });
UserSchema.index({ createdAt: 1 });
UserSchema.index({ lastActive: 1 });

module.exports = mongoose.model('User', UserSchema);

<backend/package.json>
{
  "name": "chat-app-backend",
  "version": "1.0.0",
  "description": "Backend for Chat App",
  "main": "server.js",
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js"
  },
  "dependencies": {
    "axios": "^1.4.0",
    "bcryptjs": "^2.4.3",
    "bull": "^4.10.4",
    "compression": "^1.7.5",
    "cors": "^2.8.5",
    "dotenv": "^16.3.1",
    "express": "^4.18.2",
    "express-rate-limit": "^7.4.1",
    "helmet": "^8.0.0",
    "jsonwebtoken": "^9.0.1",
    "marked": "^14.1.3",
    "mongoose": "^7.3.4",
    "mongoose-cache": "^0.1.5",
    "morgan": "^1.10.0",
    "multer": "^1.4.5-lts.1",
    "pdf-parse": "^1.1.1",
    "redis": "^4.6.7",
    "socket.io": "^4.7.2"
  },
  "devDependencies": {
    "nodemon": "^3.0.1"
  },
  "author": "",
  "license": "ISC"
}


<backend/routes/api/auth.js>
// backend/routes/api/auth.js
const express = require('express');
const router = express.Router();
const auth = require('../../middleware/auth');
const authController = require('../../controllers/authController');

// 상태 확인 라우트
router.get('/', (req, res) => {
  res.json({
    status: 'active',
    routes: {
      '/register': 'POST - 새 사용자 등록',
      '/login': 'POST - 사용자 로그인',
      '/logout': 'POST - 로그아웃 (인증 필요)',
      '/verify-token': 'GET - 토큰 검증',
      '/refresh-token': 'POST - 토큰 갱신 (인증 필요)'
    }
  });
});

// Public routes
router.post('/register', authController.register);
router.post('/login', authController.login);
router.post('/verify-token', authController.verifyToken); // GET /verify-token 라우트 추가

// Protected routes
router.post('/logout', auth, authController.logout);
router.post('/refresh-token', auth, authController.refreshToken);

module.exports = router;

<backend/routes/api/files.js>
// backend/routes/api/files.js
const express = require('express');
const router = express.Router();
const auth = require('../../middleware/auth');
const fileController = require('../../controllers/fileController');
const { upload, errorHandler } = require('../../middleware/upload');

// 파일 업로드
router.post('/upload',
  auth,
  upload.single('file'),
  errorHandler,
  fileController.uploadFile
);

// 파일 다운로드
router.get('/download/:filename',
  auth,
  fileController.downloadFile
);

// 파일 보기 (미리보기용)
router.get('/view/:filename',
  auth,
  fileController.viewFile
);

// 파일 삭제
router.delete('/:id',
  auth,
  fileController.deleteFile
);

module.exports = router;

<backend/routes/api/index.js>
const express = require('express');
const router = express.Router();

// Import route modules
const authRoutes = require('./auth');
const userRoutes = require('./users');
const roomRoutes = require('./rooms');
const fileRoutes = require('./files');

// API documentation route
router.get('/', (req, res) => {
  res.json({
    name: 'Chat App API',
    version: '1.0.0',
    timestamp: new Date().toISOString(),
    endpoints: {
      auth: {
        base: '/auth',
        routes: {
          register: { method: 'POST', path: '/register' },
          login: { method: 'POST', path: '/login' },
          logout: { method: 'POST', path: '/logout' },
          verifyToken: { method: 'GET', path: '/verify-token' },
          refreshToken: { method: 'POST', path: '/refresh-token' }
        }
      },
      users: '/users',
      rooms: '/rooms',
      files: '/files',
    }
  });
});

// Mount routes
router.use('/auth', authRoutes);
router.use('/users', userRoutes);
router.use('/rooms', roomRoutes);
router.use('/files', fileRoutes);

module.exports = router;


<backend/routes/api/message.js>
const express = require('express');
const router = express.Router();
const messageController = require('../controllers/messageController');
const auth = require('../middleware/auth');

// 채팅방의 메시지 목록 조회
router.get('/rooms/:roomId/messages', auth, messageController.loadMessages);

module.exports = router;

<backend/routes/api/rooms.js>
const express = require('express');
const router = express.Router();
const auth = require('../../middleware/auth');
const Room = require('../../models/Room');
const User = require('../../models/User');
const { rateLimit } = require('express-rate-limit');
let io;

// 속도 제한 설정
const limiter = rateLimit({
  windowMs: 1 * 60 * 1000, // 1분
  max: 60, // IP당 최대 요청 수
  message: {
    success: false,
    error: {
      message: '너무 많은 요청이 발생했습니다. 잠시 후 다시 시도해주세요.',
      code: 'TOO_MANY_REQUESTS'
    }
  },
  standardHeaders: true,
  legacyHeaders: false
});

// Socket.IO 초기화 함수
const initializeSocket = (socketIO) => {
  io = socketIO;
};

// 서버 상태 확인
router.get('/health', async (req, res) => {
  try {
    const isMongoConnected = require('mongoose').connection.readyState === 1;
    const recentRoom = await Room.findOne()
      .sort({ createdAt: -1 })
      .select('createdAt')
      .lean();

    const start = process.hrtime();
    await Room.findOne().select('_id').lean();
    const [seconds, nanoseconds] = process.hrtime(start);
    const latency = Math.round((seconds * 1000) + (nanoseconds / 1000000));

    const status = {
      success: true,
      timestamp: new Date().toISOString(),
      services: {
        database: {
          connected: isMongoConnected,
          latency
        }
      },
      lastActivity: recentRoom?.createdAt
    };

    res.set({
      'Cache-Control': 'no-cache, no-store, must-revalidate',
      'Pragma': 'no-cache',
      'Expires': '0'
    });

    res.status(isMongoConnected ? 200 : 503).json(status);

  } catch (error) {
    console.error('Health check error:', error);
    res.status(503).json({
      success: false,
      error: {
        message: '서비스 상태 확인에 실패했습니다.',
        code: 'HEALTH_CHECK_FAILED'
      }
    });
  }
});

// 채팅방 목록 조회 (페이징 적용)
router.get('/', [limiter, auth], async (req, res) => {
  try {
    // 쿼리 파라미터 검증 (페이지네이션)
    const page = Math.max(0, parseInt(req.query.page) || 0);
    const pageSize = Math.min(Math.max(1, parseInt(req.query.pageSize) || 10), 50);
    const skip = page * pageSize;

    // 정렬 설정
    const allowedSortFields = ['createdAt', 'name', 'participantsCount'];
    const sortField = allowedSortFields.includes(req.query.sortField) 
      ? req.query.sortField 
      : 'createdAt';
    const sortOrder = ['asc', 'desc'].includes(req.query.sortOrder)
      ? req.query.sortOrder
      : 'desc';

    // 검색 필터 구성
    const filter = {};
    if (req.query.search) {
      filter.name = { $regex: req.query.search, $options: 'i' };
    }

    // 총 문서 수 조회
    const totalCount = await Room.countDocuments(filter);

    // 채팅방 목록 조회 with 페이지네이션
    const rooms = await Room.find(filter)
      .populate('creator', 'name email')
      .populate('participants', 'name email')
      .sort({ [sortField]: sortOrder === 'desc' ? -1 : 1 })
      .skip(skip)
      .limit(pageSize)
      .lean();

    // 안전한 응답 데이터 구성 
    const safeRooms = rooms.map(room => {
      if (!room) return null;

      const creator = room.creator || { _id: 'unknown', name: '알 수 없음', email: '' };
      const participants = Array.isArray(room.participants) ? room.participants : [];

      return {
        _id: room._id?.toString() || 'unknown',
        name: room.name || '제목 없음',
        hasPassword: !!room.hasPassword,
        creator: {
          _id: creator._id?.toString() || 'unknown',
          name: creator.name || '알 수 없음',
          email: creator.email || ''
        },
        participants: participants.filter(p => p && p._id).map(p => ({
          _id: p._id.toString(),
          name: p.name || '알 수 없음',
          email: p.email || ''
        })),
        participantsCount: participants.length,
        createdAt: room.createdAt || new Date(),
        isCreator: creator._id?.toString() === req.user.id,
      };
    }).filter(room => room !== null);

    // 메타데이터 계산    
    const totalPages = Math.ceil(totalCount / pageSize);
    const hasMore = skip + rooms.length < totalCount;

    // 캐시 설정
    res.set({
      'Cache-Control': 'private, max-age=10',
      'Last-Modified': new Date().toUTCString()
    });

    // 응답 전송
    res.json({
      success: true,
      data: safeRooms,
      metadata: {
        total: totalCount,
        page,
        pageSize,
        totalPages,
        hasMore,
        currentCount: safeRooms.length,
        sort: {
          field: sortField,
          order: sortOrder
        }
      }
    });

  } catch (error) {
    console.error('방 목록 조회 에러:', error);
    const errorResponse = {
      success: false,
      error: {
        message: '채팅방 목록을 불러오는데 실패했습니다.',
        code: 'ROOMS_FETCH_ERROR'
      }
    };

    if (process.env.NODE_ENV === 'development') {
      errorResponse.error.details = error.message;
      errorResponse.error.stack = error.stack;
    }

    res.status(500).json(errorResponse);
  }
});

// 채팅방 생성
router.post('/', auth, async (req, res) => {
  try {
    const { name, password } = req.body;
    
    if (!name?.trim()) {
      return res.status(400).json({ 
        success: false,
        message: '방 이름은 필수입니다.' 
      });
    }

    const newRoom = new Room({
      name: name.trim(),
      creator: req.user.id,
      participants: [req.user.id],
      password: password
    });

    const savedRoom = await newRoom.save();
    const populatedRoom = await Room.findById(savedRoom._id)
      .populate('creator', 'name email')
      .populate('participants', 'name email');
    
    // Socket.IO를 통해 새 채팅방 생성 알림
    if (io) {
      io.to('room-list').emit('roomCreated', {
        ...populatedRoom.toObject(),
        password: undefined
      });
    }
    
    res.status(201).json({
      success: true,
      data: {
        ...populatedRoom.toObject(),
        password: undefined
      }
    });
  } catch (error) {
    console.error('방 생성 에러:', error);
    res.status(500).json({ 
      success: false,
      message: '서버 에러가 발생했습니다.',
      error: error.message 
    });
  }
});

// 특정 채팅방 조회
router.get('/:roomId', auth, async (req, res) => {
  try {
    const room = await Room.findById(req.params.roomId)
      .populate('creator', 'name email')
      .populate('participants', 'name email');

    if (!room) {
      return res.status(404).json({
        success: false,
        message: '채팅방을 찾을 수 없습니다.'
      });
    }

    res.json({
      success: true,
      data: {
        ...room.toObject(),
        password: undefined
      }
    });
  } catch (error) {
    console.error('Room fetch error:', error);
    res.status(500).json({
      success: false,
      message: '채팅방 정보를 불러오는데 실패했습니다.'
    });
  }
});

// 채팅방 입장
router.post('/:roomId/join', auth, async (req, res) => {
  try {
    const { password } = req.body;
    const room = await Room.findById(req.params.roomId).select('+password');
    
    if (!room) {
      return res.status(404).json({
        success: false,
        message: '채팅방을 찾을 수 없습니다.'
      });
    }

    // 비밀번호 확인
    if (room.hasPassword) {
      const isPasswordValid = await room.checkPassword(password);
      if (!isPasswordValid) {
        return res.status(401).json({
          success: false,
          message: '비밀번호가 일치하지 않습니다.'
        });
      }
    }

    // 참여자 목록에 추가
    if (!room.participants.includes(req.user.id)) {
      room.participants.push(req.user.id);
      await room.save();
    }

    const populatedRoom = await room.populate('participants', 'name email');

    // Socket.IO를 통해 참여자 업데이트 알림
    if (io) {
      io.to(req.params.roomId).emit('roomUpdate', {
        ...populatedRoom.toObject(),
        password: undefined
      });
    }

    res.json({
      success: true,
      data: {
        ...populatedRoom.toObject(),
        password: undefined
      }
    });
  } catch (error) {
    console.error('방 입장 에러:', error);
    res.status(500).json({
      success: false,
      message: '서버 에러가 발생했습니다.',
      error: error.message
    });
  }
});

module.exports = {
  router,
  initializeSocket
};

<backend/routes/api/users.js>
const express = require('express');
const router = express.Router();
const userController = require('../../controllers/userController');
const auth = require('../../middleware/auth');
const { upload } = require('../../middleware/upload');

// 공개 라우트
// 회원가입
router.post('/register', userController.register);

// 인증이 필요한 라우트
// 프로필 조회
router.get('/profile', 
  auth, 
  userController.getProfile
);

// 프로필 업데이트
router.put('/profile',
  auth,
  userController.updateProfile
);

// 프로필 이미지 업로드
router.post('/profile-image',
  auth,
  upload.single('profileImage'),
  userController.uploadProfileImage
);

// 프로필 이미지 삭제
router.delete('/profile-image',
  auth,
  userController.deleteProfileImage
);

// 회원 탈퇴
router.delete('/account',
  auth,
  userController.deleteAccount
);

// API 상태 확인
router.get('/status', (req, res) => {
  res.json({
    success: true,
    message: 'User API is running',
    timestamp: new Date().toISOString()
  });
});

// 에러 처리 미들웨어
router.use((err, req, res, next) => {
  console.error('User routes error:', err);

  // Multer 에러 처리
  if (err.code === 'LIMIT_FILE_SIZE') {
    return res.status(413).json({
      success: false,
      message: '파일 크기는 5MB를 초과할 수 없습니다.'
    });
  }

  if (err.code === 'LIMIT_UNEXPECTED_FILE') {
    return res.status(400).json({
      success: false,
      message: '잘못된 파일 필드입니다.'
    });
  }

  // 기타 에러
  res.status(500).json({
    success: false,
    message: '서버 에러가 발생했습니다.',
    error: process.env.NODE_ENV === 'development' ? err.message : undefined
  });
});

module.exports = router;

<backend/routes/index.js>
const express = require('express');
const router = express.Router();

// Import route modules
const authRoutes = require('./api/auth');
const userRoutes = require('./api/users');
const { router: roomsRouter } = require('./api/rooms');
const fileRoutes = require('./api/files');

// API documentation route
router.get('/', (req, res) => {
  res.json({
    name: 'Chat App API',
    version: '1.0.0',
    timestamp: new Date().toISOString(),
    endpoints: {
      auth: {
        base: '/auth',
        routes: {
          register: { method: 'POST', path: '/register' },
          login: { method: 'POST', path: '/login' },
          logout: { method: 'POST', path: '/logout' },
          verifyToken: { method: 'GET', path: '/verify-token' },
          refreshToken: { method: 'POST', path: '/refresh-token' }
        }
      },
      users: '/users',
      rooms: '/rooms',
      files: '/files',
      ai: '/ai'
    }
  });
});

// Mount routes
router.use('/auth', authRoutes);
router.use('/users', userRoutes);
router.use('/rooms', roomsRouter);  // roomsRouter로 변경
router.use('/files', fileRoutes);

module.exports = router;

<backend/server.js>
require('dotenv').config();
const express = require('express');
const cors = require('cors');
const mongoose = require('mongoose');
const http = require('http');
const socketIO = require('socket.io');
const path = require('path');
const { router: roomsRouter, initializeSocket } = require('./routes/api/rooms');
const routes = require('./routes');

const app = express();
const server = http.createServer(app);
const PORT = process.env.PORT || 5000;

// trust proxy 설정 추가
app.set('trust proxy', 1);

// CORS 설정
const corsOptions = {
  origin: [
    'https://bootcampchat-fe.run.goorm.site',
    'http://localhost:3000',
    'https://localhost:3000',
    'http://0.0.0.0:3000',
    'https://0.0.0.0:3000'
  ],
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: [
    'Content-Type', 
    'Authorization', 
    'x-auth-token', 
    'x-session-id',
    'Cache-Control',
    'Pragma'
  ],
  exposedHeaders: ['x-auth-token', 'x-session-id']
};

// 기본 미들웨어
app.use(cors(corsOptions));
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// OPTIONS 요청에 대한 처리
app.options('*', cors(corsOptions));

// 정적 파일 제공
app.use('/uploads', express.static(path.join(__dirname, 'uploads')));

// 요청 로깅
if (process.env.NODE_ENV === 'development') {
  app.use((req, res, next) => {
    console.log(`[${new Date().toISOString()}] ${req.method} ${req.originalUrl}`);
    next();
  });
}

// 기본 상태 체크
app.get('/health', (req, res) => {
  res.json({ 
    status: 'ok', 
    timestamp: new Date().toISOString(),
    env: process.env.NODE_ENV
  });
});

// API 라우트 마운트
app.use('/api', routes);

// Socket.IO 설정
const io = socketIO(server, { cors: corsOptions });
require('./sockets/chat')(io);

// Socket.IO 객체 전달
initializeSocket(io);

// 404 에러 핸들러
app.use((req, res) => {
  console.log('404 Error:', req.originalUrl);
  res.status(404).json({
    success: false,
    message: '요청하신 리소스를 찾을 수 없습니다.',
    path: req.originalUrl
  });
});

// 글로벌 에러 핸들러
app.use((err, req, res, next) => {
  console.error('Server error:', err);
  res.status(err.status || 500).json({
    success: false,
    message: err.message || '서버 에러가 발생했습니다.',
    ...(process.env.NODE_ENV === 'development' && { stack: err.stack })
  });
});

// 서버 시작
mongoose.connect(process.env.MONGO_URI)
  .then(() => {
    console.log('MongoDB Connected');
    server.listen(PORT, '0.0.0.0', () => {
      console.log(`Server running on port ${PORT}`);
      console.log('Environment:', process.env.NODE_ENV);
      console.log('API Base URL:', `http://0.0.0.0:${PORT}/api`);
    });
  })
  .catch(err => {
    console.error('Server startup error:', err);
    process.exit(1);
  });

module.exports = { app, server };

<backend/services/aiService.js>
const axios = require('axios');
const { openaiApiKey } = require('../config/keys');

class AIService {
  constructor() {
    this.openaiClient = axios.create({
      baseURL: 'https://api.openai.com/v1',
      headers: {
        'Authorization': `Bearer ${openaiApiKey}`,
        'Content-Type': 'application/json'
      }
    });
  }

  async generateResponse(message, persona = 'wayneAI', callbacks) {
    try {
      const aiPersona = {
        wayneAI: {
          name: 'Wayne AI',
          role: '친절하고 도움이 되는 어시스턴트',
          traits: '전문적이고 통찰력 있는 답변을 제공하며, 사용자의 질문을 깊이 이해하고 명확한 설명을 제공합니다.',
          tone: '전문적이면서도 친근한 톤',
        },
        consultingAI: {
          name: 'Consulting AI',
          role: '비즈니스 컨설팅 전문가',
          traits: '비즈니스 전략, 시장 분석, 조직 관리에 대한 전문적인 조언을 제공합니다.',
          tone: '전문적이고 분석적인 톤',
        }
      }[persona];

      if (!aiPersona) {
        throw new Error('Unknown AI persona');
      }

      const systemPrompt = `당신은 ${aiPersona.name}입니다.
역할: ${aiPersona.role}
특성: ${aiPersona.traits}
톤: ${aiPersona.tone}

답변 시 주의사항:
1. 명확하고 이해하기 쉬운 언어로 답변하세요.
2. 정확하지 않은 정보는 제공하지 마세요.
3. 필요한 경우 예시를 들어 설명하세요.
4. ${aiPersona.tone}을 유지하세요.`;

      callbacks.onStart();

      const response = await this.openaiClient.post('/chat/completions', {
        model: 'gpt-4',
        messages: [
          { role: 'system', content: systemPrompt },
          { role: 'user', content: message }
        ],
        temperature: 0.7,
        stream: true
      }, {
        responseType: 'stream'
      });

      let fullResponse = '';
      let isCodeBlock = false;
      let buffer = '';

      return new Promise((resolve, reject) => {
        response.data.on('data', async chunk => {
          try {
            // 청크 데이터를 문자열로 변환하고 버퍼에 추가
            buffer += chunk.toString();

            // 완전한 JSON 객체를 찾아 처리
            while (true) {
              const newlineIndex = buffer.indexOf('\n');
              if (newlineIndex === -1) break;

              const line = buffer.slice(0, newlineIndex).trim();
              buffer = buffer.slice(newlineIndex + 1);

              if (line === '') continue;
              if (line === 'data: [DONE]') {
                callbacks.onComplete({
                  content: fullResponse.trim()
                });
                resolve(fullResponse.trim());
                return;
              }

              if (line.startsWith('data: ')) {
                try {
                  const data = JSON.parse(line.slice(6));
                  const content = data.choices[0]?.delta?.content;
                  
                  if (content) {
                    // 코드 블록 상태 업데이트
                    if (content.includes('```')) {
                      isCodeBlock = !isCodeBlock;
                    }

                    // 현재 청크만 전송
                    await callbacks.onChunk({
                      currentChunk: content,
                      isCodeBlock
                    });

                    // 전체 응답은 서버에서만 관리
                    fullResponse += content;
                  }
                } catch (err) {
                  console.error('JSON parsing error:', err);
                }
              }
            }
          } catch (error) {
            console.error('Stream processing error:', error);
            callbacks.onError(error);
            reject(error);
          }
        });

        response.data.on('error', error => {
          console.error('Stream error:', error);
          callbacks.onError(error);
          reject(error);
        });
      });

    } catch (error) {
      console.error('AI response generation error:', error);
      callbacks.onError(error);
      throw new Error('AI 응답 생성 중 오류가 발생했습니다.');
    }
  }
}

module.exports = new AIService();

<backend/services/fileService.js>
const fs = require('fs');
const pdfParse = require('pdf-parse');

exports.processFileForRAG = async (filePath) => {
  let textContent = '';

  // PDF 파일 처리
  if (filePath.endsWith('.pdf')) {
    const dataBuffer = fs.readFileSync(filePath);
    const pdfData = await pdfParse(dataBuffer);
    textContent = pdfData.text;
  } else {
    // 텍스트 파일 처리
    textContent = fs.readFileSync(filePath, 'utf-8');
  }

  // 텍스트를 벡터화하여 벡터 DB에 저장
  await vectorDB.storeDocument(textContent);
};

<backend/services/sessionService.js>
const redisClient = require('../utils/redisClient');
const crypto = require('crypto');

class SessionService {
  static SESSION_TTL = 24 * 60 * 60; // 24 hours
  static SESSION_PREFIX = 'session:';
  static SESSION_ID_PREFIX = 'sessionId:';
  static USER_SESSIONS_PREFIX = 'user_sessions:';
  static ACTIVE_SESSION_PREFIX = 'active_session:';

  // 안전한 JSON 직렬화
  static safeStringify(data) {
    try {
      if (typeof data === 'string') return data;
      return JSON.stringify(data);
    } catch (error) {
      console.error('JSON stringify error:', error);
      return '';
    }
  }

  // 안전한 JSON 파싱
  static safeParse(data) {
    try {
      if (!data) return null;
      if (typeof data === 'object') return data;
      if (typeof data !== 'string') return null;
      
      // 이미 객체인 경우 즉시 반환
      if (data === '[object Object]') return null;
      
      return JSON.parse(data);
    } catch (error) {
      console.error('JSON parse error:', error);
      return null;
    }
  }

  // Redis에 데이터 저장 전 JSON 문자열로 변환
  static async setJson(key, value, ttl) {
    try {
      const jsonString = this.safeStringify(value);
      if (!jsonString) {
        console.error('Failed to stringify value:', value);
        return false;
      }

      if (ttl) {
        await redisClient.setEx(key, ttl, jsonString);
      } else {
        await redisClient.set(key, jsonString);
      }
      return true;
    } catch (error) {
      console.error('Redis setJson error:', error);
      return false;
    }
  }

  // Redis에서 데이터를 가져와서 JSON으로 파싱
  static async getJson(key) {
    try {
      const value = await redisClient.get(key);
      return this.safeParse(value);
    } catch (error) {
      console.error('Redis getJson error:', error);
      return null;
    }
  }

  static async createSession(userId, metadata = {}) {
    try {
      // 기존 세션들 모두 제거
      await this.removeAllUserSessions(userId);

      const sessionId = this.generateSessionId();
      const sessionData = {
        userId,
        sessionId,
        createdAt: Date.now(),
        lastActivity: Date.now(),
        metadata: {
          userAgent: metadata.userAgent || '',
          ipAddress: metadata.ipAddress || '',
          deviceInfo: metadata.deviceInfo || '',
          ...metadata
        }
      };

      const sessionKey = this.getSessionKey(userId);
      const sessionIdKey = this.getSessionIdKey(sessionId);
      const userSessionsKey = this.getUserSessionsKey(userId);
      const activeSessionKey = this.getActiveSessionKey(userId);

      // 세션 데이터 저장
      const saved = await this.setJson(sessionKey, sessionData, this.SESSION_TTL);
      if (!saved) {
        throw new Error('세션 데이터 저장에 실패했습니다.');
      }

      // 세션 ID 매핑 저장 - 문자열 값은 직접 저장
      await redisClient.setEx(sessionIdKey, this.SESSION_TTL, userId.toString());
      await redisClient.setEx(userSessionsKey, this.SESSION_TTL, sessionId);
      await redisClient.setEx(activeSessionKey, this.SESSION_TTL, sessionId);

      return {
        sessionId,
        expiresIn: this.SESSION_TTL,
        sessionData
      };

    } catch (error) {
      console.error('Session creation error:', error);
      throw new Error('세션 생성 중 오류가 발생했습니다.');
    }
  }

  static async validateSession(userId, sessionId) {
    try {
      if (!userId || !sessionId) {
        return {
          isValid: false,
          error: 'INVALID_PARAMETERS',
          message: '유효하지 않은 세션 파라미터'
        };
      }

      // 활성 세션 확인
      const activeSessionKey = this.getActiveSessionKey(userId);
      const activeSessionId = await redisClient.get(activeSessionKey);

      if (!activeSessionId || activeSessionId !== sessionId) {
        console.log('Session validation failed:', {
          userId,
          sessionId,
          activeSessionId
        });
        return {
          isValid: false,
          error: 'INVALID_SESSION',
          message: '다른 기기에서 로그인되어 현재 세션이 만료되었습니다.'
        };
      }

      // 세션 데이터 검증
      const sessionKey = this.getSessionKey(userId);
      const sessionData = await this.getJson(sessionKey);

      if (!sessionData) {
        return {
          isValid: false,
          error: 'SESSION_NOT_FOUND',
          message: '세션을 찾을 수 없습니다.'
        };
      }

      // 세션 만료 시간 검증
      const SESSION_TIMEOUT = 24 * 60 * 60 * 1000; // 24시간
      if (Date.now() - sessionData.lastActivity > SESSION_TIMEOUT) {
        await this.removeSession(userId);
        return {
          isValid: false,
          error: 'SESSION_EXPIRED',
          message: '세션이 만료되었습니다.'
        };
      }

      // 세션 데이터 갱신
      sessionData.lastActivity = Date.now();
      
      // 갱신된 세션 데이터 저장
      const updated = await this.setJson(sessionKey, sessionData, this.SESSION_TTL);
      if (!updated) {
        return {
          isValid: false,
          error: 'UPDATE_FAILED',
          message: '세션 갱신에 실패했습니다.'
        };
      }

      // 관련 키들의 만료 시간 갱신
      await Promise.all([
        redisClient.expire(activeSessionKey, this.SESSION_TTL),
        redisClient.expire(this.getUserSessionsKey(userId), this.SESSION_TTL),
        redisClient.expire(this.getSessionIdKey(sessionId), this.SESSION_TTL)
      ]);

      return {
        isValid: true,
        session: sessionData
      };

    } catch (error) {
      console.error('Session validation error:', error);
      return {
        isValid: false,
        error: 'VALIDATION_ERROR',
        message: '세션 검증 중 오류가 발생했습니다.'
      };
    }
  }

  static async removeSession(userId, sessionId = null) {
    try {
      const userSessionsKey = this.getUserSessionsKey(userId);
      const activeSessionKey = this.getActiveSessionKey(userId);

      if (sessionId) {
        const currentSessionId = await redisClient.get(userSessionsKey);
        if (currentSessionId === sessionId) {
          await Promise.all([
            redisClient.del(this.getSessionKey(userId)),
            redisClient.del(this.getSessionIdKey(sessionId)),
            redisClient.del(userSessionsKey),
            redisClient.del(activeSessionKey)
          ]);
        }
      } else {
        const storedSessionId = await redisClient.get(userSessionsKey);
        if (storedSessionId) {
          await Promise.all([
            redisClient.del(this.getSessionKey(userId)),
            redisClient.del(this.getSessionIdKey(storedSessionId)),
            redisClient.del(userSessionsKey),
            redisClient.del(activeSessionKey)
          ]);
        }
      }
    } catch (error) {
      console.error('Session removal error:', error);
      throw error;
    }
  }

  static async removeAllUserSessions(userId) {
    try {
      const activeSessionKey = this.getActiveSessionKey(userId);
      const userSessionsKey = this.getUserSessionsKey(userId);
      const sessionId = await redisClient.get(userSessionsKey);

      const deletePromises = [
        redisClient.del(activeSessionKey),
        redisClient.del(userSessionsKey)
      ];

      if (sessionId) {
        deletePromises.push(
          redisClient.del(this.getSessionKey(userId)),
          redisClient.del(this.getSessionIdKey(sessionId))
        );
      }

      await Promise.all(deletePromises);
      return true;
    } catch (error) {
      console.error('Remove all user sessions error:', error);
      return false;
    }
  }

  static async updateLastActivity(userId) {
    try {
      if (!userId) {
        console.error('updateLastActivity: userId is required');
        return false;
      }

      const sessionKey = this.getSessionKey(userId);
      const sessionData = await this.getJson(sessionKey);

      if (!sessionData) {
        console.error('updateLastActivity: No session found for user', userId);
        return false;
      }

      // 세션 데이터 갱신
      sessionData.lastActivity = Date.now();
      
      // 갱신된 세션 데이터 저장
      const updated = await this.setJson(sessionKey, sessionData, this.SESSION_TTL);
      if (!updated) {
        console.error('updateLastActivity: Failed to update session data');
        return false;
      }

      // 관련 키들의 만료 시간도 함께 갱신
      const activeSessionKey = this.getActiveSessionKey(userId);
      const userSessionsKey = this.getUserSessionsKey(userId);
      if (sessionData.sessionId) {
        const sessionIdKey = this.getSessionIdKey(sessionData.sessionId);
        await Promise.all([
          redisClient.expire(activeSessionKey, this.SESSION_TTL),
          redisClient.expire(userSessionsKey, this.SESSION_TTL),
          redisClient.expire(sessionIdKey, this.SESSION_TTL)
        ]);
      }

      return true;

    } catch (error) {
      console.error('Update last activity error:', error);
      return false;
    }
  }  
  
  static async getActiveSession(userId) {
    try {
      if (!userId) {
        console.error('getActiveSession: userId is required');
        return null;
      }

      const activeSessionKey = this.getActiveSessionKey(userId);
      const sessionId = await redisClient.get(activeSessionKey);

      if (!sessionId) {
        return null;
      }

      const sessionKey = this.getSessionKey(userId);
      const sessionData = await this.getJson(sessionKey);

      if (!sessionData) {
        await redisClient.del(activeSessionKey);
        return null;
      }

      return {
        ...sessionData,
        userId,
        sessionId
      };
    } catch (error) {
      console.error('Get active session error:', error);
      return null;
    }
  }

  static getSessionKey(userId) {
    return `${this.SESSION_PREFIX}${userId}`;
  }

  static getSessionIdKey(sessionId) {
    return `${this.SESSION_ID_PREFIX}${sessionId}`;
  }

  static getUserSessionsKey(userId) {
    return `${this.USER_SESSIONS_PREFIX}${userId}`;
  }

  static getActiveSessionKey(userId) {
    return `${this.ACTIVE_SESSION_PREFIX}${userId}`;
  }

  static generateSessionId() {
    return crypto.randomBytes(32).toString('hex');
  }
}

module.exports = SessionService;

<backend/sockets/chat.js>
const Message = require('../models/Message');
const Room = require('../models/Room');
const User = require('../models/User');
const File = require('../models/File');
const jwt = require('jsonwebtoken');
const { jwtSecret } = require('../config/keys');
const redisClient = require('../utils/redisClient');
const SessionService = require('../services/sessionService');
const aiService = require('../services/aiService');

module.exports = function(io) {
  const connectedUsers = new Map();
  const streamingSessions = new Map();
  const userRooms = new Map();
  const messageQueues = new Map();
  const messageLoadRetries = new Map();
  const BATCH_SIZE = 30;  // 한 번에 로드할 메시지 수
  const LOAD_DELAY = 300; // 메시지 로드 딜레이 (ms)
  const MAX_RETRIES = 3;  // 최대 재시도 횟수
  const MESSAGE_LOAD_TIMEOUT = 10000; // 메시지 로드 타임아웃 (10초)
  const RETRY_DELAY = 2000; // 재시도 간격 (2초)
  const DUPLICATE_LOGIN_TIMEOUT = 10000; // 중복 로그인 타임아웃 (10초)

  // 로깅 유틸리티 함수
  const logDebug = (action, data) => {
    console.debug(`[Socket.IO] ${action}:`, {
      ...data,
      timestamp: new Date().toISOString()
    });
  };

  // 메시지 일괄 로드 함수 개선
  const loadMessages = async (socket, roomId, before, limit = BATCH_SIZE) => {
    const timeoutPromise = new Promise((_, reject) => {
      setTimeout(() => {
        reject(new Error('Message loading timed out'));
      }, MESSAGE_LOAD_TIMEOUT);
    });

    try {
      // 쿼리 구성
      const query = { room: roomId };
      if (before) {
        query.timestamp = { $lt: new Date(before) };
      }

      // 메시지 로드 with profileImage
      const messages = await Promise.race([
        Message.find(query)
          .populate('sender', 'name email profileImage')
          .populate({
            path: 'file',
            select: 'filename originalname mimetype size'
          })
          .sort({ timestamp: -1 })
          .limit(limit + 1)
          .lean(),
        timeoutPromise
      ]);

      // 결과 처리
      const hasMore = messages.length > limit;
      const resultMessages = messages.slice(0, limit);
      const sortedMessages = resultMessages.sort((a, b) => 
        new Date(a.timestamp) - new Date(b.timestamp)
      );

      // 읽음 상태 비동기 업데이트
      if (sortedMessages.length > 0 && socket.user) {
        const messageIds = sortedMessages.map(msg => msg._id);
        Message.updateMany(
          {
            _id: { $in: messageIds },
            'readers.userId': { $ne: socket.user.id }
          },
          {
            $push: {
              readers: {
                userId: socket.user.id,
                readAt: new Date()
              }
            }
          }
        ).exec().catch(error => {
          console.error('Read status update error:', error);
        });
      }

      return {
        messages: sortedMessages,
        hasMore,
        oldestTimestamp: sortedMessages[0]?.timestamp || null
      };
    } catch (error) {
      if (error.message === 'Message loading timed out') {
        logDebug('message load timeout', {
          roomId,
          before,
          limit
        });
      } else {
        console.error('Load messages error:', {
          error: error.message,
          stack: error.stack,
          roomId,
          before,
          limit
        });
      }
      throw error;
    }
  };

  // 재시도 로직을 포함한 메시지 로드 함수
  const loadMessagesWithRetry = async (socket, roomId, before, retryCount = 0) => {
    const retryKey = `${roomId}:${socket.user.id}`;
    
    try {
      if (messageLoadRetries.get(retryKey) >= MAX_RETRIES) {
        throw new Error('최대 재시도 횟수를 초과했습니다.');
      }

      const result = await loadMessages(socket, roomId, before);
      messageLoadRetries.delete(retryKey);
      return result;

    } catch (error) {
      const currentRetries = messageLoadRetries.get(retryKey) || 0;
      
      if (currentRetries < MAX_RETRIES) {
        messageLoadRetries.set(retryKey, currentRetries + 1);
        const delay = Math.min(RETRY_DELAY * Math.pow(2, currentRetries), 10000);
        
        logDebug('retrying message load', {
          roomId,
          retryCount: currentRetries + 1,
          delay
        });

        await new Promise(resolve => setTimeout(resolve, delay));
        return loadMessagesWithRetry(socket, roomId, before, currentRetries + 1);
      }

      messageLoadRetries.delete(retryKey);
      throw error;
    }
  };

  // 중복 로그인 처리 함수
  const handleDuplicateLogin = async (existingSocket, newSocket) => {
    try {
      // 기존 연결에 중복 로그인 알림
      existingSocket.emit('duplicate_login', {
        type: 'new_login_attempt',
        deviceInfo: newSocket.handshake.headers['user-agent'],
        ipAddress: newSocket.handshake.address,
        timestamp: Date.now()
      });

      // 타임아웃 설정
      return new Promise((resolve) => {
        setTimeout(async () => {
          try {
            // 기존 세션 종료
            existingSocket.emit('session_ended', {
              reason: 'duplicate_login',
              message: '다른 기기에서 로그인하여 현재 세션이 종료되었습니다.'
            });

            // 기존 연결 종료
            existingSocket.disconnect(true);
            resolve();
          } catch (error) {
            console.error('Error during session termination:', error);
            resolve();
          }
        }, DUPLICATE_LOGIN_TIMEOUT);
      });
    } catch (error) {
      console.error('Duplicate login handling error:', error);
      throw error;
    }
  };

  // 미들웨어: 소켓 연결 시 인증 처리
  io.use(async (socket, next) => {
    try {
      const token = socket.handshake.auth.token;
      const sessionId = socket.handshake.auth.sessionId;

      if (!token || !sessionId) {
        return next(new Error('Authentication error'));
      }

      const decoded = jwt.verify(token, jwtSecret);
      if (!decoded?.user?.id) {
        return next(new Error('Invalid token'));
      }

      // 이미 연결된 사용자인지 확인
      const existingSocketId = connectedUsers.get(decoded.user.id);
      if (existingSocketId) {
        const existingSocket = io.sockets.sockets.get(existingSocketId);
        if (existingSocket) {
          // 중복 로그인 처리
          await handleDuplicateLogin(existingSocket, socket);
        }
      }

      const validationResult = await SessionService.validateSession(decoded.user.id, sessionId);
      if (!validationResult.isValid) {
        console.error('Session validation failed:', validationResult);
        return next(new Error(validationResult.message || 'Invalid session'));
      }

      const user = await User.findById(decoded.user.id);
      if (!user) {
        return next(new Error('User not found'));
      }

      socket.user = {
        id: user._id.toString(),
        name: user.name,
        email: user.email,
        sessionId: sessionId,
        profileImage: user.profileImage
      };

      await SessionService.updateLastActivity(decoded.user.id);
      next();

    } catch (error) {
      console.error('Socket authentication error:', error);
      
      if (error.name === 'TokenExpiredError') {
        return next(new Error('Token expired'));
      }
      
      if (error.name === 'JsonWebTokenError') {
        return next(new Error('Invalid token'));
      }
      
      next(new Error('Authentication failed'));
    }
  });
  
  io.on('connection', (socket) => {
    logDebug('socket connected', {
      socketId: socket.id,
      userId: socket.user?.id,
      userName: socket.user?.name
    });

    if (socket.user) {
      // 이전 연결이 있는지 확인
      const previousSocketId = connectedUsers.get(socket.user.id);
      if (previousSocketId && previousSocketId !== socket.id) {
        const previousSocket = io.sockets.sockets.get(previousSocketId);
        if (previousSocket) {
          // 이전 연결에 중복 로그인 알림
          previousSocket.emit('duplicate_login', {
            type: 'new_login_attempt',
            deviceInfo: socket.handshake.headers['user-agent'],
            ipAddress: socket.handshake.address,
            timestamp: Date.now()
          });

          // 이전 연결 종료 처리
          setTimeout(() => {
            previousSocket.emit('session_ended', {
              reason: 'duplicate_login',
              message: '다른 기기에서 로그인하여 현재 세션이 종료되었습니다.'
            });
            previousSocket.disconnect(true);
          }, DUPLICATE_LOGIN_TIMEOUT);
        }
      }
      
      // 새로운 연결 정보 저장
      connectedUsers.set(socket.user.id, socket.id);
    }

    // 이전 메시지 로딩 처리 개선
    socket.on('fetchPreviousMessages', async ({ roomId, before }) => {
      const queueKey = `${roomId}:${socket.user.id}`;

      try {
        if (!socket.user) {
          throw new Error('Unauthorized');
        }

        // 권한 체크
        const room = await Room.findOne({
          _id: roomId,
          participants: socket.user.id
        });

        if (!room) {
          throw new Error('채팅방 접근 권한이 없습니다.');
        }

        if (messageQueues.get(queueKey)) {
          logDebug('message load skipped - already loading', {
            roomId,
            userId: socket.user.id
          });
          return;
        }

        messageQueues.set(queueKey, true);
        socket.emit('messageLoadStart');

        const result = await loadMessagesWithRetry(socket, roomId, before);
        
        logDebug('previous messages loaded', {
          roomId,
          messageCount: result.messages.length,
          hasMore: result.hasMore,
          oldestTimestamp: result.oldestTimestamp
        });

        socket.emit('previousMessagesLoaded', result);

      } catch (error) {
        console.error('Fetch previous messages error:', error);
        socket.emit('error', {
          type: 'LOAD_ERROR',
          message: error.message || '이전 메시지를 불러오는 중 오류가 발생했습니다.'
        });
      } finally {
        setTimeout(() => {
          messageQueues.delete(queueKey);
        }, LOAD_DELAY);
      }
    });
    
    // 채팅방 입장 처리 개선
    socket.on('joinRoom', async (roomId) => {
      try {
        if (!socket.user) {
          throw new Error('Unauthorized');
        }

        // 이미 해당 방에 참여 중인지 확인
        const currentRoom = userRooms.get(socket.user.id);
        if (currentRoom === roomId) {
          logDebug('already in room', {
            userId: socket.user.id,
            roomId
          });
          socket.emit('joinRoomSuccess', { roomId });
          return;
        }

        // 기존 방에서 나가기
        if (currentRoom) {
          logDebug('leaving current room', { 
            userId: socket.user.id, 
            roomId: currentRoom 
          });
          socket.leave(currentRoom);
          userRooms.delete(socket.user.id);
          
          socket.to(currentRoom).emit('userLeft', {
            userId: socket.user.id,
            name: socket.user.name
          });
        }

        // 채팅방 참가 with profileImage
        const room = await Room.findByIdAndUpdate(
          roomId,
          { $addToSet: { participants: socket.user.id } },
          { 
            new: true,
            runValidators: true 
          }
        ).populate('participants', 'name email profileImage');

        if (!room) {
          throw new Error('채팅방을 찾을 수 없습니다.');
        }

        socket.join(roomId);
        userRooms.set(socket.user.id, roomId);

        // 입장 메시지 생성
        const joinMessage = new Message({
          room: roomId,
          content: `${socket.user.name}님이 입장하였습니다.`,
          type: 'system',
          timestamp: new Date()
        });
        
        await joinMessage.save();

        // 초기 메시지 로드
        const messageLoadResult = await loadMessages(socket, roomId);
        const { messages, hasMore, oldestTimestamp } = messageLoadResult;

        // 활성 스트리밍 메시지 조회
        const activeStreams = Array.from(streamingSessions.values())
          .filter(session => session.room === roomId)
          .map(session => ({
            _id: session.messageId,
            type: 'ai',
            aiType: session.aiType,
            content: session.content,
            timestamp: session.timestamp,
            isStreaming: true
          }));

        // 이벤트 발송
        socket.emit('joinRoomSuccess', {
          roomId,
          participants: room.participants,
          messages,
          hasMore,
          oldestTimestamp,
          activeStreams
        });

        io.to(roomId).emit('message', joinMessage);
        io.to(roomId).emit('participantsUpdate', room.participants);

        logDebug('user joined room', {
          userId: socket.user.id,
          roomId,
          messageCount: messages.length,
          hasMore
        });

      } catch (error) {
        console.error('Join room error:', error);
        socket.emit('joinRoomError', {
          message: error.message || '채팅방 입장에 실패했습니다.'
        });
      }
    });
    
    // 메시지 전송 처리
    socket.on('chatMessage', async (messageData) => {
      try {
        if (!socket.user) {
          throw new Error('Unauthorized');
        }

        if (!messageData) {
          throw new Error('메시지 데이터가 없습니다.');
        }

        const { room, type, content, fileData } = messageData;

        if (!room) {
          throw new Error('채팅방 정보가 없습니다.');
        }

        // 채팅방 권한 확인
        const chatRoom = await Room.findOne({
          _id: room,
          participants: socket.user.id
        });

        if (!chatRoom) {
          throw new Error('채팅방 접근 권한이 없습니다.');
        }

        // 세션 유효성 재확인
        const sessionValidation = await SessionService.validateSession(
          socket.user.id, 
          socket.user.sessionId
        );
        
        if (!sessionValidation.isValid) {
          throw new Error('세션이 만료되었습니다. 다시 로그인해주세요.');
        }

        // AI 멘션 확인
        const aiMentions = extractAIMentions(content);
        let message;

        logDebug('message received', {
          type,
          room,
          userId: socket.user.id,
          hasFileData: !!fileData,
          hasAIMentions: aiMentions.length
        });

        // 메시지 타입별 처리
        switch (type) {
          case 'file':
            if (!fileData || !fileData._id) {
              throw new Error('파일 데이터가 올바르지 않습니다.');
            }

            const file = await File.findOne({
              _id: fileData._id,
              user: socket.user.id
            });

            if (!file) {
              throw new Error('파일을 찾을 수 없거나 접근 권한이 없습니다.');
            }

            message = new Message({
              room,
              sender: socket.user.id,
              type: 'file',
              file: file._id,
              content: content || '',
              timestamp: new Date(),
              reactions: {},
              metadata: {
                fileType: file.mimetype,
                fileSize: file.size,
                originalName: file.originalname
              }
            });
            break;

          case 'text':
            const messageContent = content?.trim() || messageData.msg?.trim();
            if (!messageContent) {
              return;
            }

            message = new Message({
              room,
              sender: socket.user.id,
              content: messageContent,
              type: 'text',
              timestamp: new Date(),
              reactions: {}
            });
            break;

          default:
            throw new Error('지원하지 않는 메시지 타입입니다.');
        }

        await message.save();
        await message.populate([
          { path: 'sender', select: 'name email profileImage' },
          { path: 'file', select: 'filename originalname mimetype size' }
        ]);

        io.to(room).emit('message', message);

        // AI 멘션이 있는 경우 AI 응답 생성
        if (aiMentions.length > 0) {
          for (const ai of aiMentions) {
            const query = content.replace(new RegExp(`@${ai}\\b`, 'g'), '').trim();
            await handleAIResponse(io, room, ai, query);
          }
        }

        await SessionService.updateLastActivity(socket.user.id);

        logDebug('message processed', {
          messageId: message._id,
          type: message.type,
          room
        });

      } catch (error) {
        console.error('Message handling error:', error);
        socket.emit('error', {
          code: error.code || 'MESSAGE_ERROR',
          message: error.message || '메시지 전송 중 오류가 발생했습니다.'
        });
      }
    });

    // 채팅방 퇴장 처리
    socket.on('leaveRoom', async (roomId) => {
      try {
        if (!socket.user) {
          throw new Error('Unauthorized');
        }

        // 실제로 해당 방에 참여 중인지 먼저 확인
        const currentRoom = userRooms?.get(socket.user.id);
        if (!currentRoom || currentRoom !== roomId) {
          console.log(`User ${socket.user.id} is not in room ${roomId}`);
          return;
        }

        // 권한 확인
        const room = await Room.findOne({
          _id: roomId,
          participants: socket.user.id
        }).select('participants').lean();

        if (!room) {
          console.log(`Room ${roomId} not found or user has no access`);
          return;
        }

        socket.leave(roomId);
        userRooms.delete(socket.user.id);

        // 퇴장 메시지 생성 및 저장
        const leaveMessage = await Message.create({
          room: roomId,
          content: `${socket.user.name}님이 퇴장하였습니다.`,
          type: 'system',
          timestamp: new Date()
        });

        // 참가자 목록 업데이트 - profileImage 포함
        const updatedRoom = await Room.findByIdAndUpdate(
          roomId,
          { $pull: { participants: socket.user.id } },
          { 
            new: true,
            runValidators: true
          }
        ).populate('participants', 'name email profileImage');

        if (!updatedRoom) {
          console.log(`Room ${roomId} not found during update`);
          return;
        }

        // 스트리밍 세션 정리
        for (const [messageId, session] of streamingSessions.entries()) {
          if (session.room === roomId && session.userId === socket.user.id) {
            streamingSessions.delete(messageId);
          }
        }

        // 메시지 큐 정리
        const queueKey = `${roomId}:${socket.user.id}`;
        messageQueues.delete(queueKey);
        messageLoadRetries.delete(queueKey);

        // 이벤트 발송
        io.to(roomId).emit('message', leaveMessage);
        io.to(roomId).emit('participantsUpdate', updatedRoom.participants);

        console.log(`User ${socket.user.id} left room ${roomId} successfully`);

      } catch (error) {
        console.error('Leave room error:', error);
        socket.emit('error', {
          message: error.message || '채팅방 퇴장 중 오류가 발생했습니다.'
        });
      }
    });
    
    // 연결 해제 처리
    socket.on('disconnect', async (reason) => {
      if (!socket.user) return;

      try {
        // 해당 사용자의 현재 활성 연결인 경우에만 정리
        if (connectedUsers.get(socket.user.id) === socket.id) {
          connectedUsers.delete(socket.user.id);
        }

        const roomId = userRooms.get(socket.user.id);
        userRooms.delete(socket.user.id);

        // 메시지 큐 정리
        const userQueues = Array.from(messageQueues.keys())
          .filter(key => key.endsWith(`:${socket.user.id}`));
        userQueues.forEach(key => {
          messageQueues.delete(key);
          messageLoadRetries.delete(key);
        });
        
        // 스트리밍 세션 정리
        for (const [messageId, session] of streamingSessions.entries()) {
          if (session.userId === socket.user.id) {
            streamingSessions.delete(messageId);
          }
        }

        // 현재 방에서 자동 퇴장 처리
        if (roomId) {
          // 다른 디바이스로 인한 연결 종료가 아닌 경우에만 처리
          if (reason !== 'client namespace disconnect' && reason !== 'duplicate_login') {
            const leaveMessage = await Message.create({
              room: roomId,
              content: `${socket.user.name}님이 연결이 끊어졌습니다.`,
              type: 'system',
              timestamp: new Date()
            });

            const updatedRoom = await Room.findByIdAndUpdate(
              roomId,
              { $pull: { participants: socket.user.id } },
              { 
                new: true,
                runValidators: true 
              }
            ).populate('participants', 'name email profileImage');

            if (updatedRoom) {
              io.to(roomId).emit('message', leaveMessage);
              io.to(roomId).emit('participantsUpdate', updatedRoom.participants);
            }
          }
        }

        logDebug('user disconnected', {
          reason,
          userId: socket.user.id,
          socketId: socket.id,
          lastRoom: roomId
        });

      } catch (error) {
        console.error('Disconnect handling error:', error);
      }
    });

    // 세션 종료 또는 로그아웃 처리
    socket.on('force_login', async ({ token }) => {
      try {
        if (!socket.user) return;

        // 강제 로그아웃을 요청한 클라이언트의 세션 정보 확인
        const decoded = jwt.verify(token, jwtSecret);
        if (!decoded?.user?.id || decoded.user.id !== socket.user.id) {
          throw new Error('Invalid token');
        }

        // 세션 종료 처리
        socket.emit('session_ended', {
          reason: 'force_logout',
          message: '다른 기기에서 로그인하여 현재 세션이 종료되었습니다.'
        });

        // 연결 종료
        socket.disconnect(true);

      } catch (error) {
        console.error('Force login error:', error);
        socket.emit('error', {
          message: '세션 종료 중 오류가 발생했습니다.'
        });
      }
    });

    // 메시지 읽음 상태 처리
    socket.on('markMessagesAsRead', async ({ roomId, messageIds }) => {
      try {
        if (!socket.user) {
          throw new Error('Unauthorized');
        }

        if (!Array.isArray(messageIds) || messageIds.length === 0) {
          return;
        }

        // 읽음 상태 업데이트
        await Message.updateMany(
          {
            _id: { $in: messageIds },
            room: roomId,
            'readers.userId': { $ne: socket.user.id }
          },
          {
            $push: {
              readers: {
                userId: socket.user.id,
                readAt: new Date()
              }
            }
          }
        );

        socket.to(roomId).emit('messagesRead', {
          userId: socket.user.id,
          messageIds
        });

      } catch (error) {
        console.error('Mark messages as read error:', error);
        socket.emit('error', {
          message: '읽음 상태 업데이트 중 오류가 발생했습니다.'
        });
      }
    });

    // 리액션 처리
    socket.on('messageReaction', async ({ messageId, reaction, type }) => {
      try {
        if (!socket.user) {
          throw new Error('Unauthorized');
        }

        const message = await Message.findById(messageId);
        if (!message) {
          throw new Error('메시지를 찾을 수 없습니다.');
        }

        // 리액션 추가/제거
        if (type === 'add') {
          await message.addReaction(reaction, socket.user.id);
        } else if (type === 'remove') {
          await message.removeReaction(reaction, socket.user.id);
        }

        // 업데이트된 리액션 정보 브로드캐스트
        io.to(message.room).emit('messageReactionUpdate', {
          messageId,
          reactions: message.reactions
        });

      } catch (error) {
        console.error('Message reaction error:', error);
        socket.emit('error', {
          message: error.message || '리액션 처리 중 오류가 발생했습니다.'
        });
      }
    });
  });

  // AI 멘션 추출 함수
  function extractAIMentions(content) {
    if (!content) return [];
    
    const aiTypes = ['wayneAI', 'consultingAI'];
    const mentions = new Set();
    const mentionRegex = /@(wayneAI|consultingAI)\b/g;
    let match;
    
    while ((match = mentionRegex.exec(content)) !== null) {
      if (aiTypes.includes(match[1])) {
        mentions.add(match[1]);
      }
    }
    
    return Array.from(mentions);
  }

  // AI 응답 처리 함수 개선
  async function handleAIResponse(io, room, aiName, query) {
    const messageId = `${aiName}-${Date.now()}`;
    let accumulatedContent = '';
    const timestamp = new Date();

    // 스트리밍 세션 초기화
    streamingSessions.set(messageId, {
      room,
      aiType: aiName,
      content: '',
      messageId,
      timestamp,
      lastUpdate: Date.now(),
      reactions: {}
    });
    
    logDebug('AI response started', {
      messageId,
      aiType: aiName,
      room,
      query
    });

    // 초기 상태 전송
    io.to(room).emit('aiMessageStart', {
      messageId,
      aiType: aiName,
      timestamp
    });

    try {
      // AI 응답 생성 및 스트리밍
      await aiService.generateResponse(query, aiName, {
        onStart: () => {
          logDebug('AI generation started', {
            messageId,
            aiType: aiName
          });
        },
        onChunk: async (chunk) => {
          accumulatedContent += chunk.currentChunk || '';
          
          const session = streamingSessions.get(messageId);
          if (session) {
            session.content = accumulatedContent;
            session.lastUpdate = Date.now();
          }

          io.to(room).emit('aiMessageChunk', {
            messageId,
            currentChunk: chunk.currentChunk,
            fullContent: accumulatedContent,
            isCodeBlock: chunk.isCodeBlock,
            timestamp: new Date(),
            aiType: aiName,
            isComplete: false
          });
        },
        onComplete: async (finalContent) => {
          // 스트리밍 세션 정리
          streamingSessions.delete(messageId);

          // AI 메시지 저장
          const aiMessage = await Message.create({
            room,
            content: finalContent.content,
            type: 'ai',
            aiType: aiName,
            timestamp: new Date(),
            reactions: {},
            metadata: {
              query,
              generationTime: Date.now() - timestamp,
              completionTokens: finalContent.completionTokens,
              totalTokens: finalContent.totalTokens
            }
          });

          // 완료 메시지 전송
          io.to(room).emit('aiMessageComplete', {
            messageId,
            _id: aiMessage._id,
            content: finalContent.content,
            aiType: aiName,
            timestamp: new Date(),
            isComplete: true,
            query,
            reactions: {}
          });

          logDebug('AI response completed', {
            messageId,
            aiType: aiName,
            contentLength: finalContent.content.length,
            generationTime: Date.now() - timestamp
          });
        },
        onError: (error) => {
          streamingSessions.delete(messageId);
          console.error('AI response error:', error);
          
          io.to(room).emit('aiMessageError', {
            messageId,
            error: error.message || 'AI 응답 생성 중 오류가 발생했습니다.',
            aiType: aiName
          });

          logDebug('AI response error', {
            messageId,
            aiType: aiName,
            error: error.message
          });
        }
      });
    } catch (error) {
      streamingSessions.delete(messageId);
      console.error('AI service error:', error);
      
      io.to(room).emit('aiMessageError', {
        messageId,
        error: error.message || 'AI 서비스 오류가 발생했습니다.',
        aiType: aiName
      });

      logDebug('AI service error', {
        messageId,
        aiType: aiName,
        error: error.message
      });
    }
  }

  return io;
};

<backend/utils/encryption.js>
// backend/utils/encryption.js
const crypto = require('crypto');
const { promisify } = require('util');
const config = require('../config/keys');

class Encryption {
  static getKey() {
    let key = config.encryptionKey;
    
    // 키가 없는 경우 에러
    if (!key) {
      throw new Error('Encryption key is not set');
    }

    // 키가 hex 문자열인 경우 버퍼로 변환
    if (typeof key === 'string') {
      key = Buffer.from(key, 'hex');
    }

    // 키 길이가 32바이트가 아닌 경우 처리
    if (key.length !== 32) {
      // 키가 짧은 경우 늘리고, 긴 경우 자름
      key = crypto.createHash('sha256').update(String(key)).digest();
    }

    return key;
  }

  static getSalt() {
    let salt = config.passwordSalt;
    
    if (!salt) {
      throw new Error('Password salt is not set');
    }

    // salt가 hex 문자열인 경우 버퍼로 변환
    if (typeof salt === 'string') {
      salt = Buffer.from(salt, 'hex');
    }

    return salt;
  }

  static encrypt(text) {
    if (!text) return text;

    try {
      const iv = crypto.randomBytes(16);
      const key = this.getKey();
      
      const cipher = crypto.createCipheriv('aes-256-cbc', key, iv);
      
      let encrypted = cipher.update(text.toString(), 'utf8', 'hex');
      encrypted += cipher.final('hex');
      
      // IV를 암호문과 함께 저장 (복호화할 때 필요)
      return iv.toString('hex') + ':' + encrypted;
    } catch (error) {
      console.error('Encryption error:', error);
      throw new Error('암호화 중 오류가 발생했습니다.');
    }
  }

  static decrypt(text) {
    if (!text) return text;

    try {
      const [ivHex, encryptedHex] = text.split(':');
      
      if (!ivHex || !encryptedHex) {
        throw new Error('Invalid encrypted text format');
      }

      const iv = Buffer.from(ivHex, 'hex');
      const key = this.getKey();
      const encrypted = Buffer.from(encryptedHex, 'hex');
      
      const decipher = crypto.createDecipheriv('aes-256-cbc', key, iv);
      
      let decrypted = decipher.update(encrypted);
      decrypted = Buffer.concat([decrypted, decipher.final()]);
      
      return decrypted.toString('utf8');
    } catch (error) {
      console.error('Decryption error:', error);
      throw new Error('복호화 중 오류가 발생했습니다.');
    }
  }

  static async hashPassword(password) {
    try {
      const salt = this.getSalt();
      // PBKDF2로 비밀번호 해시 생성 (더 안전한 방식)
      const pbkdf2 = promisify(crypto.pbkdf2);
      const key = await pbkdf2(password, salt, 100000, 64, 'sha512');
      return key.toString('hex');
    } catch (error) {
      console.error('Password hashing error:', error);
      throw new Error('비밀번호 해싱 중 오류가 발생했습니다.');
    }
  }

  static generateKey() {
    // 새로운 32바이트 키 생성
    return crypto.randomBytes(32);
  }

  static generateSalt() {
    // 새로운 16바이트 솔트 생성
    return crypto.randomBytes(16);
  }
}

// 초기화 시 키와 솔트 유효성 검사
(() => {
  try {
    Encryption.getKey();
    Encryption.getSalt();
  } catch (error) {
    console.error('Encryption initialization error:', error);
    console.log('Generating new encryption keys...');
    
    // 새로운 키와 솔트 생성
    const newKey = Encryption.generateKey();
    const newSalt = Encryption.generateSalt();
    
    console.log(`Please set the following values in your environment:
ENCRYPTION_KEY=${newKey.toString('hex')}
PASSWORD_SALT=${newSalt.toString('hex')}`);
    
    process.exit(1);
  }
})();

module.exports = Encryption;

<backend/utils/redisClient.js>
// backend/utils/redisClient.js
const Redis = require('redis');
const { redisHost, redisPort } = require('../config/keys');

class RedisClient {
  constructor() {
    this.client = null;
    this.isConnected = false;
    this.connectionAttempts = 0;
    this.maxRetries = 5;
    this.retryDelay = 5000;
  }

  async connect() {
    if (this.isConnected && this.client) {
      return this.client;
    }

    try {
      console.log('Connecting to Redis...');

      this.client = Redis.createClient({
        url: `redis://${redisHost}:${redisPort}`,
        socket: {
          host: redisHost,
          port: redisPort,
          reconnectStrategy: (retries) => {
            if (retries > this.maxRetries) {
              return null;
            }
            return Math.min(retries * 50, 2000);
          }
        }
      });

      this.client.on('connect', () => {
        console.log('Redis Client Connected');
        this.isConnected = true;
        this.connectionAttempts = 0;
      });

      this.client.on('error', (err) => {
        console.error('Redis Client Error:', err);
        this.isConnected = false;
      });

      await this.client.connect();
      return this.client;

    } catch (error) {
      console.error('Redis connection error:', error);
      this.isConnected = false;
      this.retryConnection();
      throw error;
    }
  }

  async set(key, value, options = {}) {
    try {
      if (!this.isConnected) {
        await this.connect();
      }

      let stringValue;
      if (typeof value === 'object') {
        stringValue = JSON.stringify(value);
      } else {
        stringValue = String(value);
      }

      if (options.ttl) {
        return await this.client.setEx(key, options.ttl, stringValue);
      }
      return await this.client.set(key, stringValue);
    } catch (error) {
      console.error('Redis set error:', error);
      throw error;
    }
  }

  async get(key) {
    try {
      if (!this.isConnected) {
        await this.connect();
      }

      const value = await this.client.get(key);
      if (!value) return null;

      try {
        return JSON.parse(value);
      } catch (parseError) {
        return value;  // 일반 문자열인 경우 그대로 반환
      }
    } catch (error) {
      console.error('Redis get error:', error);
      throw error;
    }
  }

  async setEx(key, seconds, value) {
    try {
      if (!this.isConnected) {
        await this.connect();
      }

      let stringValue;
      if (typeof value === 'object') {
        stringValue = JSON.stringify(value);
      } else {
        stringValue = String(value);
      }

      return await this.client.setEx(key, seconds, stringValue);
    } catch (error) {
      console.error('Redis setEx error:', error);
      throw error;
    }
  }

  async del(key) {
    try {
      if (!this.isConnected) {
        await this.connect();
      }
      return await this.client.del(key);
    } catch (error) {
      console.error('Redis del error:', error);
      throw error;
    }
  }

  async expire(key, seconds) {
    try {
      if (!this.isConnected) {
        await this.connect();
      }
      return await this.client.expire(key, seconds);
    } catch (error) {
      console.error('Redis expire error:', error);
      throw error;
    }
  }

  async quit() {
    if (this.client) {
      try {
        await this.client.quit();
        this.isConnected = false;
        this.client = null;
        console.log('Redis connection closed successfully');
      } catch (error) {
        console.error('Redis quit error:', error);
        throw error;
      }
    }
  }
}

const redisClient = new RedisClient();
module.exports = redisClient;

<e2e/create_e2e_codes.js>
const fs = require('fs');
const path = require('path');

// 결과를 저장할 파일 경로
const outputFilePath = path.join(__dirname, 'e2e20241129');

// 파일을 탐색하는 함수
function scanDirectory(dir, excludeDirs) {
  const files = fs.readdirSync(dir);

  files.forEach(file => {
    const fullPath = path.join(dir, file);
    const stat = fs.lstatSync(fullPath);

    // 제외할 디렉토리 검사
    if (stat.isDirectory() && !excludeDirs.includes(file)) {
      scanDirectory(fullPath, excludeDirs);
    } else if (stat.isFile()) {
      // 제외할 파일 검사
      if (
        file !== 'package-lock.json' && 
        !file.endsWith('.backup') &&
        !file.endsWith('.temp') &&
        file !== 'patch.js' &&
        file !== 'create_e2e_codes.js' &&
        !file.endsWith('.png') // .png 파일 제외 조건 추가
      ) {
        appendFileContent(fullPath);
      }
    }
  });
}

// 파일 경로와 내용을 'source_codes' 파일에 추가
function appendFileContent(filePath) {
  const fileContent = fs.readFileSync(filePath, 'utf-8');
  const formattedContent = `\n<${filePath}>\n\n${fileContent}\n\n`;
  fs.appendFileSync(outputFilePath, formattedContent);
}

// 기존 'source_codes' 파일이 있다면 삭제
if (fs.existsSync(outputFilePath)) {
  fs.unlinkSync(outputFilePath);
}

// 현재 디렉토리에서 시작, node_modules, logs, .next 디렉토리 제외
scanDirectory(__dirname, ['node_modules', 'logs', '.next', 'uploads', 'chat-app', 'images', 'build', 'public', 'e2e', 'test-results', 'playwright-report', 'playwright-reports', 'fixtures', 'combined-report', 'data']);

console.log(`Source codes have been saved to ${outputFilePath}`);


<e2e/package.json>
{
  "name": "bootcampchat-e2e",
  "version": "1.0.0",
  "description": "E2E tests for BootcampChat",
  "scripts": {
    "test": "playwright test",
    "test:headed": "playwright test --headed",
    "test:ui": "playwright test --ui",
    "report": "playwright show-report"
  },
  "devDependencies": {
    "@playwright/test": "^1.49.0",
    "@types/node": "^20.17.7",
    "http-server": "^14.1.1",
    "typescript": "^5.7.2"
  },
  "main": "index.js",
  "author": "",
  "license": "ISC",
  "dependencies": {
    "axios": "^1.7.8",
    "dotenv": "^16.4.5",
    "openai": "^4.73.1",
    "playwright": "^1.49.0"
  }
}


<e2e/playwright.config.ts>
import { PlaywrightTestConfig, devices } from '@playwright/test';

const config: PlaywrightTestConfig = {
  testDir: './test',
  timeout: 600000, // 전체 테스트 타임아웃 증가
  expect: { 
    timeout: 20000  // expect 작업 타임아웃 증가
  },
  fullyParallel: false,  // 순차 실행으로 변경
  retries: 0, // 재시도 횟수 설정
  workers: 2,  // 동시 실행 워커 수 제한
  reporter: [['html', { open: 'never' }]],
  use: {
    baseURL: process.env.BASE_URL || 'http://localhost:3000',
    trace: 'on-first-retry',
    screenshot: 'only-on-failure',
    actionTimeout: 60000,  // 액션 타임아웃 설정
    navigationTimeout: 60000, // 네비게이션 타임아웃 설정
    video: 'retain-on-failure' // 실패 시 비디오 저장
  },
  projects: [
    {
      name: 'chromium',
      use: { ...devices['Desktop Chrome'] },
    },
    {
      name: 'firefox',
      use: { ...devices['Desktop Firefox'] },
    },
    {
      name: 'webkit',
      use: { ...devices['Desktop Safari'] },
    },
  ],
};

export default config;

<e2e/run.sh>
#!/bin/bash

# 색상 코드 정의
GREEN='\033[0;32m'
RED='\033[0;31m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# PID 파일과 리포트 디렉토리 경로 설정
PID_FILE="/tmp/playwright-report.pid"
REPORT_DIR="playwright-report"
COMBINED_REPORT_DIR="combined-report"
TEST_RESULTS_DIR="test-results"

# 중단 처리를 위한 변수들
CURRENT_BROWSER=""
CURRENT_TIMESTAMP=""
INTERRUPTED=0

# 브라우저 타입 정의
declare -A BROWSERS=(
  ["chromium"]="Chromium"
  ["firefox"]="Firefox"
  ["webkit"]="WebKit (Safari)"
  ["all"]="모든 브라우저"
)

# 테스트 모듈 및 시나리오 정의
declare -A TEST_MODULES=(
  ["인증"]="auth/auth.spec.ts"
  ["프로필"]="profile/profile.spec.ts"
  ["채팅방"]="chatrooms/chatrooms.spec.ts"
  ["메시징"]="messaging/messaging.spec.ts"
  ["고급 메시징"]="messaging/advanced-messaging.spec.ts"
  ["이미지"]="files/image-upload.spec.ts"
  ["PDF"]="files/pdf-upload.spec.ts"
  ["비디오"]="files/video-upload.spec.ts"
  ["AI 기본"]="ai/ai.spec.ts"
  ["AI 대화"]="ai/ai-conversation.spec.ts"
  ["AI 논쟁"]="debate/debate.spec.ts"
  ["실시간"]="realtime/realtime.spec.ts"
  ["실시간 상태"]="realtime/presence.spec.ts"
  ["에러처리"]="error/error-handling.spec.ts"
  ["부하테스트"]="load/load-testing.spec.ts"
)

# 테스트 결과와 리포트 저장을 위한 배열
declare -A test_results
declare -A test_summaries
declare -A browser_reports

# 임시 디렉토리 정리 함수
cleanup_reports() {
  echo -e "\n${BLUE}임시 리포트 파일 정리 중...${NC}"
  find . -maxdepth 1 -type d -name "playwright-report*" -exec rm -rf {} +
  rm -rf "$TEST_RESULTS_DIR"
  echo -e "${GREEN}정리 완료${NC}"
}

# 중단 처리 함수
cleanup() {
  if [ $INTERRUPTED -eq 0 ]; then
    INTERRUPTED=1
    echo -e "\n${YELLOW}테스트가 중단되었습니다. 지금까지의 결과를 저장합니다...${NC}"
    
    if [ -n "$CURRENT_BROWSER" ] && [ -n "$CURRENT_TIMESTAMP" ]; then
      generate_combined_report "$CURRENT_TIMESTAMP"
      cleanup_reports
      start_report_server
    fi
    
    exit 1
  fi
}

# 중단 신호 처리 설정
trap cleanup SIGINT SIGTERM

# 브라우저 선택 메뉴 표시 함수
show_browser_menu() {
  echo -e "\n${BLUE}사용할 브라우저를 선택하세요:${NC}"
  local count=1
  for browser in "${!BROWSERS[@]}"; do
    echo -e "${count}) ${browser} - ${BROWSERS[$browser]}"
    ((count++))
  done
  read -p "선택 (기본: chromium): " selection
  
  case "$selection" in
    2) echo "firefox" ;;
    3) echo "webkit" ;;
    4) echo "all" ;;
    *) echo "chromium" ;;
  esac
}

# 테스트 실행 함수
run_tests() {
  local selected_browser="$1"
  CURRENT_TIMESTAMP=$(date +%Y%m%d_%H%M%S)
  START_TIME=$(date +%s)
  local test_exit_code=0
  local failed_tests=()

  mkdir -p "$COMBINED_REPORT_DIR/data"
  mkdir -p "$TEST_RESULTS_DIR"
  
  echo -e "${BLUE}=== BootcampChat E2E 테스트 시작 ===${NC}"

  if [ "$selected_browser" = "all" ]; then
    local browsers=("chromium" "firefox" "webkit")
  else
    local browsers=("$selected_browser")
  fi

  # 의존성 설치
  echo -e "\n${BLUE}1. 의존성 설치 중...${NC}"
  if npm install; then
    echo -e "${GREEN}✓ 의존성 설치 완료${NC}"
  else
    echo -e "${RED}✗ 의존성 설치 실패${NC}"
    exit 1
  fi

  # Playwright 브라우저 설치
  echo -e "\n${BLUE}2. Playwright 브라우저 설치 중...${NC}"
  if npx playwright install; then
    echo -e "${GREEN}✓ 브라우저 설치 완료${NC}"
  else
    echo -e "${RED}✗ 브라우저 설치 실패${NC}"
    exit 1
  fi

  # 실행 중인 리포트 서버 종료
  stop_report_server

  # 브라우저별 테스트 실행
  for browser in "${browsers[@]}"; do
    CURRENT_BROWSER=$browser
    echo -e "\n${BLUE}브라우저 [${BROWSERS[$browser]}] 테스트 시작${NC}"
    
    # 브라우저별 결과/리포트 디렉토리 설정
    local browser_results_dir="${TEST_RESULTS_DIR}/${browser}_${CURRENT_TIMESTAMP}"
    local browser_report_dir="${REPORT_DIR}_${browser}_${CURRENT_TIMESTAMP}"
    browser_reports[$browser]=$browser_report_dir
    mkdir -p "$browser_results_dir" "$browser_report_dir"

    # 모든 테스트 파일을 하나의 배열로 준비
    local test_files=()
    for module_name in "${!TEST_MODULES[@]}"; do
      test_files+=("test/${TEST_MODULES[$module_name]}")
    done

    # 모든 테스트를 한 번의 명령어로 실행
    echo -e "\n${YELLOW}테스트 실행 중... (${#test_files[@]} 개의 테스트)${NC}"
    if ! npx playwright test "${test_files[@]}" \
        --project=$browser \
        --reporter=list,html; then
      echo -e "${RED}✗ 일부 테스트가 실패했습니다${NC}"
      test_results[$browser]=0
      test_exit_code=1
    else
      echo -e "${GREEN}✓ 모든 테스트가 성공했습니다${NC}"
      test_results[$browser]=${#test_files[@]}
    fi

    # 테스트 결과 저장
    if [ -d "$REPORT_DIR" ]; then
      cp -r "$REPORT_DIR"/* "$browser_report_dir/"
    fi

    # 브라우저별 테스트 요약 생성
    local total_tests=${#test_files[@]}
    local passed_tests=${test_results[$browser]}
    local failed_count=$((total_tests - passed_tests))
    test_summaries[$browser]="총 테스트: $total_tests, 성공: $passed_tests, 실패: $failed_count"

    # 테스트 결과 생성
    generate_combined_report "$CURRENT_TIMESTAMP"
  done

  # 최종 결과 출력
  END_TIME=$(date +%s)
  DURATION=$((END_TIME - START_TIME))
  
  echo -e "\n${BLUE}=== 테스트 실행 완료 ===${NC}"
  echo -e "총 소요 시간: ${DURATION}초"

  # 브라우저별 결과 출력
  for browser in "${!test_summaries[@]}"; do
    echo -e "\n${BROWSERS[$browser]} 결과:"
    echo -e "${test_summaries[$browser]}"
  done

  if [ ${#failed_tests[@]} -gt 0 ]; then
    echo -e "\n${RED}실패한 테스트 목록:${NC}"
    for failed_test in "${failed_tests[@]}"; do
      echo -e "${RED}- ${failed_test}${NC}"
    done
  fi

  cleanup_reports
  start_report_server

  return $test_exit_code
}

# 통합 리포트 생성 함수
generate_combined_report() {
  local timestamp=$1
  echo -e "\n${BLUE}통합 리포트 생성 중...${NC}"

  if [ -d "$COMBINED_REPORT_DIR" ]; then
    mv "$COMBINED_REPORT_DIR" "${COMBINED_REPORT_DIR}_backup"
  fi

  mkdir -p "$COMBINED_REPORT_DIR/data"

  # 브라우저별 결과 통합
  for browser in "${!browser_reports[@]}"; do
    local browser_dir="${browser_reports[$browser]}"
    if [ -d "$browser_dir" ]; then
      find "$browser_dir" -type f -not -name "index.html" -exec cp {} "$COMBINED_REPORT_DIR/data/" \;
      
      local browser_results_dir="${TEST_RESULTS_DIR}/${browser}_${timestamp}"
      if [ -d "$browser_results_dir" ]; then
        find "$browser_results_dir" -type f -not -name "index.html" -exec cp {} "$COMBINED_REPORT_DIR/data/" \;
      fi
    fi
  done

  if [ -d "$REPORT_DIR" ]; then
    cp "$REPORT_DIR/index.html" "$COMBINED_REPORT_DIR/"
  fi

  # 테스트 요약 생성
  {
    echo "# BootcampChat E2E 테스트 결과"
    echo "## 실행 시간: $(date '+%Y-%m-%d %H:%M:%S')"
    if [ $INTERRUPTED -eq 1 ]; then
      echo "## ⚠️ 테스트가 중단되었습니다"
    fi
    
    echo -e "\n## 브라우저별 결과"
    for browser in "${!test_summaries[@]}"; do
      echo "### ${BROWSERS[$browser]}"
      echo "${test_summaries[$browser]}"
    done
    
    if [ ${#failed_tests[@]} -gt 0 ]; then
      echo -e "\n## 실패한 테스트"
      for failed_test in "${failed_tests[@]}"; do
        echo "- ${failed_test}"
      done
    fi
  } > "$COMBINED_REPORT_DIR/summary.md"

  echo -e "${GREEN}통합 리포트 생성 완료${NC}"

  if [ -d "${COMBINED_REPORT_DIR}_backup" ]; then
    rm -rf "${COMBINED_REPORT_DIR}_backup"
  fi
}

# 리포트 서버 시작 함수
start_report_server() {
  if [ -f "$PID_FILE" ]; then
    pid=$(cat "$PID_FILE")
    if ps -p $pid > /dev/null 2>&1; then
      echo -e "${RED}리포트 서버가 이미 실행 중입니다 (PID: $pid)${NC}"
      echo -e "${BLUE}http://0.0.0.0:9323 에서 확인할 수 있습니다${NC}"
      return 1
    else
      rm "$PID_FILE"
    fi
  fi

  if [ ! -d "$COMBINED_REPORT_DIR" ]; then
    echo -e "${RED}리포트 디렉토리가 존재하지 않습니다${NC}"
    return 1
  fi

  echo -e "${BLUE}테스트 리포트 서버를 시작합니다...${NC}"
  npx playwright show-report "$COMBINED_REPORT_DIR" --host 0.0.0.0 --port 9323 > /dev/null 2>&1 &
  echo $! > "$PID_FILE"
  echo -e "${GREEN}리포트 서버가 시작되었습니다 (PID: $(cat $PID_FILE))${NC}"
  echo -e "${BLUE}리포트는 http://0.0.0.0:9323 에서 확인할 수 있습니다${NC}"
}

# 리포트 서버 중지 함수
stop_report_server() {
  if [ -f "$PID_FILE" ]; then
    pid=$(cat "$PID_FILE")
    if ps -p $pid > /dev/null 2>&1; then
      kill $pid
      rm "$PID_FILE"
      echo -e "${GREEN}리포트 서버가 중지되었습니다 (PID: $pid)${NC}"
    else
      echo -e "${RED}리포트 서버가 실행중이지 않습니다${NC}"
      rm "$PID_FILE"
    fi
  else
    echo -e "${RED}리포트 서버가 실행중이지 않습니다${NC}"
  fi
}

# 리포트 서버 상태 확인 함수
status_report_server() {
  if [ -f "$PID_FILE" ]; then
    pid=$(cat "$PID_FILE")
    if ps -p $pid > /dev/null 2>&1; then
      echo -e "${GREEN}리포트 서버가 실행 중입니다 (PID: $pid)${NC}"
      echo -e "${BLUE}http://0.0.0.0:9323 에서 확인할 수 있습니다${NC}"
    else
      echo -e "${RED}리포트 서버가 실행중이지 않습니다${NC}"
      rm "$PID_FILE"
    fi
  else
    echo -e "${RED}리포트 서버가 실행중이지 않습니다${NC}"
  fi
}

# 사용법 출력 함수
show_usage() {
  echo "Usage: $0 {start [browser]|report [start|stop|status]}"
  echo "Commands:"
  echo "  start [browser]     테스트를 실행합니다"
  echo "    browser options:  chromium (기본값), firefox, webkit, all"
  echo "  report start        테스트 리포트 서버를 시작합니다"
  echo "  report stop         테스트 리포트 서버를 중지합니다"
  echo "  report status       테스트 리포트 서버 상태를 확인합니다"
  exit 1
}

# 메인 로직
case "$1" in
  start)
    browser="${2:-$(show_browser_menu)}"
    if [[ -n "${BROWSERS[$browser]}" ]]; then
      run_tests "$browser"
    else
      echo -e "${RED}잘못된 브라우저 선택: $browser${NC}"
      show_usage
    fi
    ;;
  report)
    case "$2" in
      start)
        start_report_server
        ;;
      stop)
        stop_report_server
        ;;
      status)
        status_report_server
        ;;
      *)
        show_usage
        ;;
    esac
    ;;
  *)
    show_usage
    ;;
esac

<e2e/test/ai/ai-conversation.spec.ts>
import { test, expect } from '@playwright/test';
import { TestHelpers } from '../helpers/test-helpers';
import { MessageService } from '../services/message-service';
import * as dotenv from 'dotenv';

// .env 파일 로드
dotenv.config();

test.describe('AI 대화 시나리오', () => {
  const helpers = new TestHelpers();
  let messageService: MessageService;

  test.beforeAll(async () => {
    messageService = new MessageService();
  });

  test('AI와의 복잡한 대화', async ({ browser }) => {  
    const page = await browser.newPage();
    const creds = helpers.getTestUser(0);
    await helpers.registerUser(page, creds);
    const roomName = await helpers.joinOrCreateRoom(page, 'AI-Chat');

    // 인사 메시지 생성 및 전송
    const greeting = await messageService.generateMessage('GREETING', {
      USER_NAME: creds.name,
      ROOM_NAME: roomName
    });
    await helpers.sendAIMessage(page, greeting, 'wayneAI');
    await expect(page.locator('.message-ai').last()).toBeVisible();

    // 비즈니스 관련 질문 생성 및 전송
    const businessQuestion = await messageService.generateMessage('GROUP_CHAT', {
      CURRENT_TOPIC: '기술 트렌드',
      USER_NAME: creds.name
    });
    await helpers.sendAIMessage(page, businessQuestion, 'wayneAI');
    const businessResponse = await page.locator('.message-ai').nth(1);
    await expect(businessResponse).toBeVisible();

    // 코드 리뷰 요청 생성 및 전송
    const codeReviewRequest = await messageService.generateMessage('CHAT_RESPONSE', {
      PREV_MESSAGE: 'function sum(a, b) { return a + b; }',
      USER_NAME: creds.name
    });
    await helpers.sendAIMessage(page, codeReviewRequest, 'wayneAI');
    const codeReviewResponse = await page.locator('.message-ai').nth(2);
    await expect(codeReviewResponse).toBeVisible();

    // // 응답 검증
    // const messages = await page.locator('.message-ai').all();
    // expect(messages).toHaveLength(3);

    // // 각 응답이 적절한 내용을 포함하는지 확인
    // for (const message of messages) {
    //   const content = await message.textContent();
    //   // expect(content?.length).toBeGreaterThan(0);
    //   expect(content).not.toContain('error');
    //   expect(content).not.toContain('Error');
    // }
  });

  test('AI와의 기술 토론', async ({ browser }) => {  
    const page = await browser.newPage();
    const creds = helpers.getTestUser(1);
    await helpers.registerUser(page, creds);
    await helpers.joinOrCreateRoom(page, 'AI-Tech-Discussion');

    // 기술 토론 주제
    const topics = ['AI 윤리', '웹 개발 트렌드', '클라우드 컴퓨팅'];

    for (const topic of topics) {
      // 토론 질문 생성 및 전송
      const question = await messageService.generateMessage('GROUP_CHAT', {
        CURRENT_TOPIC: topic,
        USER_NAME: creds.name
      });
      
      await helpers.sendAIMessage(page, question, 'wayneAI');
      
      // AI 응답 대기 및 확인
      const response = await page.locator('.message-ai').last();
      await expect(response).toBeVisible();
      const content = await response.textContent();
      // expect(content).toBeTruthy();
    }

    // 전체 대화 내용 확인
    // const allMessages = await page.locator('.message-ai').all();
    // expect(allMessages).toHaveLength(topics.length);
  });
});

<e2e/test/ai/ai.spec.ts>
// test/ai/ai.spec.ts
import { test, expect } from '@playwright/test';
import { TestHelpers } from '../helpers/test-helpers';

test.describe('AI 상호작용 테스트', () => {
  const helpers = new TestHelpers();

  test('다양한 AI와의 대화', async ({ page }) => {
    // 사용자 등록 및 채팅방 생성
    const credentials = helpers.getTestUser(Math.floor(Math.random() * 1001));
    await helpers.registerUser(page, credentials);
    await helpers.joinOrCreateRoom(page, 'AI-Test');
    
    // Wayne AI와 대화
    await helpers.sendAIMessage(page, '안녕하세요', 'wayneAI');
    await expect(page.locator('.message-ai').last()).toBeVisible();
    
    // Consulting AI와 대화
    await helpers.sendAIMessage(page, '비즈니스 조언이 필요해요', 'consultingAI');
    await expect(page.locator('.message-ai').last()).toBeVisible();
    
    // 기본값(wayneAI) 사용
    await helpers.sendAIMessage(page, '감사합니다');
    await expect(page.locator('.message-ai').last()).toBeVisible();
  });
});

<e2e/test/auth/auth.spec.ts>
import { test, expect } from '@playwright/test';
import { TestHelpers } from '../helpers/test-helpers';

test.describe('인증 테스트', () => {
  const helpers = new TestHelpers();

  test('회원가입 및 로그인 흐름', async ({ page }) => {
    const credentials = helpers.generateUserCredentials(1);
    
    // 1. 회원가입
    await helpers.registerUser(page, credentials);
    
    // 채팅방 목록 페이지 확인
    await expect(page).toHaveURL('/chat-rooms');
    
    // 채팅방 목록 페이지의 필수 요소들이 로드되었는지 확인
    await expect(page.locator('.chat-rooms-card')).toBeVisible({ timeout: 30000 });

    // 채팅방 목록 헤더 텍스트 확인 (Card.Title 사용)
    await expect(page.locator('h5')).toHaveText('채팅방 목록');
    
    // 연결 상태 확인
    await expect(page.locator('.text-success')).toBeVisible();
    await expect(page.locator('.text-success')).toHaveText('연결됨');
  });

//   test('로그인 실패 케이스', async ({ page }) => {
//     const invalidCredentials = {
//       email: 'invalid@example.com',
//       password: 'wrongpassword'
//     };

//     await page.goto('/');
//     await page.waitForLoadState('networkidle');

//     // 입력 필드가 로드될 때까지 대기
//     await page.waitForSelector('input[name="email"]');
//     await page.waitForSelector('input[name="password"]');

//     await page.fill('input[name="email"]', invalidCredentials.email);
//     await page.fill('input[name="password"]', invalidCredentials.password);

//     // 폼 제출
//     await Promise.all([
//       page.waitForResponse(response => 
//         response.url().includes('/api/auth/login') && 
//         response.status() === 401
//       ),
//       page.click('button[type="submit"]')
//     ]);

//     // 에러 메시지 확인
//     await expect(page.locator('.alert.alert-danger')).toBeVisible({
//       timeout: 30000
//     });
//   });

//   test('회원가입 유효성 검사', async ({ page }) => {
//     await page.goto('/register');
//     await page.waitForLoadState('networkidle');

//     // 빈 폼 제출 시도
//     await Promise.all([
//       page.waitForResponse(response => 
//         response.url().includes('/api/auth/register') && 
//         response.status() === 400
//       ),
//       page.click('button[type="submit"]')
//     ]);

//     // 에러 메시지 확인
//     await expect(page.locator('.alert.alert-danger')).toBeVisible({
//       timeout: 30000
//     });

//     // 잘못된 이메일 형식
//     const invalidData = {
//       name: 'Test User',
//       email: 'invalid-email',
//       password: 'password123',
//       confirmPassword: 'password123'
//     };

//     await page.fill('input[name="name"]', invalidData.name);
//     await page.fill('input[name="email"]', invalidData.email);
//     await page.fill('input[name="password"]', invalidData.password);
//     await page.fill('input[name="confirmPassword"]', invalidData.confirmPassword);

//     await Promise.all([
//       page.waitForResponse(response => 
//         response.url().includes('/api/auth/register') && 
//         response.status() === 400
//       ),
//       page.click('button[type="submit"]')
//     ]);

//     await expect(page.locator('.alert.alert-danger')).toBeVisible({
//       timeout: 30000
//     });
//   });
});

<e2e/test/chatrooms/chatrooms.spec.ts>
import { test, expect } from '@playwright/test';
import { TestHelpers } from '../helpers/test-helpers';

test.describe('메시징 테스트', () => {
  const helpers = new TestHelpers();

  test('여러 사용자간 실시간 채팅', async ({ browser }) => {
    const roomPrefix = 'Chat';
    
    // 병렬로 사용자 생성 및 등록
    const [user1, user2, user3] = await Promise.all([
      browser.newPage(),
      browser.newPage(),
      browser.newPage()
    ]);

    const users = [user1, user2, user3];
    const credentials = users.map((_, i) => helpers.generateUserCredentials(i + 1));

    // 각 사용자 등록
    await Promise.all([
      helpers.registerUser(user1, credentials[0]),
      helpers.registerUser(user2, credentials[1]),
      helpers.registerUser(user3, credentials[2])
    ]);

    // 첫 번째 사용자가 방 생성 및 정확한 방 이름 저장
    const createdRoomName = await helpers.joinOrCreateRoom(user1, roomPrefix);
    console.log(`Created room name: ${createdRoomName}`);

    // 생성된 방의 URL 파라미터 확인
    const hostUrl = user1.url();
    const roomParam = new URLSearchParams(new URL(hostUrl).search).get('room');
    
    if (!roomParam) {
      throw new Error('Failed to get room name from URL');
    }

    // 나머지 사용자들이 같은 방으로 입장
    await helpers.joinRoomByURLParam(user2, roomParam);
    await helpers.joinRoomByURLParam(user3, roomParam);

    // 모든 사용자가 동일한 채팅방에 있는지 확인
    for (const user of users) {
      const userHostUrl = user.url();
    	const userRoomParam = new URLSearchParams(new URL(userHostUrl).search).get('room');
      expect(userRoomParam).toBe(roomParam);
    }

    // 각 사용자마다 채팅창이 로드될 때까지 대기
    await Promise.all(users.map(async user => {
      // 채팅 컨테이너가 표시될 때까지 대기
      await user.waitForLoadState('networkidle');
      await user.waitForSelector('.chat-container', { 
        state: 'visible',
        timeout: 30000 
      });
      
      // 채팅 입력창이 활성화될 때까지 대기
      await user.waitForLoadState('networkidle');
      await user.waitForSelector('.chat-input-textarea:not([disabled])', {
        state: 'visible',
        timeout: 30000
      });
    }));

    // 메시지 전송 및 검증
    const messages = [
      { user: user1, text: `안녕하세요! ${credentials[0].name}입니다.` },
      { user: user2, text: `반갑습니다! ${credentials[1].name}입니다.` },
      { user: user3, text: `안녕하세요~ ${credentials[2].name}입니다!` }
    ];

    // 메시지를 순차적으로 전송하고 각각 확인
    for (const { user, text } of messages) {
      await helpers.sendMessage(user, text);
      
      // // 모든 사용자의 화면에서 메시지가 표시되는지 확인
      // await Promise.all(users.map(async viewer => {
      //   await viewer.waitForSelector(`.message-content:has-text("${text}")`, {
      //     timeout: 10000
      //   });
      // }));
    }

    // // AI 호출 및 응답 확인
    // await helpers.sendAIMessage(user1, '우리 대화에 대해 요약해줄 수 있나요?');
    // await Promise.all(users.map(async user => {
    //   await user.waitForSelector('.message-ai', {
    //     timeout: 20000
    //   });
    // }));

    // 테스트 종료 전 채팅방 확인
    // for (const user of users) {
    //   const finalRoomName = await user.locator('.chat-room-title').textContent();
    //   expect(finalRoomName).toBe(roomParam);
    // }

    // 리소스 정리
    await Promise.all(users.map(user => user.close()));
  });

  test('파일 공유 및 이모지 반응', async ({ browser }) => {
    const roomPrefix = 'FileShare';
    
    // 첫 번째 사용자 설정
    const user1 = await browser.newPage();
    const user1Creds = helpers.getTestUser(Math.floor(Math.random() * 1001));
    await helpers.registerUser(user1, user1Creds);
    
    // 방 생성 및 정확한 방 이름 저장
    const createdRoomName = await helpers.joinOrCreateRoom(user1, roomPrefix);
    console.log(`Created room name: ${createdRoomName}`);

    // 생성된 방의 URL 파라미터 확인
    const hostUrl = user1.url();
    const roomParam = new URLSearchParams(new URL(hostUrl).search).get('room');
    
    if (!roomParam) {
      throw new Error('Failed to get room name from URL');
    }
    
    // 두 번째 사용자 설정 및 같은 방으로 입장
    const user2 = await browser.newPage();
    const user2Creds = helpers.getTestUser(1);
    await helpers.registerUser(user2, user2Creds);
    await helpers.joinRoomByURLParam(user2, roomParam);

    // 양쪽 모두 동일한 채팅방에 있는지 확인
    for (const user of [user1, user2]) {
      const userHostUrl = user.url();
    	const userRoomParam = new URLSearchParams(new URL(userHostUrl).search).get('room');
      expect(userRoomParam).toBe(roomParam);
    }

    // 메시지 전송 및 대기
    const testMessage = '이 메시지에 반응해보세요!';
    await helpers.sendMessage(user1, testMessage);

    // 메시지가 완전히 로드될 때까지 대기
    await user2.waitForLoadState('networkidle');
    // await user2.waitForSelector(`.message-content:has-text("${testMessage}")`, {
    //   state: 'visible',
    //   timeout: 30000
    // });

    // 메시지에 호버 및 반응 버튼 클릭
    const messageElement = user2.locator('.message-actions').last();
    // await messageElement.hover();
    
    // 반응 버튼이 나타날 때까지 대기 후 클릭
    const actionButton = messageElement.locator('button[title="리액션 추가"]');
    await actionButton.waitFor({ state: 'visible', timeout: 30000 });
    await actionButton.click();

    // 이모지 피커의 첫 번째 이모지 선택
    await messageElement.click('.emoji-picker-container button >> nth=0');
    
    // 반응이 표시되는지 확인
    // await Promise.all([
    //   user1.waitForSelector('.reaction-badge', { timeout: 30000 }),
    //   user2.waitForSelector('.reaction-badge', { timeout: 30000 })
    // ]);

    // 테스트 종료 전 채팅방 확인
    // for (const user of [user1, user2]) {
    //   const finalRoomName = await user.locator('.chat-room-title').textContent();
    //   expect(finalRoomName).toBe(roomParam);
    // }

    // 리소스 정리
    await Promise.all([user1.close(), user2.close()]);
  });
});

<e2e/test/data/ai-prompts.ts>
// test/data/ai-prompts.ts

export interface AIPrompt {
  category: string;
  purpose: string;
  prompt: string;
  parameters?: string[];
}

export const TEST_PROMPTS: Record<string, AIPrompt> = {
  GREETING: {
    category: 'Basic',
    purpose: '기본 인사',
    prompt: '안녕하세요! 저는 [AI_NAME]입니다. [USER_NAME]님과 대화를 나누게 되어 기쁩니다.',
    parameters: ['AI_NAME', 'USER_NAME']
  },
  CODE_REVIEW: {
    category: 'Development',
    purpose: '코드 리뷰',
    prompt: '다음 [LANGUAGE] 코드를 리뷰해주세요:\n[CODE]',
    parameters: ['LANGUAGE', 'CODE']
  },
  BUSINESS_ADVICE: {
    category: 'Consulting',
    purpose: '비즈니스 조언',
    prompt: '[INDUSTRY] 산업에서 [TOPIC]에 대한 조언을 제공해주세요.',
    parameters: ['INDUSTRY', 'TOPIC']
  },
  DEBATE: {
    category: 'Discussion',
    purpose: '토론 진행',
    prompt: '[TOPIC]에 대해 [STANCE] 입장에서 논의를 진행해주세요.',
    parameters: ['TOPIC', 'STANCE']
  },
  ANALYSIS: {
    category: 'Analysis',
    purpose: '데이터 분석',
    prompt: '다음 [DATA_TYPE] 데이터를 분석하고 [FOCUS_POINT]에 대한 인사이트를 제공해주세요:\n[DATA]',
    parameters: ['DATA_TYPE', 'FOCUS_POINT', 'DATA']
  }
};

// AI 응답 템플릿
export const AI_RESPONSE_TEMPLATES = {
  ERROR: {
    NO_RESPONSE: '죄송합니다. 현재 응답을 생성할 수 없습니다.',
    INVALID_PROMPT: '잘못된 프롬프트 형식입니다.',
    API_ERROR: 'AI API 호출 중 오류가 발생했습니다.'
  },
  FALLBACK: {
    DEFAULT: '이해했습니다. 어떻게 도와드릴까요?',
    CLARIFICATION: '조금 더 자세히 설명해 주시겠어요?'
  }
};

<e2e/test/data/credentials.ts>
// test/data/credentials.ts
export interface UserCredential {
  name: string;
  email: string;
  password: string;
}

// 테스트용 계정 목록
export const TEST_USERS: UserCredential[] = [
  // 발롱도르 수상자
  {
    name: 'Lionel Messi',
    email: 'test_messi@example.com',
    password: 'TestPass123!'
  },
  {
    name: 'Cristiano Ronaldo',
    email: 'test_ronaldo@example.com', 
    password: 'TestPass123!'
  },
  {
    name: 'Luka Modric',
    email: 'test_modric@example.com',
    password: 'TestPass123!'
  },
  {
    name: 'Karim Benzema',
    email: 'test_benzema@example.com',
    password: 'TestPass123!'
  },
  {
    name: 'Fabio Cannavaro',
    email: 'test_cannavaro@example.com',
    password: 'TestPass123!'
  },

  // 역대 월드컵 영웅들
  {
    name: 'Pelé',
    email: 'test_pele@example.com',
    password: 'TestPass123!'
  },
  {
    name: 'Diego Maradona',
    email: 'test_maradona@example.com',
    password: 'TestPass123!'
  },
  {
    name: 'Zinedine Zidane',
    email: 'test_zidane@example.com',
    password: 'TestPass123!'
  },
  {
    name: 'Ronaldo Nazário',
    email: 'test_r9@example.com',
    password: 'TestPass123!'
  },
  {
    name: 'Miroslav Klose',
    email: 'test_klose@example.com',
    password: 'TestPass123!'
  },

  // 축구 역사의 전설들
  {
    name: 'Johan Cruyff',
    email: 'test_cruyff@example.com',
    password: 'TestPass123!'
  },
  {
    name: 'Franz Beckenbauer',
    email: 'test_beckenbauer@example.com',
    password: 'TestPass123!'
  },
  {
    name: 'Eusébio',
    email: 'test_eusebio@example.com',
    password: 'TestPass123!'
  },
  {
    name: 'Alfredo Di Stéfano',
    email: 'test_distefano@example.com',
    password: 'TestPass123!'
  },
  {
    name: 'Michel Platini',
    email: 'test_platini@example.com',
    password: 'TestPass123!'
  },

  // 전설적인 공격수들
  {
    name: 'Ferenc Puskás',
    email: 'test_puskas@example.com',
    password: 'TestPass123!'
  },
  {
    name: 'Gerd Müller',
    email: 'test_muller@example.com',
    password: 'TestPass123!'
  },
  {
    name: 'Marco van Basten',
    email: 'test_vanbasten@example.com',
    password: 'TestPass123!'
  },
  {
    name: 'Romário',
    email: 'test_romario@example.com',
    password: 'TestPass123!'
  },
  {
    name: 'Hristo Stoichkov',
    email: 'test_stoichkov@example.com',
    password: 'TestPass123!'
  },

  // 전설적인 미드필더들
  {
    name: 'Bobby Charlton',
    email: 'test_charlton@example.com',
    password: 'TestPass123!'
  },
  {
    name: 'Paul Scholes',
    email: 'test_scholes@example.com',
    password: 'TestPass123!'
  },
  {
    name: 'Andrea Pirlo',
    email: 'test_pirlo@example.com',
    password: 'TestPass123!'
  },
  {
    name: 'Xavi Hernández',
    email: 'test_xavi@example.com',
    password: 'TestPass123!'
  },
  {
    name: 'Andrés Iniesta',
    email: 'test_iniesta@example.com',
    password: 'TestPass123!'
  },

  // 전설적인 수비수들
  {
    name: 'Paolo Maldini',
    email: 'test_maldini@example.com',
    password: 'TestPass123!'
  },
  {
    name: 'Franco Baresi',
    email: 'test_baresi@example.com',
    password: 'TestPass123!'
  },
  {
    name: 'Bobby Moore',
    email: 'test_moore@example.com',
    password: 'TestPass123!'
  },
  {
    name: 'Roberto Carlos',
    email: 'test_rcarlos@example.com',
    password: 'TestPass123!'
  },
  {
    name: 'Cafu',
    email: 'test_cafu@example.com',
    password: 'TestPass123!'
  },

  // 전설적인 골키퍼들
  {
    name: 'Lev Yashin',
    email: 'test_yashin@example.com',
    password: 'TestPass123!'
  },
  {
    name: 'Peter Schmeichel',
    email: 'test_schmeichel@example.com',
    password: 'TestPass123!'
  },
  {
    name: 'Oliver Kahn',
    email: 'test_kahn@example.com',
    password: 'TestPass123!'
  },
  {
    name: 'Gianluigi Buffon',
    email: 'test_buffon@example.com',
    password: 'TestPass123!'
  },
  {
    name: 'Iker Casillas',
    email: 'test_casillas@example.com',
    password: 'TestPass123!'
  },

  // 맨체스터 유나이티드 레전드
  {
    name: 'George Best',
    email: 'test_best@example.com',
    password: 'TestPass123!'
  },
  {
    name: 'Eric Cantona',
    email: 'test_cantona@example.com',
    password: 'TestPass123!'
  },
  {
    name: 'Wayne Rooney',
    email: 'test_rooney@example.com',
    password: 'TestPass123!'
  },
  {
    name: 'Ryan Giggs',
    email: 'test_giggs@example.com',
    password: 'TestPass123!'
  },
  {
    name: 'David Beckham',
    email: 'test_beckham@example.com',
    password: 'TestPass123!'
  },

  // 한국 축구 레전드
  {
    name: 'Cha Bum-kun',
    email: 'test_chabk@example.com',
    password: 'TestPass123!'
  },
  {
    name: 'Park Ji-sung',
    email: 'test_parkjs@example.com',
    password: 'TestPass123!'
  },
  {
    name: 'Son Heung-min',
    email: 'test_sonhm@example.com',
    password: 'TestPass123!'
  },
  {
    name: 'Hong Myung-bo',
    email: 'test_hongmb@example.com',
    password: 'TestPass123!'
  },
  {
    name: 'Kim Joo-sung',
    email: 'test_kimjs@example.com',
    password: 'TestPass123!'
  },

  // 현대 축구 스타들
  {
    name: 'Kylian Mbappé',
    email: 'test_mbappe@example.com',
    password: 'TestPass123!'
  },
  {
    name: 'Erling Haaland',
    email: 'test_haaland@example.com',
    password: 'TestPass123!'
  },
  {
    name: 'Kevin De Bruyne',
    email: 'test_kdb@example.com',
    password: 'TestPass123!'
  },
  {
    name: 'Virgil van Dijk',
    email: 'test_vvd@example.com',
    password: 'TestPass123!'
  },
  {
    name: 'Mohamed Salah',
    email: 'test_salah@example.com',
    password: 'TestPass123!'
  },

  // 전설적인 감독들
  {
    name: 'Sir Alex Ferguson',
    email: 'test_ferguson@example.com',
    password: 'TestPass123!'
  },
  {
    name: 'Johan Cruyff',
    email: 'test_cruyff_coach@example.com',
    password: 'TestPass123!'
  },
  {
    name: 'Arrigo Sacchi',
    email: 'test_sacchi@example.com',
    password: 'TestPass123!'
  },
  {
    name: 'Rinus Michels',
    email: 'test_michels@example.com',
    password: 'TestPass123!'
  },
  {
    name: 'Bill Shankly',
    email: 'test_shankly@example.com',
    password: 'TestPass123!'
  },
  {
    name: 'Pep Guardiola',
    email: 'test_guardiola@example.com',
    password: 'TestPass123!'
  },
  {
    name: 'José Mourinho',
    email: 'test_mourinho@example.com',
    password: 'TestPass123!'
  },
  {
    name: 'Carlo Ancelotti',
    email: 'test_ancelotti@example.com',
    password: 'TestPass123!'
  },
  {
    name: 'Vicente del Bosque',
    email: 'test_delbosque@example.com',
    password: 'TestPass123!'
  },
  {
    name: 'Brian Clough',
    email: 'test_clough@example.com',
    password: 'TestPass123!'
  },

  // 추가 전설적 선수들
  {
    name: 'Ronaldinho',
    email: 'test_ronaldinho@example.com',
    password: 'TestPass123!'
  },
  {
    name: 'Thierry Henry',
    email: 'test_henry@example.com',
    password: 'TestPass123!'
  },
  {
    name: 'Raúl González',
    email: 'test_raul@example.com',
    password: 'TestPass123!'
  },
  {
    name: 'Pavel Nedvěd',
    email: 'test_nedved@example.com',
    password: 'TestPass123!'
  },
  {
    name: 'Michael Laudrup',
    email: 'test_laudrup@example.com',
    password: 'TestPass123!'
  },
  {
    name: 'Kenny Dalglish',
    email: 'test_dalglish@example.com',
    password: 'TestPass123!'
  },
  {
    name: 'Steven Gerrard',
    email: 'test_gerrard@example.com',
    password: 'TestPass123!'
  },
  {
    name: 'Frank Lampard',
    email: 'test_lampard@example.com',
    password: 'TestPass123!'
  },
  {
    name: 'Ruud Gullit',
    email: 'test_gullit@example.com',
    password: 'TestPass123!'
  },
  {
    name: 'Alessandro Del Piero',
    email: 'test_delpiero@example.com',
    password: 'TestPass123!'
  }
];

// AI 테스트용 계정
export const AI_TEST_USERS: UserCredential[] = [
  {
    name: 'ChatGPT',
    email: 'gpt_user@example.com',
    password: 'TestPass123!'
  },
  {
    name: 'Claude',
    email: 'claude_user@example.com',
    password: 'TestPass123!'
  }
];

<e2e/test/data/message-prompts.ts>
// test/data/message-prompts.ts

export interface MessagePrompt {
  category: string;
  context: string;
  prompt: string;
  parameters: string[];
}

export const MESSAGE_PROMPTS: Record<string, MessagePrompt> = {
  GREETING: {
    category: 'General',
    context: '채팅방에 처음 입장했을 때의 인사',
    prompt: '[USER_NAME]님이 [ROOM_NAME] 채팅방에 처음 입장했을 때 적절한 인사말을 20자 이내로 생성해주세요.',
    parameters: ['USER_NAME', 'ROOM_NAME']
  },
  CHAT_RESPONSE: {
    category: 'Conversation',
    context: '이전 메시지에 대한 응답',
    prompt: '[PREV_MESSAGE]라는 메시지에 대해 [USER_NAME]님이 할 수 있는 자연스러운 응답을 20자 이내로 생성해주세요.',
    parameters: ['PREV_MESSAGE', 'USER_NAME']
  },
  GROUP_CHAT: {
    category: 'Group',
    context: '그룹 채팅에서의 대화 참여',
    prompt: '[CURRENT_TOPIC]에 대한 그룹 대화에서 [USER_NAME]님이 할 수 있는 적절한 답변을 20자 이내로 생성해주세요.',
    parameters: ['CURRENT_TOPIC', 'USER_NAME']
  },
  FILE_COMMENT: {
    category: 'File',
    context: '파일 공유 시 코멘트',
    prompt: '[FILE_TYPE] 파일인 [FILE_NAME]을 공유할 때 덧붙일 수 있는 적절한 코멘트를 20자 이내로 생성해주세요.',
    parameters: ['FILE_TYPE', 'FILE_NAME']
  },
  REACTION_COMMENT: {
    category: 'Reaction',
    context: '이모지 리액션에 대한 답변',
    prompt: '[REACTION_EMOJI]로 리액션한 메시지에 대한 답변을 20자 이내로 생성해주세요.',
    parameters: ['REACTION_EMOJI']
  }
};

<e2e/test/debate/debate.spec.ts>
import { test, expect } from '@playwright/test';
import { TestHelpers } from '../helpers/test-helpers';

test.describe('AI 축구 논쟁 테스트', () => {
  const helpers = new TestHelpers();

  test('메시 vs 호날두 논쟁', async ({ browser }) => {
    const roomPrefix = 'Football-Debate';
    
    // GPT 사용자 (메시 지지자) 설정
    const messiSupporter = await browser.newPage();
    const messiCreds = helpers.getAITestUser('gpt');
    await helpers.registerUser(messiSupporter, messiCreds);
    
    // 메시 지지자가 방 생성 및 정확한 방 이름 저장
    const createdRoomName = await helpers.joinOrCreateRoom(messiSupporter, roomPrefix);
    console.log(`Created room name: ${createdRoomName}`);

    // 생성된 방의 URL 파라미터 확인
    const messiUrl = messiSupporter.url();
    const roomParam = new URLSearchParams(new URL(messiUrl).search).get('room');
    
    if (!roomParam) {
      throw new Error('Failed to get room name from URL');
    }
    
    // Claude 사용자 (호날두 지지자) 설정 및 같은 방으로 입장
    const ronaldoSupporter = await browser.newPage();
    const ronaldoCreds = helpers.getAITestUser('claude');
    await helpers.registerUser(ronaldoSupporter, ronaldoCreds);
    await helpers.joinRoomByURLParam(ronaldoSupporter, roomParam);

    // 양쪽 모두 동일한 채팅방에 있는지 확인
    for (const page of [messiSupporter, ronaldoSupporter]) {
      const userHostUrl = page.url();
    	const userRoomParam = new URLSearchParams(new URL(userHostUrl).search).get('room');
      expect(userRoomParam).toBe(roomParam);
    }

    // 논쟁 주제 및 포인트 정의
    const debatePoints = [
      {
        messiPoint: "메시의 드리블은 예술 수준입니다. 그의 볼 컨트롤과 민첩성은 축구 역사상 전례가 없죠.",
        ronaldoResponse: "반면 호날두는 현대 축구에서 가장 완벽한 신체 조건과 운동 능력을 보여줍니다.",
      },
      {
        messiPoint: "메시는 8번의 발롱도르 수상으로 역대 최다 수상 기록을 보유하고 있습니다.",
        ronaldoResponse: "호날두는 세 개의 다른 리그에서 우승하며 적응력과 다재다능함을 증명했습니다.",
      },
      {
        messiPoint: "메시는 월드컵에서 우승하며 마지막 퍼즐을 완성했고, 이제 GOAT 논쟁은 끝났습니다.",
        ronaldoResponse: "호날두는 챔피언스리그 역대 최다 득점자이며, 국가대표 최다 득점 기록도 보유하고 있습니다.",
      },
      {
        messiPoint: "메시의 패스와 어시스트 능력은 공격수임에도 플레이메이커 역할을 완벽히 수행합니다.",
        ronaldoResponse: "호날두의 헤딩 능력과 점프력은 인간의 한계를 뛰어넘는 수준입니다.",
      },
      {
        messiPoint: "메시는 한 클럽에서 20년 가까이 충성하며 바르셀로나의 황금기를 이끌었습니다.",
        ronaldoResponse: "호날두는 맨유, 레알 마드리드, 유벤투스에서 모두 성공을 거둔 유일한 선수입니다.",
      },
      {
        messiPoint: "메시의 왼발은 마법과도 같습니다. 그의 슈팅과 프리킥은 예술 작품이죠.",
        ronaldoResponse: "호날두의 양발 사용 능력과 다양한 슈팅 기술은 그를 완벽한 공격수로 만듭니다.",
      },
      {
        messiPoint: "메시는 더 적은 경기 수로 더 많은 도움을 기록했습니다. 이는 그의 팀 플레이 능력을 증명합니다.",
        ronaldoResponse: "호날두는 큰 경기에서 더 뛰어난 활약을 보여줍니다. 챔피언스리그 녹아웃 스테이지 기록이 이를 증명합니다.",
      },
      {
        messiPoint: "메시는 좁은 공간에서의 드리블과 볼 컨트롤로 불가능을 가능으로 만듭니다.",
        ronaldoResponse: "호날두는 압도적인 신체능력과 점프력으로 수비수들을 압도합니다.",
      },
      {
        messiPoint: "메시는 자연스러운 재능과 천부적인 감각으로 축구를 예술로 승화시킵니다.",
        ronaldoResponse: "호날두는 끊임없는 노력과 자기관리로 최정상에 오른 프로페셔널의 표본입니다.",
      },
      {
        messiPoint: "메시는 아르헨티나 대표팀을 월드컵 우승으로 이끌며 진정한 리더십을 보여줬습니다.",
        ronaldoResponse: "호날두는 포르투갈 대표팀의 역사를 새로 쓰며 국가대표 최다 득점 기록을 보유하고 있습니다.",
      }
    ];

    // 논쟁 진행
    for (const [index, point] of debatePoints.entries()) {
      // 메시 지지자의 주장
      await helpers.sendMessage(messiSupporter, point.messiPoint);

      // 잠시 대기
      await messiSupporter.waitForTimeout(2000);

      // 호날두 지지자의 반박
      await helpers.sendMessage(ronaldoSupporter, point.ronaldoResponse);

      // 대화 간격을 위한 대기
      await ronaldoSupporter.waitForTimeout(2000);
    }

    // 대화 내용 검증
    const messiMessages = await helpers.getConversationHistory(messiSupporter);
    const ronaldoMessages = await helpers.getConversationHistory(ronaldoSupporter);

    // // 메시 관련 메시지 검증
    // expect(messiMessages.filter(m => m.text.toLowerCase().includes('messi') || 
    //                                m.text.toLowerCase().includes('메시'))).toHaveLength(10);

    // // 호날두 관련 메시지 검증
    // expect(ronaldoMessages.filter(m => m.text.toLowerCase().includes('ronaldo') || 
    //                                  m.text.toLowerCase().includes('호날두'))).toHaveLength(10);

    // // AI 응답 확인
    // const messiAIResponses = await messiSupporter.locator('.message-ai').count();
    // const ronaldoAIResponses = await ronaldoSupporter.locator('.message-ai').count();

    // expect(messiAIResponses).toBe(10);
    // expect(ronaldoAIResponses).toBe(10);

    // // 테스트 종료 전 채팅방 확인
    // for (const page of [messiSupporter, ronaldoSupporter]) {
    //   const finalRoomName = await page.locator('.chat-room-title').textContent();
    //   expect(finalRoomName).toBe(roomParam);
    // }

    // 리소스 정리
    await Promise.all([messiSupporter.close(), ronaldoSupporter.close()]);
  });
});

<e2e/test/error/error-handling.spec.ts>
// test/error/error-handling.spec.ts
import { test, expect } from '@playwright/test';
import { TestHelpers } from '../helpers/test-helpers';

test.describe('에러 처리 테스트', () => {
  const helpers = new TestHelpers();

  test('네트워크 에러 복구', async ({ browser }) => {   
    const page = await browser.newPage();
    const creds = helpers.generateUserCredentials(1);
    await helpers.registerUser(page, creds);
    await helpers.joinOrCreateRoom(page, 'ErrorHandling');

    // 네트워크 차단
    await page.route('**/*', route => route.abort());

    // 에러 표시 확인
    // await page.waitForLoadState('networkidle');
    // await expect(page.locator('.connection-error')).toBeVisible();
    
    // 네트워크 복구
    await page.unroute('**/*');
        
    // 메시지 전송 시도
    await helpers.sendMessage(page, 'This message should be queued');
      });

  test('중복 로그인 처리', async ({ browser }) => {
    const creds = helpers.generateUserCredentials(1);
    
    // 첫 번째 세션
    const session1 = await browser.newPage();
    await helpers.registerUser(session1, creds);
    
    // 두 번째 세션으로 로그인
    const session2 = await browser.newPage();
    await helpers.login(session2, creds);
    
    // 첫 번째 세션에서 중복 로그인 알림 확인
    await session1.waitForLoadState('networkidle');
    await expect(session1.locator('.duplicate-login-modal')).toBeVisible({
      timeout: 30000 // 타임아웃을 30초로 증가
    });

    // 다이얼로그의 내용도 확인
    await session1.waitForLoadState('networkidle');
    const modalText = await session1.locator('.duplicate-login-modal').textContent();
    expect(modalText).toContain('지금 로그아웃'); // 실제 메시지에 맞게 수정 필요
  });
});


<e2e/test/files/image-upload.spec.ts>
import { test, expect } from '@playwright/test';
import { TestHelpers } from '../helpers/test-helpers';
import path from 'path';

test.describe('이미지 업로드 테스트', () => {
  const helpers = new TestHelpers();

  test('이미지 업로드 및 공유', async ({ browser }) => {
    const roomPrefix = 'Image-Test';
    
    // 업로더와 뷰어 설정
    const uploader = await browser.newPage();
    const viewer = await browser.newPage();
    
    // 업로더 등록 및 방 생성
    const uploaderCreds = helpers.generateUserCredentials(1);
    await helpers.registerUser(uploader, uploaderCreds);
    
    // 방 생성 및 생성된 정확한 방 이름 저장
    const createdRoomName = await helpers.joinOrCreateRoom(uploader, roomPrefix);
    console.log(`Created room name: ${createdRoomName}`);

    // 생성된 방의 URL 파라미터 확인
    const uploaderUrl = uploader.url();
    const uploaderRoomParam = new URLSearchParams(new URL(uploaderUrl).search).get('room');
    
    if (!uploaderRoomParam) {
      throw new Error('Failed to get room name from uploader URL');
    }

    // 뷰어 등록 및 같은 방으로 입장
    const viewerCreds = helpers.generateUserCredentials(2);
    await helpers.registerUser(viewer, viewerCreds);
    await helpers.joinRoomByURLParam(viewer, uploaderRoomParam);

    // 양쪽 모두 동일한 채팅방에 있는지 확인
    for (const page of [uploader, viewer]) {
      const userHostUrl = page.url();
    	const userRoomParam = new URLSearchParams(new URL(userHostUrl).search).get('room');
      expect(userRoomParam).toBe(uploaderRoomParam);
    }

    // 이미지 업로드
    const imagePath = path.join(__dirname, '../fixtures/images/mufc_logo.png');

    // 채팅 UI가 완전히 로드될 때까지 대기
    await uploader.waitForSelector('.chat-input-wrapper', {
      state: 'visible',
      timeout: 30000
    });
    
    // 파일 입력 필드 대기 및 파일 설정
    const fileInput = await uploader.waitForSelector('input[type="file"]', {
      state: 'attached',
      timeout: 30000
    });
    await fileInput.setInputFiles(imagePath);

    // 파일 프리뷰 표시 및 안정화 대기
    await uploader.waitForSelector('.file-preview-item img', {
      state: 'visible',
      timeout: 30000
    });
    await uploader.waitForTimeout(1000); // 프리뷰 안정화를 위한 잠시 대기

    // 전송 버튼 찾기 및 클릭
    const submitButton = await uploader.waitForSelector(
      'button[type="submit"], .chat-input-actions button[title*="보내기"], .chat-input-actions button.send-button', 
      {
        state: 'visible',
        timeout: 30000
      }
    );
    
    // 버튼이 클릭 가능한 상태가 될 때까지 대기
    await submitButton.waitForElementState('stable');
    await submitButton.click();

    // 업로드 진행 상태 표시 사라질 때까지 대기 (있는 경우)
    await uploader.waitForSelector('.upload-progress', {
      state: 'detached',
      timeout: 30000
    }).catch(() => {}); // 진행 상태 표시가 없을 수 있으므로 에러 무시

    // 이미지 메시지가 나타날 때까지 대기
    const messageSelector = '.message-content:has(img)';
    await Promise.all([
      uploader.waitForSelector(messageSelector, { timeout: 30000 }),
      viewer.waitForSelector(messageSelector, { timeout: 30000 })
    ]);

    // 이미지 로드 완료 확인 및 검증
    for (const page of [uploader, viewer]) {
      // 이미지 요소 찾기
      const imgElement = await page.locator('.message-content img').first();
      
      // 이미지가 실제로 로드될 때까지 대기
      await expect(imgElement).toBeVisible({ timeout: 30000 });
      
      // 이미지 속성 확인
      const imgSrc = await imgElement.getAttribute('src');
      expect(imgSrc).toBeTruthy();
      
      // 이미지 크기 확인
      const dimensions = await imgElement.evaluate((img) => {
        return {
          naturalWidth: (img as HTMLImageElement).naturalWidth,
          naturalHeight: (img as HTMLImageElement).naturalHeight
        };
      });
      expect(dimensions.naturalWidth).toBeGreaterThan(0);
      expect(dimensions.naturalHeight).toBeGreaterThan(0);
      
      // 이미지 로드 상태 확인
      await imgElement.evaluate(img => {
        return new Promise((resolve, reject) => {
          if (img instanceof HTMLImageElement) {
            if (img.complete) {
              if (img.naturalWidth === 0) {
                reject(new Error('Image failed to load'));
              }
              resolve(true);
            } else {
              img.onload = () => resolve(true);
              img.onerror = () => reject(new Error('Image failed to load'));
            }
          }
        });
      });
    }

    // // AI에게 이미지 분석 요청
    // await helpers.sendAIMessage(uploader, '방금 공유된 이미지는 어떤 이미지인가요?');
    
    // // AI 응답 대기 및 검증
    // const aiResponse = await uploader.waitForSelector('.message-ai', {
    //   timeout: 30000
    // });
    // const responseText = await aiResponse.textContent();
    // expect(responseText?.toLowerCase()).toMatch(/manchester|united|logo|football/i);

    // 테스트 종료 전 채팅방 확인
    // for (const page of [uploader, viewer]) {
    //   const finalRoomName = await page.locator('.chat-room-title').textContent();
    //   expect(finalRoomName).toBe(uploaderRoomParam);
    // }
    
    // 리소스 정리
    await Promise.all([uploader.close(), viewer.close()]);
  });
});

<e2e/test/files/pdf-upload.spec.ts>
import { test, expect } from '@playwright/test';
import { TestHelpers } from '../helpers/test-helpers';
import path from 'path';

test.describe('PDF 업로드 테스트', () => {
  const helpers = new TestHelpers();

  test('PDF 문서 업로드 및 공유', async ({ browser }) => {
    const roomPrefix = 'PDF-Test';
    
    // 업로더와 뷰어 설정
    const uploader = await browser.newPage();
    const viewer = await browser.newPage();
    
    // 업로더 등록 및 방 생성
    const uploaderCreds = helpers.generateUserCredentials(1);
    await helpers.registerUser(uploader, uploaderCreds);
    
    // 방 생성 및 생성된 정확한 방 이름 저장
    const createdRoomName = await helpers.joinOrCreateRoom(uploader, roomPrefix);
    console.log(`Created room name: ${createdRoomName}`);

    // 생성된 방의 URL 파라미터 확인
    const uploaderUrl = uploader.url();
    const uploaderRoomParam = new URLSearchParams(new URL(uploaderUrl).search).get('room');
    
    if (!uploaderRoomParam) {
      throw new Error('Failed to get room name from uploader URL');
    }

    // 뷰어 등록 및 같은 방으로 입장
    const viewerCreds = helpers.generateUserCredentials(2);
    await helpers.registerUser(viewer, viewerCreds);
    await helpers.joinRoomByURLParam(viewer, uploaderRoomParam);

    // 양쪽 모두 동일한 채팅방에 있는지 확인
    for (const page of [uploader, viewer]) {
      const userHostUrl = page.url();
    	const userRoomParam = new URLSearchParams(new URL(userHostUrl).search).get('room');
      expect(userRoomParam).toBe(uploaderRoomParam);
    }

    // PDF 업로드
    const pdfPath = path.join(__dirname, '../fixtures/documents/pdf-test.pdf');
    
    // 채팅 UI가 완전히 로드될 때까지 대기
    await uploader.waitForSelector('.chat-input-wrapper', {
      state: 'visible',
      timeout: 30000
    });
    
    // 파일 입력 필드 찾기 및 파일 설정
    const fileInput = await uploader.waitForSelector('input[type="file"]', {
      state: 'attached',
      timeout: 30000
    });
    await fileInput.setInputFiles(pdfPath);
    
    // 파일 프리뷰 확인
    await uploader.waitForSelector('.file-preview-item .file-icon', {
      state: 'visible',
      timeout: 30000
    });
    
    // 프리뷰가 안정화될 때까지 잠시 대기
    await uploader.waitForTimeout(1000);

    // 전송 버튼 찾기
    const submitButton = await uploader.waitForSelector(
      'button[type="submit"], .chat-input-actions button[title*="보내기"], .chat-input-actions button.send-button', 
      {
        state: 'visible',
        timeout: 30000
      }
    );
    
    // 버튼이 클릭 가능한 상태가 될 때까지 대기
    await submitButton.waitForElementState('stable');
    
    // 파일 업로드 시작
    await submitButton.click();

    // // 업로드 진행 표시 사라질 때까지 대기 (있는 경우)
    // await uploader.waitForSelector('.upload-progress', {
    //   state: 'detached',
    //   timeout: 30000
    // }).catch(() => {}); // 진행 표시가 없을 수 있으므로 에러 무시

    // // 파일 메시지가 나타날 때까지 대기 (양쪽 모두)
    // const messageSelector = '.message-content:has(.file-message)';
    // await Promise.all([
    //   uploader.waitForSelector(messageSelector, { timeout: 30000 }),
    //   viewer.waitForSelector(messageSelector, { timeout: 30000 })
    // ]);

    // // 양쪽 모두에서 PDF 메시지 요소 확인
    // for (const page of [uploader, viewer]) {
    //   // PDF 메시지 컨테이너 찾기
    //   const fileMessage = page.locator('.message-content .file-message').last();
    //   await expect(fileMessage).toBeVisible({ timeout: 30000 });

    //   // PDF 아이콘 확인
    //   const fileIcon = fileMessage.locator('.file-icon');
    //   await expect(fileIcon).toBeVisible({ timeout: 30000 });

    //   // 파일명 확인
    //   const fileName = fileMessage.locator('.file-name');
    //   await expect(fileName).toBeVisible({ timeout: 30000 });
    //   await expect(fileName).toContainText('pdf-test.pdf', { timeout: 30000 });

    //   // 다운로드 버튼 확인
    //   const downloadButton = fileMessage.locator('button:has-text("다운로드")');
    //   await expect(downloadButton).toBeVisible({ timeout: 30000 });

    //   // 새 탭에서 보기 버튼 확인
    //   const viewButton = fileMessage.locator('button:has-text("새 탭에서 보기")');
    //   await expect(viewButton).toBeVisible({ timeout: 30000 });
    // }

    // // 다운로드 기능 테스트
    // const downloadPromise = viewer.waitForEvent('download');
    // await viewer.locator('.file-message button:has-text("다운로드")').last().click();
    // const download = await downloadPromise;
    // expect(download.suggestedFilename()).toBe('pdf-test.pdf');

    // // AI에게 PDF 파일 정보 요청
    // await helpers.sendAIMessage(uploader, '방금 공유된 PDF 파일의 정보를 알려주세요.');
    
    // // AI 응답 대기 및 검증
    // const aiResponse = await uploader.waitForSelector('.message-ai', {
    //   timeout: 30000
    // });
    // const responseText = await aiResponse.textContent();
    // expect(responseText?.toLowerCase()).toMatch(/pdf|document|file/i);

    // 테스트 종료 전 채팅방 확인
    // for (const page of [uploader, viewer]) {
    //   const finalRoomName = await page.locator('.chat-room-title').textContent();
    //   expect(finalRoomName).toBe(uploaderRoomParam);
    // }

    // 리소스 정리
    await Promise.all([uploader.close(), viewer.close()]);
  });
});

<e2e/test/files/video-upload.spec.ts>
import { test, expect } from '@playwright/test';
import { TestHelpers } from '../helpers/test-helpers';
import path from 'path';

test.describe('비디오 업로드 테스트', () => {
  const helpers = new TestHelpers();

  test('비디오 파일 업로드 및 재생', async ({ browser }) => {
    const roomPrefix = 'Video-Test';
    
    // 업로더와 뷰어 설정
    const uploader = await browser.newPage();
    const viewer = await browser.newPage();
    
    // 업로더 등록 및 방 생성
    const uploaderCreds = helpers.generateUserCredentials(1);
    await helpers.registerUser(uploader, uploaderCreds);
    
    // 방 생성 및 생성된 정확한 방 이름 저장
    const createdRoomName = await helpers.joinOrCreateRoom(uploader, roomPrefix);
    console.log(`Created room name: ${createdRoomName}`);

    // 생성된 방의 URL 파라미터 확인
    const uploaderUrl = uploader.url();
    const uploaderRoomParam = new URLSearchParams(new URL(uploaderUrl).search).get('room');
    
    if (!uploaderRoomParam) {
      throw new Error('Failed to get room name from uploader URL');
    }

    // 뷰어 등록 및 같은 방으로 입장
    const viewerCreds = helpers.generateUserCredentials(2);
    await helpers.registerUser(viewer, viewerCreds);
    await helpers.joinRoomByURLParam(viewer, uploaderRoomParam);

    // 양쪽 모두 동일한 채팅방에 있는지 확인
    for (const page of [uploader, viewer]) {
      const userHostUrl = page.url();
    	const userRoomParam = new URLSearchParams(new URL(userHostUrl).search).get('room');
      expect(userRoomParam).toBe(uploaderRoomParam);
    }

    // 비디오 업로드
    const videoPath = path.join(__dirname, '../fixtures/media/mp4-test.mp4');
    
    // 채팅 UI가 완전히 로드될 때까지 대기
    await uploader.waitForSelector('.chat-input-wrapper', {
      state: 'visible',
      timeout: 30000
    });
    
    // 파일 입력 필드 찾기 및 파일 설정
    const fileInput = await uploader.waitForSelector('input[type="file"]', {
      state: 'attached',
      timeout: 30000
    });
    await fileInput.setInputFiles(videoPath);
    
    // 비디오 프리뷰 확인
    await uploader.waitForSelector('.file-preview-item video', {
      state: 'visible',
      timeout: 30000
    });
    
    // 프리뷰 안정화를 위한 대기
    await uploader.waitForTimeout(1000);

    // 전송 버튼 찾기
    const submitButton = await uploader.waitForSelector(
      'button[type="submit"], .chat-input-actions button[title*="보내기"], .chat-input-actions button.send-button', 
      {
        state: 'visible',
        timeout: 30000
      }
    );
    
    // 버튼이 클릭 가능한 상태가 될 때까지 대기
    await submitButton.waitForElementState('stable');
    
    // 파일 업로드 시작
    await submitButton.click();

    // 업로드 진행 표시 사라질 때까지 대기 (있는 경우)
    await uploader.waitForSelector('.upload-progress', {
      state: 'detached',
      timeout: 30000
    }).catch(() => {}); // 진행 표시가 없을 수 있으므로 에러 무시

    // 비디오 메시지가 나타날 때까지 대기 (양쪽 모두)
    const messageSelector = '.message-content:has(video)';
    await Promise.all([
      uploader.waitForSelector(messageSelector, { timeout: 30000 }),
      viewer.waitForSelector(messageSelector, { timeout: 30000 })
    ]);

    // 양쪽 모두에서 비디오 플레이어 확인
    for (const page of [uploader, viewer]) {
      // 비디오 메시지 컨테이너 찾기
      const videoMessage = page.locator('.message-content').filter({ hasText: '.mp4' }).last();
      await expect(videoMessage).toBeVisible({ timeout: 30000 });

      // 비디오 플레이어 확인
      const videoPlayer = videoMessage.locator('video');
      await expect(videoPlayer).toBeVisible({ timeout: 30000 });
      await expect(videoPlayer).toHaveAttribute('controls', '', { timeout: 30000 });

      // // 비디오 메타데이터 로드 대기
      // await videoPlayer.evaluate(video => {
      //   return new Promise((resolve) => {
      //     if (video instanceof HTMLVideoElement) {
      //       if (video.readyState >= 1) {
      //         resolve(true);
      //       } else {
      //         video.onloadedmetadata = () => resolve(true);
      //         video.onerror = () => resolve(false);
      //       }
      //     }
      //   });
      // });

      // 비디오 컨트롤러가 초기화될 때까지 대기
      // await page.waitForTimeout(2000);

      // // 비디오 컨트롤러 요소들 확인
      // const controls = videoMessage.locator('.video-controls');
      // await expect(controls).toBeVisible({ timeout: 30000 });

      // const playButton = controls.locator('.play-button');
      // await expect(playButton).toBeVisible({ timeout: 30000 });

      // const timeDisplay = controls.locator('.time-display');
      // await expect(timeDisplay).toBeVisible({ timeout: 30000 });

      // // 비디오 정보 확인
      // const videoDuration = await videoPlayer.evaluate(video => {
      //   if (video instanceof HTMLVideoElement) {
      //     return video.duration;
      //   }
      //   return 0;
      // });
      // expect(videoDuration).toBeGreaterThan(0);
    }

    // 비디오 재생 테스트 (업로더 화면에서)
    // const uploaderVideo = uploader.locator('video').first();
    // const uploaderPlayButton = uploader.locator('.video-controls .play-button').first();

    // // 재생 버튼 클릭
    // await uploaderPlayButton.click();
    // await expect(uploaderVideo).toHaveAttribute('data-playing', 'true', { timeout: 30000 });
    
    // // 잠시 재생
    // await uploader.waitForTimeout(2000);

    // // 일시정지
    // await uploaderPlayButton.click();
    // await expect(uploaderVideo).toHaveAttribute('data-playing', 'false', { timeout: 30000 });

    // // AI에게 비디오 정보 요청
    // await helpers.sendAIMessage(uploader, '방금 공유된 비디오 파일의 정보를 알려주세요.');
    // const aiResponse = await uploader.waitForSelector('.message-ai', { timeout: 30000 });
    // const responseText = await aiResponse.textContent();
    // expect(responseText).toMatch(/mp4|video|media/i);

    // 테스트 종료 전 채팅방 확인
    // for (const page of [uploader, viewer]) {
    //   const finalRoomName = await page.locator('.chat-room-title').textContent();
    //   expect(finalRoomName).toBe(uploaderRoomParam);
    // }

    // 리소스 정리
    await Promise.all([uploader.close(), viewer.close()]);
  });
});

<e2e/test/helpers/test-helpers.ts>
import { Page } from '@playwright/test';
import { AIService } from '../services/ai-service';
import { MessageService } from '../services/message-service';
import { TEST_PROMPTS } from '../data/ai-prompts';
import { MESSAGE_PROMPTS } from '../data/message-prompts';
import { TEST_USERS, AI_TEST_USERS, UserCredential } from '../data/credentials';

interface UserCredentials {
  name: string;
  email: string;
  password: string;
}

interface LoginCredentials {
  email: string;
  password: string;
}

// 채팅방 찾기 및 입장을 위한 인터페이스 정의
interface RoomInfo {
  id: string;
  name: string;
  hasPassword: boolean;
}

export class TestHelpers {
  private aiService: AIService;
  private messageService: MessageService;
  private existingRooms: Set<string> = new Set();

  constructor() {
    const apiKey = process.env.OPENAI_API_KEY || '';
    this.aiService = new AIService({
      apiKey,
      model: process.env.OPENAI_MODEL || 'gpt-4-turbo-preview',
    });
    this.messageService = new MessageService(apiKey);
  }

  generateRoomName(prefix = 'Test') {
    const randomId = Math.random().toString(36).substring(2, 6);
    return `${prefix}-${randomId}`;
  }

  getTestUser(index: number): UserCredential {
    return TEST_USERS[index % TEST_USERS.length];
  }

  getAITestUser(type: 'gpt' | 'claude'): UserCredential {
    return type === 'gpt' ? AI_TEST_USERS[0] : AI_TEST_USERS[1];
  }

  generateUserCredentials(index: number) {
    const timestamp = Date.now();
    return {
      name: `Test User ${index}`,
      email: `testuser${index}_${timestamp}@example.com`,
      password: 'testPassword123!'
    };
  }

  async loginAndEnterRoom(page: Page) {
    const credentials = this.generateUserCredentials(1);
    await this.registerUser(page, credentials);
    const roomName = this.generateRoomName();
    await this.joinOrCreateRoom(page, roomName);
    return { credentials, roomName };
  }

  async registerUser(page: Page, credentials: UserCredentials) {
    try {
      await page.goto('/register');
      await page.waitForLoadState('networkidle');

      await Promise.all([
        page.waitForSelector('input[name="name"]'),
        page.waitForSelector('input[name="email"]'),
        page.waitForSelector('input[name="password"]'),
        page.waitForSelector('input[name="confirmPassword"]')
      ]);

      await page.fill('input[name="name"]', credentials.name);
      await page.fill('input[name="email"]', credentials.email);
      await page.fill('input[name="password"]', credentials.password);
      await page.fill('input[name="confirmPassword"]', credentials.password);

      await Promise.all([
        page.click('button[type="submit"]'),
        Promise.race([
          page.waitForURL('/chat-rooms', { timeout: 20000 }).catch(() => null),
          page.waitForSelector('.alert-danger', { timeout: 20000 }).catch(() => null)
        ])
      ]);

      const errorMessage = await page.locator('.alert-danger').isVisible();
      if (errorMessage) {
        console.log('회원가입 실패, 로그인 시도 중...');
        await this.login(page, {
          email: credentials.email,
          password: credentials.password
        });
      }

      await page.waitForURL('/chat-rooms', { timeout: 20000 });

    } catch (error) {
      console.error('Registration/Login process failed:', error);
      throw new Error(`회원가입/로그인 실패: ${error.message}`);
    }
  }

  async login(page: Page, credentials: LoginCredentials) {
    try {
      await page.goto('/');
      await page.waitForLoadState('networkidle');

      await Promise.all([
        page.waitForSelector('input[name="email"]'),
        page.waitForSelector('input[name="password"]')
      ]);

      await page.fill('input[name="email"]', credentials.email);
      await page.fill('input[name="password"]', credentials.password);

      await Promise.all([
        page.click('button[type="submit"]'),
        page.waitForURL('/chat-rooms', { timeout: 10000 })
      ]);

    } catch (error) {
      console.error('Login failed:', error);
      throw new Error(`로그인 실패: ${error.message}`);
    }
  }

  async logout(page: Page) {
    try {
      await page.waitForSelector('[data-toggle="dropdown"]', { 
        state: 'visible',
        timeout: 10000 
      });

      await page.click('[data-toggle="dropdown"]');

      await page.waitForSelector('.dropdown-menu', { 
        state: 'visible',
        timeout: 10000 
      });

      await page.waitForTimeout(1000);

      await page.click('text=로그아웃');

      await page.waitForURL('/', { waitUntil: 'networkidle' });

    } catch (error) {
      console.error('Logout failed:', error);
      await page.screenshot({ 
        path: `test-results/logout-error-${Date.now()}.png` 
      });
      throw error;
    }
  }

  async findSimilarRoom(page: Page, prefix: string): Promise<string | null> {
    try {
      await page.goto('/chat-rooms');
      await page.waitForLoadState('networkidle');

      let previousHeight = 0;
      let maxScrollAttempts = 3;
      let scrollAttempts = 0;
      let allFoundRooms: string[] = [];

      console.log("Finding rooms with prefix:", prefix);

      // 채팅방 테이블이 로드될 때까지 대기
      await page.waitForLoadState('networkidle');
      await page.waitForSelector('table tbody tr', {
        state: 'visible',
        timeout: 30000
      });

      while (scrollAttempts < maxScrollAttempts) {
        // 현재 화면에서 보이는 모든 채팅방 이름 가져오기
        const currentRooms = await page.$$eval(
          'span._3U8yo._32yag.font-medium', 
          (elements, searchPrefix) => {
            return elements
              .map(el => el.textContent || '')
              .filter(name => name.startsWith(searchPrefix));
          }, 
          prefix
        );

        // 새로 발견된 방들을 중복 제거하여 추가
        for (const roomName of currentRooms) {
          if (!allFoundRooms.includes(roomName)) {
            console.log(`Found room: ${roomName}`);
            allFoundRooms.push(roomName);
          }
        }

        // 현재 스크롤 높이 확인
        const currentHeight = await page.evaluate(() => {
          const container = document.querySelector('.chat-rooms-table');
          return container?.scrollHeight || 0;
        });

        // 더 이상 스크롤이 되지 않으면 종료
        if (currentHeight === previousHeight) {
          break;
        }

        // 스크롤 다운
        await page.evaluate(() => {
          const container = document.querySelector('.chat-rooms-table');
          if (container) {
            container.scrollTop = container.scrollHeight;
          }
        });

        // 새로운 컨텐츠 로딩 대기
        await page.waitForTimeout(1000);

        previousHeight = currentHeight;
        scrollAttempts++;

        console.log(`Scroll attempt ${scrollAttempts}/${maxScrollAttempts}: Found ${allFoundRooms.length} rooms`);
      }

      // 발견된 방들 중에서 랜덤하게 하나 선택
      if (allFoundRooms.length > 0) {
        const selectedRoom = allFoundRooms[Math.floor(Math.random() * allFoundRooms.length)];
        console.log(`Selected room: ${selectedRoom}`);
        return selectedRoom;
      }

      console.log("No rooms found with prefix:", prefix);
      return null;

    } catch (error) {
      console.error('Finding similar room failed:', error);
      await page.screenshot({ 
        path: `test-results/find-room-error-${Date.now()}.png`,
        fullPage: true 
      });
      return null;
    }
  }

  async joinOrCreateRoom(page: Page, prefix: string): Promise<string> {
    try {
      // 90% vs 10% 확률 결정
      const shouldJoinExisting = Math.random() < 0.9;

      // 기존 채팅방 찾기 시도
      const existingRoom = await this.findSimilarRoom(page, prefix);

      console.log('Found existing room:', existingRoom);
      console.log('Should join existing:', shouldJoinExisting);

      // 기존 채팅방이 있고 90% 확률에 해당하는 경우 기존 방 입장
      if (existingRoom && shouldJoinExisting) {
        const currentUrl = page.url();
        const urlRoomParam = new URLSearchParams(new URL(currentUrl).search).get('room');

        if (urlRoomParam === existingRoom) {
          console.log('Already in the selected room');
          return existingRoom;
        }

        // 채팅방 테이블이 로드될 때까지 대기
        await page.waitForSelector('table tbody tr', {
          state: 'visible',
          timeout: 30000
        });

        // tr 요소들을 순회하면서 해당 방 찾기
        const rows = await page.$$('tbody tr');

        for (const row of rows) {
          const roomNameElement = await row.$('span._3U8yo._32yag.font-medium');
          const roomName = await roomNameElement?.textContent();

          if (roomName === existingRoom) {
            // 같은 row에서 입장 버튼 찾기
            const enterButton = await row.$('button:has-text("입장")');
            if (enterButton) {
              console.log('Found enter button for room:', existingRoom);

              // 버튼 클릭 및 페이지 이동 대기
              await Promise.all([
                page.waitForURL('**/chat?room=**', { 
                  timeout: 30000,
                  waitUntil: 'networkidle'
                }),
                enterButton.click()
              ]);

              // 채팅방 UI 로드 대기
              await Promise.all([
                page.waitForSelector('.chat-input-textarea', {
                  state: 'visible',
                  timeout: 30000
                }),
                page.waitForSelector('.chat-room-title', {
                  state: 'visible',
                  timeout: 30000
                })
              ]);

              console.log('Successfully joined room:', existingRoom);
              return existingRoom;
            }
          }
        }

        console.log('Could not find enter button, creating new room instead');
      }

      // 새 채팅방 생성 (10% 확률이거나 기존 채팅방이 없는 경우)
      const newRoomName = this.generateRoomName(prefix);
      console.log('Creating new room:', newRoomName);

      await this.createRoom(page, newRoomName);
      this.existingRooms.add(newRoomName);
      return newRoomName;

    } catch (error) {
      console.error('Join or create room failed:', error);
      await this.takeErrorScreenshot(page, 'join-or-create-room');
      throw new Error(`채팅방 참여/생성 실패: ${error.message}`);
    }
  }

  async createRoom(page: Page, roomName: string, password?: string): Promise<void> {
    try {
      console.log('Creating new room:', roomName);

      // 새 채팅방 페이지로 이동
      await page.goto('/chat-rooms/new');
      await page.waitForLoadState('networkidle');

      // 폼이 완전히 로드될 때까지 대기
      const nameInput = await page.waitForSelector('input[name="name"]', {
        state: 'visible',
        timeout: 30000
      });

      // 이름 검증
      if (!roomName?.trim()) {
        throw new Error('방 이름이 비어있습니다.');
      }

      // 기본 정보 입력
      await nameInput.fill(roomName);
      console.log('Room name filled:', roomName);

      // 비밀번호 설정
      if (password) {
        const passwordSwitch = await page.waitForSelector('#hasPassword', { 
          state: 'visible',
          timeout: 5000 
        });
        await passwordSwitch.click();

        const passwordInput = await page.waitForSelector('input[name="password"]', { 
          state: 'visible',
          timeout: 5000 
        });
        await passwordInput.fill(password);
      }

      // 생성 버튼 찾기
      const createButton = await page.waitForSelector('button:has-text("채팅방 만들기")', {
        state: 'visible',
        timeout: 5000
      });

      // 버튼 활성화 대기
      await createButton.waitForElementState('enabled', { timeout: 5000 });

      // 방 생성 시도
      await Promise.all([
        // 네트워크 idle 상태 대기
        page.waitForLoadState('networkidle', { timeout: 30000 }),

        // URL 변경 대기 (여러 방식으로 시도)
        Promise.race([
          page.waitForURL('**/chat?room=*', { timeout: 30000 }),
          page.waitForURL(url => url.pathname === '/chat' && url.searchParams.has('room'), { timeout: 30000 })
        ]),

        // 버튼 클릭
        createButton.click()
      ]);

      // 채팅방 UI 로드 대기 (여러 요소 동시 대기)
      await Promise.all([
        page.waitForSelector('.chat-input-textarea', {
          state: 'visible',
          timeout: 30000
        }),
        page.waitForSelector('.chat-room-title', {
          state: 'visible',
          timeout: 30000
        }),
        page.waitForSelector('.message-list', {
          state: 'visible',
          timeout: 30000
        })
      ]).catch(async (error) => {
        console.error('UI elements load error:', error);

        // 현재 URL과 페이지 상태 확인
        const currentUrl = page.url();
        const elements = {
          input: await page.$('.chat-input-textarea').catch(() => null),
          title: await page.$('.chat-room-title').catch(() => null),
          messageList: await page.$('.message-list').catch(() => null)
        };

        console.log('Current page state:', {
          url: currentUrl,
          elements: Object.entries(elements).reduce((acc, [key, value]) => {
            acc[key] = !!value;
            return acc;
          }, {})
        });

        // URL이 올바르지만 UI 요소가 없는 경우 리로드 시도
        if (currentUrl.includes('/chat') && currentUrl.includes('room=')) {
          console.log('Attempting page reload...');
          await page.reload({ waitUntil: 'networkidle' });

          // 리로드 후 다시 UI 요소 대기
          await Promise.all([
            page.waitForSelector('.chat-input-textarea', { timeout: 30000 }),
            page.waitForSelector('.chat-room-title', { timeout: 30000 }),
            page.waitForSelector('.message-list', { timeout: 30000 })
          ]);
        } else {
          throw new Error('채팅방 UI 로드 실패');
        }
      });

      // // Socket.IO 연결 상태 확인
      // await page.waitForFunction(
      //   () => {
      //     const socket = (window as any).io;
      //     return socket && socket.connected;
      //   },
      //   { timeout: 30000 }
      // ).catch((error) => {
      //   console.warn('Socket connection check warning:', error);
      // });

      // 최종 URL 및 채팅방 상태 검증
      const finalUrl = page.url();
      if (!finalUrl.includes('/chat') || !finalUrl.includes('room=')) {
        throw new Error('최종 URL 검증 실패');
      }

      console.log('Room created and loaded successfully:', {
        roomName,
        url: finalUrl
      });

    } catch (error) {
      console.error('Room creation error:', error);

      // 스크린샷 촬영
      if (!page.isClosed()) {
        const timestamp = Date.now();
        await page.screenshot({
          path: `test-results/create-room-error-${timestamp}.png`,
          fullPage: true
        });

        // 페이지 상태 저장
        const pageState = {
          url: page.url(),
          content: await page.content().catch(() => null),
          console: await page.evaluate(() => {
            return (window as any).consoleLog || [];
          }).catch(() => [])
        };

        console.error('Failed page state:', pageState);
      }

      throw new Error(`채팅방 생성 실패: ${error.message}`);
    }
  }

  // 비밀번호 처리 개선
  private async handleRoomPassword(page: Page, password: string, timeout: number) {
    await page.waitForSelector('input[name="password"]', {
      state: 'visible',
      timeout
    });

    await Promise.all([
      page.waitForNavigation({ 
        timeout,
        waitUntil: ['load', 'domcontentloaded', 'networkidle']
      }),
      page.fill('input[name="password"]', password),
      page.click('button:has-text("입장")')
    ]);
  }

  // 연결 상태 확인 메서드
  private async waitForConnection(page: Page, timeout: number): Promise<boolean> {
    try {
      await page.waitForFunction(
        () => {
          const socket = (window as any).io;
          return socket && socket.connected;
        },
        { timeout }
      );
      return true;
    } catch {
      return false;
    }
  }

  // 채팅방 UI 검증
  private async verifyRoomLoaded(page: Page, timeout: number) {
    const elements = [
      '.chat-room-title',
      '.chat-messages',
      '.chat-input-textarea:not([disabled])'
    ];

    await Promise.all(
      elements.map(selector => 
        page.waitForSelector(selector, {
          state: 'visible',
          timeout
        })
      )
    );
  }
  
  async joinRoomByURLParam(page: Page, roomId: string, password?: string) {
    try {
      const currentUrl = page.url();
      const currentRoomId = new URLSearchParams(new URL(currentUrl).search).get('room');

      // 이미 같은 방에 있으면 스킵
      if (currentRoomId === roomId) {
        return;
      }

      // 로드 타임아웃 설정
      const LOAD_TIMEOUT = 60000;

      // 1. 페이지 로드
      await page.goto(`/chat?room=${encodeURIComponent(roomId)}`, {
        waitUntil: 'networkidle',
        timeout: LOAD_TIMEOUT
      });

      // 2. Socket 연결 대기
      await page.waitForFunction(
        () => {
          const socket = (window as any).io;
          return socket && socket.connected;
        },
        { timeout: LOAD_TIMEOUT }
      ).catch(() => {
        console.warn('Socket connection check timed out');
      });

      // 3. 비밀번호 처리
      const passwordInput = await page.locator('input[name="password"]');
      const needsPassword = await passwordInput.isVisible().catch(() => false);

      if (needsPassword) {
        if (!password) {
          throw new Error('비밀번호가 필요한 채팅방입니다.');
        }

        await passwordInput.fill(password);
        await page.click('button:has-text("입장")');

        // 비밀번호 입력 후 페이지 로드 대기
        await page.waitForLoadState('networkidle', { timeout: LOAD_TIMEOUT });
      }

      // 4. UI 로드 대기
      const requiredElements = [
        {
          selector: '.chat-room-title',
          description: '채팅방 제목'
        },
        {
          selector: '.chat-messages',
          description: '메시지 영역'
        },
        {
          selector: '.chat-input-textarea:not([disabled])',
          description: '채팅 입력창'
        }
      ];

      // 모든 필수 요소가 로드될 때까지 대기
      await Promise.all(
        requiredElements.map(async ({ selector, description }) => {
          try {
            await page.waitForSelector(selector, {
              state: 'visible',
              timeout: LOAD_TIMEOUT
            });
            console.log(`${description} 로드됨`);
          } catch (error) {
            throw new Error(`${description} 로드 실패: ${error.message}`);
          }
        })
      );

      // 5. 연결 상태 최종 확인
      // const isConnected = await page
      //   .waitForSelector('.status-indicator.connected', {
      //     state: 'visible',
      //     timeout: LOAD_TIMEOUT
      //   })
      //   .then(() => true)
      //   .catch(() => false);

      // if (!isConnected) {
      //   throw new Error('채팅 서버 연결 실패');
      // }

      // 6. 최종 URL 검증
      const finalUrl = page.url();
      const finalRoomId = new URLSearchParams(new URL(finalUrl).search).get('room');

      if (finalRoomId !== roomId) {
        throw new Error(`채팅방 입장 실패: 예상된 방 ID ${roomId}, 실제 방 ID ${finalRoomId}`);
      }

    } catch (error) {
      console.error('URL 파라미터로 채팅방 입장 실패:', {
        error,
        roomId,
        currentUrl: page.url(),
        pageState: await this.getPageState(page)
      });

      // 스크린샷 촬영 시도
      try {
        if (!page.isClosed()) {
          const timestamp = Date.now();
          await page.screenshot({
            path: `test-results/room-join-url-error-${timestamp}.png`,
            fullPage: true
          });
        }
      } catch (screenshotError) {
        console.error('스크린샷 촬영 실패:', screenshotError);
      }

      throw new Error(`채팅방 입장 실패 (URL 파라미터로 접근): ${error.message}`);
    }
  }

  // 페이지 상태 정보 수집을 위한 헬퍼 메서드
  private async getPageState(page: Page) {
    try {
      return await page.evaluate(() => ({
        url: window.location.href,
        readyState: document.readyState,
        socketConnected: !!(window as any).io?.connected,
        elements: {
          title: !!document.querySelector('.chat-room-title'),
          messages: !!document.querySelector('.chat-messages'),
          input: !!document.querySelector('.chat-input-textarea')
        }
      }));
    } catch (error) {
      return {
        error: 'Failed to get page state',
        message: error.message
      };
    }
  }
  
  async sendMessage(page: Page, message: string, parameters?: Record<string, string>) {
    try {
      const finalMessage = await this.messageService.generateMessage(message, parameters);
      const inputSelector = '.chat-input-textarea';
      
      // 입력 필드가 나타날 때까지 대기
      await page.waitForSelector(inputSelector, {
        state: 'visible',
        timeout: 30000
      });

      // 네트워크 요청이 완료될 때까지 대기
      await page.waitForLoadState('networkidle');

      // 입력 필드가 활성화될 때까지 대기
      await page.waitForSelector(`${inputSelector}:not([disabled])`, {
        timeout: 30000
      });

      // 메시지 입력
      await page.fill(inputSelector, finalMessage);
      
      // Enter 키 입력 전 잠시 대기
      await page.waitForTimeout(500);
      
      // 메시지 전송
      await page.keyboard.press('Enter');

      // 메시지 전송 확인
      // try {
      //   await page.waitForLoadState('networkidle');
      //   await page.waitForSelector('.message-content');

      //   const messages = await page.locator('.message-content').all();
      //   const lastMessage = messages[messages.length - 1];
        
      //   if (lastMessage) {
      //     const messageText = await lastMessage.textContent();
      //     if (!messageText?.includes(finalMessage.substring(0, 20))) {
      //       throw new Error('Message content verification failed');
      //     }
      //   } else {
      //     throw new Error('No messages found after sending');
      //   }
      // } catch (error) {
      //   console.error('Message verification failed:', error);
      //   throw new Error(`Message sending verification failed: ${error.message}`);
      // }

      return finalMessage;

    } catch (error) {
      console.error('Message send error:', error);
      await this.takeErrorScreenshot(page, 'message-send');
      throw error;
    }
  }

  async sendAIMessage(page: Page, message: string, aiType: AIType = 'wayneAI') {
    try {
      await page.waitForSelector('.chat-input-textarea', {
        state: 'visible',
        timeout: 20000
      });
      
      const mentionMessage = `@${aiType} ${message}`;
      await page.fill('.chat-input-textarea', mentionMessage);
      await page.keyboard.press('Enter');

      await page.waitForSelector('.message-ai', {
        timeout: 30000,
        state: 'visible'
      });

    } catch (error) {
      console.error('AI message interaction failed:', error);
      await this.takeErrorScreenshot(page, 'ai-message');
      throw new Error(`AI 메시지 전송 실패: ${error.message}`);
    }
  }

  async addReaction(page: Page, messageSelector: string, emojiIndex: number = 0) {
    try {
      await page.hover(messageSelector);
      await page.click('.action-button');
      await page.waitForSelector('.emoji-picker-container');
      await page.click(`.emoji-picker-container button >> nth=${emojiIndex}`);
      await page.waitForSelector('.reaction-badge');
    } catch (error) {
      console.error('Add reaction failed:', error);
      await this.takeErrorScreenshot(page, 'reaction');
      throw new Error(`리액션 추가 실패: ${error.message}`);
    }
  }

  async uploadFile(page: Page, filePath: string, fileType: string) {
    try {
      const fileInput = await page.waitForSelector('input[type="file"]', {
        timeout: 30000,
        state: 'visible'
      });
      
      await fileInput.setInputFiles(filePath);
      
      if (fileType === 'image') {
        await page.waitForSelector('.file-preview-item img', {
          timeout: 30000,
          state: 'visible'
        });
      } else if (fileType === 'pdf') {
        await page.waitForSelector('.file-preview-item .file-icon', {
          timeout: 30000,
          state: 'visible'
        });
      }

      const submitButton = await page.waitForSelector('.chat-input-actions button[type="submit"]', {
        timeout: 30000,
        state: 'visible'
      });
      await submitButton.click();
      
      await page.waitForSelector('.message-content .file-message', {
        timeout: 30000,
        state: 'visible'
      });

    } catch (error) {
      console.error('File upload failed:', error);
      await this.takeErrorScreenshot(page, 'file-upload');
      throw new Error(`파일 업로드 실패: ${error.message}`);
    }
  }

  async simulateConversation(pages: Page[], messages: string[], delayMin: number = 1000, delayMax: number = 3000) {
    for (const message of messages) {
      try {
        const randomPage = pages[Math.floor(Math.random() * pages.length)];
        await this.sendMessage(randomPage, message);
        
        const delay = Math.floor(Math.random() * (delayMax - delayMin + 1)) + delayMin;
        await randomPage.waitForTimeout(delay);
      } catch (error) {
        console.error('Conversation simulation failed:', error);
        throw new Error(`대화 시뮬레이션 실패: ${error.message}`);
      }
    }
  }

  async getConversationHistory(page: Page) {
    try {
      await page.waitForSelector('.message-content', {
        timeout: 30000,
        state: 'visible'
      });
      
      return await page.$$eval('.message-content', elements => 
        elements.map(el => ({
          text: el.textContent?.trim() || '',
          timestamp: el.closest('.message-group')?.querySelector('.message-time')?.textContent?.trim(),
          sender: el.closest('.message-group')?.querySelector('.message-sender')?.textContent?.trim() || 'Unknown'
        }))
      );
    } catch (error) {
      console.error('Getting conversation history failed:', error);
      await this.takeErrorScreenshot(page, 'conversation-history');
      throw new Error(`대화 내역 조회 실패: ${error.message}`);
    }
  }

  async waitForMessageDelivery(page: Page, messageContent: string, timeout: number = 30000) {
    try {
      await page.waitForFunction(
        (text) => {
          const messages = document.querySelectorAll('.message-content');
          return Array.from(messages).some(msg => msg.textContent?.includes(text));
        },
        messageContent,
        { timeout }
      );
    } catch (error) {
      console.error('Message delivery verification failed:', error);
      await this.takeErrorScreenshot(page, 'message-delivery');
      throw new Error(`메시지 전송 확인 실패: ${error.message}`);
    }
  }

  async verifyRoomState(page: Page) {
    try {
      const state = {
        title: await page.locator('.chat-room-title').textContent(),
        participantCount: await page.locator('.participants-count').textContent(),
        // isConnected: await page.locator('.connection-status .text-success').isVisible(),
        hasMessages: await page.locator('.message-content').count() > 0,
        inputEnabled: await page.locator('.chat-input-textarea').isEnabled()
      };

      return state;
    } catch (error) {
      console.error('Room state verification failed:', error);
      await this.takeErrorScreenshot(page, 'room-state');
      throw new Error(`채팅방 상태 확인 실패: ${error.message}`);
    }
  }

  // 비밀번호 처리를 위한 헬퍼 메서드
  private async handleRoomPassword(page: Page, password?: string) {
    if (password) {
      await page.waitForSelector('input[name="password"]', {
        state: 'visible',
        timeout: 30000
      });
      await page.fill('input[name="password"]', password);
      await page.click('button:has-text("입장")');
    }
  }

  // 채팅방 로드 대기를 위한 헬퍼 메서드
  private async waitForRoomLoad(page: Page) {
    // 채팅방 UI 로드 확인
    await page.waitForSelector('.chat-container', {
      state: 'visible',
      timeout: 30000
    });

    // 채팅 입력창 활성화 확인
    await page.waitForSelector('.chat-input-textarea:not([disabled])', {
      state: 'visible',
      timeout: 30000
    });
  }

  // 에러 스크린샷을 위한 헬퍼 메서드
  private async takeErrorScreenshot(page: Page, prefix: string) {
    try {
      await page.screenshot({ 
        path: `test-results/${prefix}-error-${Date.now()}.png`,
        fullPage: true 
      });
    } catch (screenshotError) {
      console.error('Screenshot failed:', screenshotError);
    }
  }
}

<e2e/test/load/load-testing.spec.ts>
// test/load/load-testing.spec.ts
import { test, expect } from '@playwright/test';
import { TestHelpers } from '../helpers/test-helpers';

test.describe('부하 테스트', () => {
  const helpers = new TestHelpers();

  test('대량 메시지 처리', async ({ browser }) => {   
    const page = await browser.newPage();
    const creds = helpers.generateUserCredentials(1);
    await helpers.registerUser(page, creds);
    await helpers.joinOrCreateRoom(page, 'Load-Test');

    // 100개의 메시지 빠르게 전송
    const messages = Array.from({ length: 100 }, (_, i) => `Load test message ${i + 1}`);
    
    for (const message of messages) {
      await helpers.sendMessage(page, message);
    }

    // 스크롤 및 메시지 로딩 확인
    await page.evaluate(() => window.scrollTo(0, 0));
    await page.waitForSelector('.message-content >> nth=0');
    
    // 첫 번째와 마지막 메시지 모두 존재하는지 확인
    // await expect(page.locator('.message-content')).toContainText('Load test message 1');
    // await expect(page.locator('.message-content')).toContainText('Load test message 100');
  });
});


<e2e/test/messaging/advanced-messaging.spec.ts>
// test/messaging/advanced-messaging.spec.ts
import { test, expect } from '@playwright/test';
import { TestHelpers } from '../helpers/test-helpers';
import { MessageService } from '../services/message-service';

test.describe('고급 메시징 테스트', () => {
  const helpers = new TestHelpers();
  let messageService: MessageService;

  test.beforeAll(async () => {
    messageService = new MessageService();
  });

  test('마크다운 메시지 렌더링', async ({ browser }) => {
    const page = await browser.newPage();
    const creds = helpers.generateUserCredentials(1);
    await helpers.registerUser(page, creds);
    const roomName = await helpers.joinOrCreateRoom(page, 'Markdown');

    // AI를 통해 마크다운 형식의 메시지 생성
    const markdownPrompt = `
다음 요소들을 포함하는 마크다운 형식의 기술 문서를 작성해주세요:
- "웹 개발 기초"라는 제목 (h1)
- 2-3개의 중요 포인트 (bullet points)
- JavaScript 코드 예제 (코드 블록)
- 굵은 글씨와 기울임꼴을 사용한 강조 표현
최대한 간단하게 작성해주세요.`;

    const markdownMessage = await messageService.generateMessage(markdownPrompt);
    await helpers.sendMessage(page, markdownMessage);

    // 마크다운 렌더링 확인
    // await expect(page.locator('h1')).toBeVisible();
    // await expect(page.locator('ul > li')).toHaveCount(2);
    // await expect(page.locator('pre code')).toBeVisible();
    // await expect(page.locator('strong')).toBeVisible();
    // await expect(page.locator('em')).toBeVisible();

    // 실제 내용 확인
    // const title = await page.locator('h1').textContent();
    // expect(title).toBe('웹 개발 기초');

    // 코드 블록 내용 확인
    // const codeBlock = await page.locator('pre code').textContent();
    // expect(codeBlock).toContain('function') || expect(codeBlock).toContain('const');
  });

  test('다양한 마크다운 요소 테스트', async ({ browser }) => {
    const page = await browser.newPage();
    const creds = helpers.generateUserCredentials(2);
    await helpers.registerUser(page, creds);
    const roomName = await helpers.joinOrCreateRoom(page, 'Markdown');

    // 다양한 마크다운 요소를 포함한 메시지 생성
    const complexMarkdownPrompt = `
다음 요소들을 모두 포함하는 마크다운 형식의 회의 요약문을 작성해주세요:
- "팀 회의 요약" (h1 제목)
- "주요 안건" (h2 부제목)
- 3개의 체크리스트 항목
- 1개의 코드 블록 (예: 배포 명령어)
- 1개의 인용구
- 굵은 글씨와 기울임꼴이 혼합된 강조구문
최대한 실제 회의 내용처럼 자연스럽게 작성해주세요.`;

    const complexMarkdown = await messageService.generateMessage(complexMarkdownPrompt);
    await helpers.sendMessage(page, complexMarkdown);

    // 각 마크다운 요소 렌더링 확인
    // await expect(page.locator('h1')).toBeVisible();
    // await expect(page.locator('h2')).toBeVisible();
    // await expect(page.locator('input[type="checkbox"]')).toBeVisible();
    // await expect(page.locator('pre code')).toBeVisible();
    // await expect(page.locator('blockquote')).toBeVisible();
    // await expect(page.locator('strong')).toBeVisible();
    // await expect(page.locator('em')).toBeVisible();

    // 구조 검증
    // const headlines = await page.locator('h1, h2').count();
    // expect(headlines).toBeGreaterThanOrEqual(2);
    
    // const checklistItems = await page.locator('input[type="checkbox"]').count();
    // expect(checklistItems).toBeGreaterThanOrEqual(3);
  });
});

<e2e/test/messaging/messaging.spec.ts>
import { test, expect } from '@playwright/test';
import { TestHelpers } from '../helpers/test-helpers';

test.describe('메시징 테스트', () => {
  const helpers = new TestHelpers();

  test('그룹 채팅 시나리오', async ({ browser }) => {
    const roomPrefix = 'Chat';
    
    // 첫 번째 사용자 설정
    const user1 = await browser.newPage();
    const user1Creds = helpers.getTestUser(Math.floor(Math.random() * 1001));
    await helpers.registerUser(user1, user1Creds);
    
    // 방 생성 및 정확한 방 이름 저장
    const createdRoomName = await helpers.joinOrCreateRoom(user1, roomPrefix);
    console.log(`Created room name: ${createdRoomName}`);

    // 생성된 방의 URL 파라미터 확인
    const hostUrl = user1.url();
    const roomParam = new URLSearchParams(new URL(hostUrl).search).get('room');
    
    if (!roomParam) {
      throw new Error('Failed to get room name from URL');
    }
    
    // 첫 번째 사용자 인사 (프롬프트 키 사용)
    const greeting1 = await helpers.sendMessage(user1, 'GREETING', {
      USER_NAME: user1Creds.name,
      ROOM_NAME: roomParam
    });
    
    // 두 번째 사용자 설정 및 같은 방으로 입장
    const user2 = await browser.newPage();
    const user2Creds = helpers.getTestUser(1);
    await helpers.registerUser(user2, user2Creds);
    await helpers.joinRoomByURLParam(user2, roomParam);

    // 양쪽 모두 동일한 채팅방에 있는지 확인
    for (const user of [user1, user2]) {
      const userHostUrl = user.url();
    	const userRoomParam = new URLSearchParams(new URL(userHostUrl).search).get('room');
      expect(userRoomParam).toBe(roomParam);
    }
    
    // 두 번째 사용자 인사 (프롬프트 키 사용)
    const greeting2 = await helpers.sendMessage(user2, 'GREETING', {
      USER_NAME: user2Creds.name,
      ROOM_NAME: roomParam
    });
    
    // 대화 주제에 대한 의견 교환 (프롬프트 키 사용)
    const topic = '주말 계획';
    const message1 = await helpers.sendMessage(user1, 'GROUP_CHAT', {
      CURRENT_TOPIC: topic,
      USER_NAME: user1Creds.name
    });
    
    // 이전 메시지에 대한 응답 (프롬프트 키 사용)
    const message2 = await helpers.sendMessage(user2, 'CHAT_RESPONSE', {
      PREV_MESSAGE: message1,
      USER_NAME: user2Creds.name
    });

    // AI 의견 요청 (직접 메시지 사용)
    await helpers.sendAIMessage(user1, '우리의 대화를 요약해주세요.');

    // 메시지 표시 확인
    // await expect(user1.locator('.message-content')).toContainText(greeting2);
    // await expect(user2.locator('.message-content')).toContainText(message1);
    // await expect(user1.locator('.message-ai')).toBeVisible();

    // // 테스트 종료 전 채팅방 확인
    // for (const user of [user1, user2]) {
    //   const finalRoomName = await user.locator('.chat-room-title').textContent();
    //   expect(finalRoomName).toBe(roomParam);
    // }

    // 리소스 정리
    await Promise.all([user1.close(), user2.close()]);
  });
});

<e2e/test/profile/profile.spec.ts>
// test/profile/profile.spec.ts
import { test, expect } from '@playwright/test';
import { TestHelpers } from '../helpers/test-helpers';

test.describe('프로필 테스트', () => {
  const helpers = new TestHelpers();

  test('프로필 수정', async ({ page }) => {
    const credentials = helpers.generateUserCredentials(1);
    await helpers.registerUser(page, credentials);
    
    // 프로필 페이지로 이동
    await page.goto('/profile');
    
    // 이름 변경
    const newName = `Updated ${credentials.name}`;
    await page.fill('input[id="name"]', newName);
    await page.click('button:has-text("저장")');
    
    // 변경 확인
    await page.waitForLoadState('networkidle');
    await expect(page.locator('.alert')).toBeVisible();
    await page.reload();
    await expect(page.locator('input[id="name"]')).toHaveValue(newName);
  });
});

<e2e/test/realtime/presence.spec.ts>
// test/realtime/presence.spec.ts
import { test, expect } from '@playwright/test';
import { TestHelpers } from '../helpers/test-helpers';

test.describe('실시간 상태 테스트', () => {
  const helpers = new TestHelpers();

  test('사용자 상태 및 타이핑 표시', async ({ browser }) => {   
    // 첫 번째 사용자
    const user1 = await browser.newPage();
    const user1Creds = helpers.generateUserCredentials(Math.floor(Math.random() * 1001));
    await helpers.registerUser(user1, user1Creds);
    const roomName = await helpers.joinOrCreateRoom(user1, 'Presence');
    const user1Url = user1.url();
    const user1RoomParam = new URLSearchParams(new URL(user1Url).search).get('room');

    
    // 두 번째 사용자
    const user2 = await browser.newPage();
    const user2Creds = helpers.generateUserCredentials(Math.floor(Math.random() * 1001));
    await helpers.registerUser(user2, user2Creds);
    await helpers.joinRoomByURLParam(user2, user1RoomParam);

    // 타이핑 표시 확인
    // await user1.fill('.chat-input-textarea', 'typing...');
    // await expect(user2.locator('.typing-indicator')).toBeVisible();

    // 탭 전환 시 상태 변경 확인
    // await user1.evaluate(() => document.hidden = true);
    // await expect(user2.locator(`[data-user-id="${user1Creds.email}"] .status-away`)).toBeVisible();
  });
});


<e2e/test/realtime/realtime.spec.ts>
// test/realtime/realtime.spec.ts
import { test, expect } from '@playwright/test';
import { TestHelpers } from '../helpers/test-helpers';

test.describe('실시간 기능 테스트', () => {
  const helpers = new TestHelpers();

  test('실시간 참여자 상태 업데이트', async ({ browser }) => {    
    // 방장
    const host = await browser.newPage();
    const hostCreds = helpers.generateUserCredentials(Math.floor(Math.random() * 1001));
    await helpers.registerUser(host, hostCreds);
    const roomName = await helpers.joinOrCreateRoom(host, 'Realtime');
    const hostUrl = host.url();
    const hostRoomParam = new URLSearchParams(new URL(hostUrl).search).get('room');
    
    // 참여자들 - 순차적으로 생성하고 참여
    const participants = [];
    for (let i = 0; i < 3; i++) {
      try {
        const page = await browser.newPage();
        const creds = helpers.generateUserCredentials(Math.floor(Math.random() * 1001));
        await helpers.registerUser(page, creds);
        await helpers.joinRoomByURLParam(page, hostRoomParam);
        participants.push(page);
      } catch (error) {
        console.error(`Failed to create participant ${i + 1}:`, error);
      }
    }
    
    // 참여자 목록 확인
    // await expect(host.locator('.participants-count')).toContainText('4');
    
    // try {
    //   // 한 명이 나가기
    //   if (participants[0]) {
    //     await participants[0].close();
    //   }
      
    //   // 참여자 수 업데이트 확인
    //   // await expect(host.locator('.participants-count')).toContainText('3');
    // } finally {
    //   // 리소스 정리
    //   await Promise.all([
    //     ...participants.slice(1).map(p => p?.close().catch(console.error)),
    //     host.close().catch(console.error)
    //   ]);
    // }
  });
});

<e2e/test/services/ai-service.ts>
// test/services/ai-service.ts

import OpenAI from 'openai';
import { TEST_PROMPTS, AI_RESPONSE_TEMPLATES } from '../data/ai-prompts';
import axios from 'axios';

interface AIConfig {
  apiKey: string;
  model: string;
  baseURL?: string;
}

interface AIResponse {
  success: boolean;
  content: string;
  error?: string;
}

export class AIService {
  private openai: OpenAI;
  private claudeApi: any; // Anthropic API 클라이언트
  private config: AIConfig;

  constructor(config: AIConfig) {
    this.config = config;
    this.openai = new OpenAI({
      apiKey: config.apiKey,
      baseURL: config.baseURL
    });
  }

  async generateResponse(
    promptKey: string,
    parameters: Record<string, string>,
    aiType: 'wayneAI' | 'consultingAI'
  ): Promise<AIResponse> {
    try {
      const promptTemplate = TEST_PROMPTS[promptKey];
      if (!promptTemplate) {
        throw new Error('Invalid prompt key');
      }

      let prompt = promptTemplate.prompt;
      for (const [key, value] of Object.entries(parameters)) {
        prompt = prompt.replace(`[${key}]`, value);
      }

      if (aiType === 'wayneAI') {
        return await this.callGPT(prompt);
      } else {
        return await this.callClaude(prompt);
      }

    } catch (error) {
      console.error('AI response generation error:', error);
      return {
        success: false,
        content: AI_RESPONSE_TEMPLATES.ERROR.API_ERROR,
        error: error.message
      };
    }
  }

  private async callGPT(prompt: string): Promise<AIResponse> {
    try {
      const completion = await this.openai.chat.completions.create({
        model: this.config.model,
        messages: [
          { role: "system", content: "당신은 WayneAI라는 AI어시스턴트입니다. 항상 한국어로 만들어주세요. \", '는 사용하지 말아주세요." },
          { role: "user", content: prompt }
        ]
      });

      return {
        success: true,
        content: completion.choices[0]?.message?.content || AI_RESPONSE_TEMPLATES.FALLBACK.DEFAULT
      };
    } catch (error) {
      throw new Error(`GPT API Error: ${error.message}`);
    }
  }

  private async callClaude(prompt: string): Promise<AIResponse> {
    try {
      const response = await axios.post(
        'https://api.anthropic.com/v1/messages',
        {
          model: process.env.CLAUDE_MODEL || 'claude-3-opus-20240229',
          max_tokens: 1024,
          messages: [{ role: 'user', content: prompt }]
        },
        {
          headers: {
            'x-api-key': this.config.apiKey,
            'anthropic-version': '2023-06-01'
          }
        }
      );

      return {
        success: true,
        content: response.data.content[0].text
      };
    } catch (error) {
      throw new Error(`Claude API Error: ${error.message}`);
    }
  }
}

<e2e/test/services/message-service.ts>
// test/services/message-service.ts
import OpenAI from 'openai';
import { MESSAGE_PROMPTS } from '../data/message-prompts';
import * as dotenv from 'dotenv';

dotenv.config();

export class MessageService {
  private openai: OpenAI;

  constructor() {
    this.openai = new OpenAI({ 
      apiKey: process.env.OPENAI_API_KEY 
    });
  }

  async generateMessage(
    promptKeyOrMessage: string,
    parameters?: Record<string, string>
  ): Promise<string> {
    try {
      let finalPrompt: string;

      // promptKey가 MESSAGE_PROMPTS에 있는지 확인
      if (MESSAGE_PROMPTS[promptKeyOrMessage]) {
        // 기존 프롬프트 템플릿 사용
        const promptTemplate = MESSAGE_PROMPTS[promptKeyOrMessage];
        finalPrompt = promptTemplate.prompt;
        
        // 파라미터 치환
        if (parameters) {
          for (const [key, value] of Object.entries(parameters)) {
            finalPrompt = finalPrompt.replace(`[${key}]`, value);
          }
        }
      } else {
        // 직접 메시지 사용
        finalPrompt = promptKeyOrMessage;
        
        // 파라미터가 있다면 치환
        if (parameters) {
          for (const [key, value] of Object.entries(parameters)) {
            finalPrompt = finalPrompt.replace(`[${key}]`, value);
          }
        }
      }

      // OpenAI API 호출
      try {
        const completion = await this.openai.chat.completions.create({
          model: process.env.MESSAGE_MODEL || 'gpt-4-turbo-preview',
          messages: [
            { 
              role: 'system', 
              content: '당신은 채팅 테스트를 위한 메시지를 생성하는 도우미입니다. 자연스럽고 실제 사용자가 작성할 법한 메시지를 생성해주세요. 항상 한국어로 만들어주세요. ", \'는 사용하지 말아주세요.' 
            },
            { role: 'user', content: finalPrompt }
          ],
          temperature: 0.7
        });

        return completion.choices[0]?.message?.content?.trim() || finalPrompt;
      } catch (error) {
        console.warn('OpenAI API 호출 실패, 원본 메시지 반환:', error);
        return finalPrompt;
      }
    } catch (error) {
      console.error('Message generation error:', error);
      // 에러 발생 시 원본 메시지 반환
      return promptKeyOrMessage;
    }
  }

  // 직접 메시지를 보내는 경우를 위한 별도 메소드
  async sendDirectMessage(message: string): Promise<string> {
    return message;
  }
}

<frontend/components/DuplicateLoginModal.js>
import React, { useState, useEffect } from 'react';
import { Alert, Modal, ModalBody, ModalFooter, ModalHeader, Button, Text } from '@goorm-dev/vapor-components';
import { AlertTriangle, Timer, ExternalLink } from 'lucide-react';

const DuplicateLoginModal = ({ 
  isOpen, 
  onClose, 
  deviceInfo, 
  ipAddress,
  onTimeout 
}) => {
  const [timeLeft, setTimeLeft] = useState(10);

  useEffect(() => {
    if (!isOpen) return;

    // 10초 카운트다운
    const timer = setInterval(() => {
      setTimeLeft(prev => {
        if (prev <= 1) {
          clearInterval(timer);
          onTimeout();
          return 0;
        }
        return prev - 1;
      });
    }, 1000);

    return () => {
      clearInterval(timer);
      setTimeLeft(10);
    };
  }, [isOpen, onTimeout]);

  return (
    <Modal 
      isOpen={isOpen} 
      toggle={onClose}
      type="center"
      size="md"
      direction="vertical"
      className="duplicate-login-modal"
    >
      <ModalHeader toggle={onClose}>
        중복 로그인 감지됨
      </ModalHeader>
      
      <ModalBody className="space-y-4">
        <Alert color="danger">
          <Text>다른 기기에서 로그인이 감지되었습니다.</Text>
          <div className="mt-5">
            <div className="flex items-center gap-2">
              <Text typography="body2">접속 위치: {ipAddress}</Text>
            </div>
            <div className="flex items-center gap-2">
              <Text typography="body2">디바이스: {deviceInfo}</Text>
            </div>
          </div>
        </Alert>

        <Text className="text-center">
          {timeLeft}초 후에 자동으로 로그아웃됩니다.
        </Text>

        <div className="relative w-full h-1 bg-gray-200 rounded-full overflow-hidden">
          <div 
            className="absolute inset-0 bg-warning transition-all duration-1000 ease-linear"
            style={{ 
              width: `${(timeLeft / 10) * 100}%`,
            }}
          />
        </div>
      </ModalBody>

      <ModalFooter>
        <Button
          variant="primary"
          size="lg"
          onClick={onTimeout}
          className="w-full"
        >
          지금 로그아웃
        </Button>
      </ModalFooter>
    </Modal>
  );
};

export default DuplicateLoginModal;

<frontend/components/Navbar.js>
import React, { useState, useEffect } from 'react';
import { useRouter } from 'next/router';
import Image from 'next/image';
import { 
 Button, 
 Text,
 Dropdown, 
 DropdownToggle,
 DropdownMenu,
 DropdownItem
} from '@goorm-dev/vapor-components';
import PersistentAvatar from './common/PersistentAvatar';
import authService from '../services/authService';

const Navbar = () => {
 const [currentUser, setCurrentUser] = useState(null);
 const [dropdownOpen, setDropdownOpen] = useState(false);
 const router = useRouter();

 // 인증 상태 변경을 감지하는 효과
 useEffect(() => {
   const checkAuth = () => {
     const user = authService.getCurrentUser();
     setCurrentUser(user);
   };

   // 초기 인증 상태 확인
   checkAuth();

   // authStateChange 이벤트 리스너 등록
   const handleAuthChange = () => {
     checkAuth();
   };

   // userProfileUpdate 이벤트 리스너 등록
   const handleProfileUpdate = () => {
     checkAuth();
   };

   window.addEventListener('authStateChange', handleAuthChange);
   window.addEventListener('userProfileUpdate', handleProfileUpdate);

   // 정리 함수
   return () => {
     window.removeEventListener('authStateChange', handleAuthChange);
     window.removeEventListener('userProfileUpdate', handleProfileUpdate);
   };
 }, []);

 const handleNavigation = (path) => {
   setDropdownOpen(false);
   router.push(path);
 };

 const handleLogout = async () => {
   setDropdownOpen(false);
   await authService.logout();
   // 로그아웃 후 authStateChange 이벤트 발생
   window.dispatchEvent(new Event('authStateChange'));
 };

 const toggleDropdown = () => {
   setDropdownOpen(prev => !prev);
 };

 const isInChatRooms = router.pathname === '/chat-rooms';

 return (
   <nav className="global-nav">
     <div className="container-fluid px-4 sm:px-6 lg:px-8">
       <div className="nav-row">
         <div className="nav-logo">
           <div 
             onClick={() => handleNavigation(currentUser ? '/chat-rooms' : '/')}
             className="cursor-pointer"
             role="button"
             tabIndex={0}
             onKeyPress={(e) => {
               if (e.key === 'Enter') {
                 handleNavigation(currentUser ? '/chat-rooms' : '/');
               }
             }}
           >
             <Image
               src="/images/logo.png"
               alt="Chat App Logo"
               width={240}
               height={72}
               style={{ objectFit: 'contain' }}
               priority
             />
           </div>
         </div>

         <div className="nav-menu">
           {currentUser && (
             <div className="nav-buttons hidden md:flex space-x-4">
               <Button
                 variant={isInChatRooms ? "primary" : "text"}
                 onClick={() => handleNavigation('/chat-rooms')}
                 size="lg"
               >
                 채팅방 목록
               </Button>
               <Button
                 variant="secondary"
                 onClick={() => handleNavigation('/chat-rooms/new')}
                 size="lg"
               >
                 새 채팅방
               </Button>
             </div>
           )}
         </div>

         <div className="nav-user">
           {currentUser ? (
             <Dropdown
               isOpen={dropdownOpen}
               toggle={toggleDropdown}
               direction="down"
               size="lg"
             >
               <DropdownToggle caret className="flex items-center">
                 <PersistentAvatar
                   user={currentUser}
                   size="sm"
                   className="flex-shrink-0"
                   showInitials={true}
                 />
                 <Text className="ml-2">
                   {currentUser.name}
                 </Text>
               </DropdownToggle>
               <DropdownMenu>
                 <DropdownItem
                   onClick={() => handleNavigation('/profile')}
                 >
                   프로필
                 </DropdownItem>
                 <DropdownItem divider />
                 <DropdownItem
                   onClick={handleLogout}
                   className="text-danger"
                 >
                   로그아웃
                 </DropdownItem>
               </DropdownMenu>
             </Dropdown>
           ) : (
             <div className="nav-auth flex items-center space-x-4">
               <Button
                 variant="text"
                 onClick={() => handleNavigation('/login')}
                 size="lg"
               >
                 로그인
               </Button>
               <Button
                 variant="primary"
                 onClick={() => handleNavigation('/register')}
                 size="lg"
               >
                 회원가입
               </Button>
             </div>
           )}
         </div>
       </div>
     </div>
   </nav>
 );
};

export default Navbar;

<frontend/components/ProfileImageUpload.js>
import React, { useState, useRef, useEffect } from 'react';
import { Button } from '@goorm-dev/vapor-core';
import { Alert } from '@goorm-dev/vapor-components';
import { Camera, X } from 'lucide-react';
import authService from '../services/authService';
import PersistentAvatar from './common/PersistentAvatar';

const ProfileImageUpload = ({ currentImage, onImageChange }) => {
  const [previewUrl, setPreviewUrl] = useState(null);
  const [error, setError] = useState('');
  const [uploading, setUploading] = useState(false);
  const fileInputRef = useRef(null);

  // 프로필 이미지 URL 생성
  const getProfileImageUrl = (imagePath) => {
    if (!imagePath) return null;
    return imagePath.startsWith('http') ? 
      imagePath : 
      `${process.env.NEXT_PUBLIC_API_URL}${imagePath}`;
  };

  // 컴포넌트 마운트 시 이미지 설정
  useEffect(() => {
    const imageUrl = getProfileImageUrl(currentImage);
    setPreviewUrl(imageUrl);
  }, [currentImage]);

  const handleFileSelect = async (e) => {
    const file = e.target.files?.[0];
    if (!file) return;

    try {
      // 이미지 파일 검증
      if (!file.type.startsWith('image/')) {
        throw new Error('이미지 파일만 업로드할 수 있습니다.');
      }

      // 파일 크기 제한 (5MB)
      if (file.size > 5 * 1024 * 1024) {
        throw new Error('파일 크기는 5MB를 초과할 수 없습니다.');
      }

      setUploading(true);
      setError('');

      // 파일 미리보기 생성
      const objectUrl = URL.createObjectURL(file);
      setPreviewUrl(objectUrl);

      // 현재 사용자의 인증 정보 가져오기
      const user = authService.getCurrentUser();
      if (!user?.token) {
        throw new Error('인증 정보가 없습니다.');
      }

      // FormData 생성
      const formData = new FormData();
      formData.append('profileImage', file);

      // 파일 업로드 요청
      const response = await fetch(`${process.env.NEXT_PUBLIC_API_URL}/api/users/profile-image`, {
        method: 'POST',
        headers: {
          'x-auth-token': user.token,
          'x-session-id': user.sessionId
        },
        body: formData
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.message || '이미지 업로드에 실패했습니다.');
      }

      const data = await response.json();
      
      // 로컬 스토리지의 사용자 정보 업데이트
      const updatedUser = {
        ...user,
        profileImage: data.imageUrl
      };
      localStorage.setItem('user', JSON.stringify(updatedUser));

      // 부모 컴포넌트에 변경 알림
      onImageChange(data.imageUrl);

      // 전역 이벤트 발생
      window.dispatchEvent(new Event('userProfileUpdate'));

    } catch (error) {
      console.error('Image upload error:', error);
      setError(error.message);
      setPreviewUrl(getProfileImageUrl(currentImage));
      
      // 기존 objectUrl 정리
      if (previewUrl && previewUrl.startsWith('blob:')) {
        URL.revokeObjectURL(previewUrl);
      }
    } finally {
      setUploading(false);
      if (fileInputRef.current) {
        fileInputRef.current.value = '';
      }
    }
  };

  const handleRemoveImage = async () => {
    try {
      setUploading(true);
      setError('');

      const user = authService.getCurrentUser();
      if (!user?.token) {
        throw new Error('인증 정보가 없습니다.');
      }

      const response = await fetch(`${process.env.NEXT_PUBLIC_API_URL}/api/users/profile-image`, {
        method: 'DELETE',
        headers: {
          'x-auth-token': user.token,
          'x-session-id': user.sessionId
        }
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.message || '이미지 삭제에 실패했습니다.');
      }

      // 로컬 스토리지의 사용자 정보 업데이트
      const updatedUser = {
        ...user,
        profileImage: ''
      };
      localStorage.setItem('user', JSON.stringify(updatedUser));

      // 기존 objectUrl 정리
      if (previewUrl && previewUrl.startsWith('blob:')) {
        URL.revokeObjectURL(previewUrl);
      }

      setPreviewUrl(null);
      onImageChange('');

      // 전역 이벤트 발생
      window.dispatchEvent(new Event('userProfileUpdate'));

    } catch (error) {
      console.error('Image removal error:', error);
      setError(error.message);
    } finally {
      setUploading(false);
    }
  };

  // 컴포넌트 언마운트 시 cleanup
  useEffect(() => {
    return () => {
      if (previewUrl && previewUrl.startsWith('blob:')) {
        URL.revokeObjectURL(previewUrl);
      }
    };
  }, [previewUrl]);

  // 현재 사용자 정보
  const currentUser = authService.getCurrentUser();

  return (
    <div>
      <div>
        <PersistentAvatar
          user={currentUser}
          size="xl"
          className="w-24 h-24 mx-auto mb-6"
          showInitials={true}
        />
        
        <div className="mt-6">
          <Button
            size="md"
            color="secondary"
            className="rounded-full p-2 mt-3"
            onClick={() => fileInputRef.current?.click()}
            disabled={uploading}
          >
            <Camera className="w-4 h-4" />
          </Button>

          {previewUrl && (
            <Button
              size="md"
              color="danger"
              className="rounded-full p-2 mt-3 ml-2"
              onClick={handleRemoveImage}
              disabled={uploading}
            >
              <X className="w-4 h-4" />
            </Button>
          )}
        </div>
      </div>

      <input
        ref={fileInputRef}
        type="file"
        className="hidden"
        accept="image/*"
        onChange={handleFileSelect}
      />

      {error && (
        <div className="w-full max-w-sm mx-auto">
          <Alert variant="danger" className="mt-2">
            {error}
          </Alert>
        </div>
      )}

      {uploading && (
        <div className="text-sm text-gray-500 text-center mt-2">
          이미지 업로드 중...
        </div>
      )}
    </div>
  );
};

export default ProfileImageUpload;

<frontend/components/Toast.js>
import React from 'react';
import { ToastContainer, toast, Slide } from '@goorm-dev/vapor-components';
import 'react-toastify/dist/ReactToastify.min.css';
import { 
  AlertCircle, 
  CheckCircle2, 
  Info, 
  AlertTriangle,
  XCircle 
} from 'lucide-react';

// Toast 타입별 설정
const TOAST_TYPES = {
  success: {
    type: 'success',
    duration: 3000
  },
  error: {
    type: 'error',
    duration: 5000
  },
  warning: {
    type: 'warning',
    duration: 4000
  },
  info: {
    type: 'info',
    duration: 3000
  }
};

// Toast 클래스 정의
class Toast {
  static show(message, type = 'info', options = {}) {
    const config = TOAST_TYPES[type] || TOAST_TYPES.info;

    toast[config.type](
      <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
        <span>{message}</span>
      </div>,
      {
        position: toast.POSITION.TOP_RIGHT,
        autoClose: options.duration || config.duration,
        hideProgressBar: true,
        closeOnClick: true,
        pauseOnHover: true,
        draggable: true,
        ...options
      }
    );
  }

  static success(message, options = {}) {
    this.show(message, 'success', options);
  }

  static error(message, options = {}) {
    this.show(message, 'error', options);
  }

  static warning(message, options = {}) {
    this.show(message, 'warning', options);
  }

  static info(message, options = {}) {
    this.show(message, 'info', options);
  }
  
  static dismiss(toastId) {
    if (toastId) {
      toast.dismiss(toastId);
    } else {
      toast.dismiss(); // 모든 toast 닫기
    }
  }

  static isActive(toastId) {
    return toast.isActive(toastId);
  }
}

// Container 컴포넌트
const ToastContainer$ = () => {
  return (
    <ToastContainer
      position={toast.POSITION.TOP_RIGHT}
      autoClose={3000}
      hideProgressBar={true}
      newestOnTop={true}
      closeOnClick={true}
      rtl={false}
      pauseOnFocusLoss={true}
      draggable={true}
      pauseOnHover={true}
      theme="light"
      transition={Slide}
    />
  );
};

export { Toast };
export default ToastContainer$;

<frontend/components/chat/ChatInput.js>
import React, { useCallback, useEffect, useRef, useState, forwardRef } from 'react';
import { Button } from '@goorm-dev/vapor-components';
import { 
  Smile,
  Paperclip,
  Send
} from 'lucide-react';
import MarkdownToolbar from './MarkdownToolbar';
import EmojiPicker from './EmojiPicker';
import MentionDropdown from './MentionDropdown';
import FilePreview from './FilePreview';
import fileService from '../../services/fileService';

const ChatInput = forwardRef(({
  message = '',
  onMessageChange = () => {},
  onSubmit = () => {},
  onEmojiToggle = () => {},
  onFileSelect = () => {},
  fileInputRef,
  disabled = false,
  uploading: externalUploading = false,
  showEmojiPicker = false,
  showMentionList = false,
  mentionFilter = '',
  mentionIndex = 0,
  getFilteredParticipants = () => [],
  setMessage = () => {},
  setShowEmojiPicker = () => {},
  setShowMentionList = () => {},
  setMentionFilter = () => {},
  setMentionIndex = () => {},
  room = null // room prop 추가
}, ref) => {
  const emojiPickerRef = useRef(null);
  const emojiButtonRef = useRef(null);
  const dropZoneRef = useRef(null);
  const internalInputRef = useRef(null);
  const messageInputRef = ref || internalInputRef;
  const [files, setFiles] = useState([]);
  const [uploading, setUploading] = useState(false);
  const [uploadProgress, setUploadProgress] = useState(0);
  const [uploadError, setUploadError] = useState(null);
  const [isDragging, setIsDragging] = useState(false);

  const handleFileValidationAndPreview = useCallback(async (file) => {
    if (!file) return;

    try {
      await fileService.validateFile(file);
      
      const filePreview = {
        file,
        url: URL.createObjectURL(file),
        name: file.name,
        type: file.type,
        size: file.size
      };
      
      setFiles(prev => [...prev, filePreview]);
      setUploadError(null);
      onFileSelect?.(file);
      
    } catch (error) {
      console.error('File validation error:', error);
      setUploadError(error.message);
    } finally {
      if (fileInputRef?.current) {
        fileInputRef.current.value = '';
      }
    }
  }, [onFileSelect]);

  const handleFileRemove = useCallback((fileToRemove) => {
    setFiles(prev => prev.filter(file => file.name !== fileToRemove.name));
    URL.revokeObjectURL(fileToRemove.url);
    setUploadError(null);
    setUploadProgress(0);
  }, []);

  const handleFileDrop = useCallback(async (e) => {
    e.preventDefault();
    e.stopPropagation();
    setIsDragging(false);

    const droppedFiles = Array.from(e.dataTransfer.files);
    if (droppedFiles.length === 0) return;

    try {
      await handleFileValidationAndPreview(droppedFiles[0]);
    } catch (error) {
      console.error('File drop error:', error);
    }
  }, [handleFileValidationAndPreview]);

  const handleSubmit = useCallback(async (e) => {
    e?.preventDefault();

    if (files.length > 0) {
      try {
        const file = files[0];
        if (!file || !file.file) {
          throw new Error('파일이 선택되지 않았습니다.');
        }

        onSubmit({
          type: 'file',
          content: message.trim(),
          fileData: file
        });

        setMessage('');
        setFiles([]);

      } catch (error) {
        console.error('File submit error:', error);
        setUploadError(error.message);
      }
    } else if (message.trim()) {
      onSubmit({
        type: 'text',
        content: message.trim()
      });
      setMessage('');
    }
  }, [files, message, onSubmit, setMessage]);

  useEffect(() => {
    const handleClickOutside = (event) => {
      if (
        showEmojiPicker &&
        !emojiPickerRef.current?.contains(event.target) &&
        !emojiButtonRef.current?.contains(event.target)
      ) {
        setShowEmojiPicker(false);
      }
    };

    const handlePaste = async (event) => {
      if (!messageInputRef?.current?.contains(event.target)) return;

      const items = event.clipboardData?.items;
      if (!items) return;

      const fileItem = Array.from(items).find(
        item => item.kind === 'file' && 
        (item.type.startsWith('image/') || 
         item.type.startsWith('video/') || 
         item.type.startsWith('audio/') ||
         item.type === 'application/pdf')
      );

      if (!fileItem) return;

      const file = fileItem.getAsFile();
      if (!file) return;

      try {
        await handleFileValidationAndPreview(file);
        event.preventDefault();
      } catch (error) {
        console.error('File paste error:', error);
      }
    };

    document.addEventListener('mousedown', handleClickOutside);
    document.addEventListener('paste', handlePaste);

    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
      document.removeEventListener('paste', handlePaste);
      files.forEach(file => URL.revokeObjectURL(file.url));
    };
  }, [showEmojiPicker, setShowEmojiPicker, files, messageInputRef, handleFileValidationAndPreview]);

  const handleInputChange = useCallback((e) => {
    const value = e.target.value;
    const cursorPosition = e.target.selectionStart;
    const textBeforeCursor = value.slice(0, cursorPosition);
    const lastAtSymbol = textBeforeCursor.lastIndexOf('@');
    
    const textarea = e.target;
    textarea.style.height = 'auto';
    const maxHeight = parseFloat(getComputedStyle(document.documentElement).fontSize) * 1.5 * 10;

    if (textarea.scrollHeight > maxHeight) {
      textarea.style.height = `${maxHeight}px`;
      textarea.style.overflowY = 'auto';
    } else {
      textarea.style.height = `${textarea.scrollHeight}px`;
      textarea.style.overflowY = 'hidden';
    }

    onMessageChange(e);

    if (lastAtSymbol !== -1) {
      const textAfterAt = textBeforeCursor.slice(lastAtSymbol + 1);
      const hasSpaceAfterAt = textAfterAt.includes(' ');
      
      if (!hasSpaceAfterAt) {
        setMentionFilter(textAfterAt.toLowerCase());
        setShowMentionList(true);
        setMentionIndex(0);
        return;
      }
    }
    
    setShowMentionList(false);
  }, [onMessageChange, setMentionFilter, setShowMentionList, setMentionIndex]);

  const handleMentionSelect = useCallback((user) => {
    if (!messageInputRef?.current) return;

    const cursorPosition = messageInputRef.current.selectionStart;
    const textBeforeCursor = message.slice(0, cursorPosition);
    const textAfterCursor = message.slice(cursorPosition);
    const lastAtSymbol = textBeforeCursor.lastIndexOf('@');

    if (lastAtSymbol !== -1) {
      const newMessage = 
        message.slice(0, lastAtSymbol) +
        `@${user.name} ` +
        textAfterCursor;

      setMessage(newMessage);
      setShowMentionList(false);

      setTimeout(() => {
        if (messageInputRef.current) {
          const newPosition = lastAtSymbol + user.name.length + 2;
          messageInputRef.current.focus();
          messageInputRef.current.setSelectionRange(newPosition, newPosition);
        }
      }, 0);
    }
  }, [message, setMessage, setShowMentionList, messageInputRef]);

  const handleKeyDown = useCallback((e) => {
    if (showMentionList) {
      const participants = getFilteredParticipants(room); // room 객체 전달
      const participantsCount = participants.length;

      switch (e.key) {
        case 'ArrowDown':
          e.preventDefault();
          setMentionIndex(prev => 
            prev < participantsCount - 1 ? prev + 1 : 0
          );
          break;

        case 'ArrowUp':
          e.preventDefault();
          setMentionIndex(prev => 
            prev > 0 ? prev - 1 : participantsCount - 1
          );
          break;

        case 'Tab':
        case 'Enter':
          e.preventDefault();
          if (participantsCount > 0) {
            handleMentionSelect(participants[mentionIndex]);
          }
          break;

        case 'Escape':
          e.preventDefault();
          setShowMentionList(false);
          break;

        default:
          return;
      }
    } else if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      if (message.trim() || files.length > 0) {
        handleSubmit(e);
      }
    } else if (e.key === 'Escape' && showEmojiPicker) {
      setShowEmojiPicker(false);
    }
  }, [
    message,
    files,
    showMentionList,
    showEmojiPicker,
    mentionIndex,
    getFilteredParticipants,
    handleMentionSelect,
    handleSubmit,
    setMentionIndex,
    setShowMentionList,
    setShowEmojiPicker,
    room // room 의존성 추가
  ]);

  const handleMarkdownAction = useCallback((markdown) => {
    if (!messageInputRef?.current) return;

    const input = messageInputRef.current;
    const start = input.selectionStart;
    const end = input.selectionEnd;
    const selectedText = message.substring(start, end);
    let newText;
    let newCursorPos;
    let newSelectionStart;
    let newSelectionEnd;

    if (markdown.includes('\n')) {
      newText = message.substring(0, start) +
                markdown.replace('\n\n', '\n' + selectedText + '\n') +
                message.substring(end);
      if (selectedText) {
        newSelectionStart = start + markdown.split('\n')[0].length + 1;
        newSelectionEnd = newSelectionStart + selectedText.length;
        newCursorPos = newSelectionEnd;
      } else {
        newCursorPos = start + markdown.indexOf('\n') + 1;
        newSelectionStart = newCursorPos;
        newSelectionEnd = newCursorPos;
      }
    } else if (markdown.endsWith(' ')) {
      newText = message.substring(0, start) +
                markdown + selectedText +
                message.substring(end);
      newCursorPos = start + markdown.length + selectedText.length;
      newSelectionStart = newCursorPos;
      newSelectionEnd = newCursorPos;
    } else {
      newText = message.substring(0, start) +
                markdown + selectedText + markdown +
                message.substring(end);
      if (selectedText) {
        newSelectionStart = start + markdown.length;
        newSelectionEnd = newSelectionStart + selectedText.length;
      } else {
        newSelectionStart = start + markdown.length;
        newSelectionEnd = newSelectionStart;
      }
      newCursorPos = newSelectionEnd;
    }

    setMessage(newText);

    setTimeout(() => {
      if (messageInputRef.current) {
        input.focus();
        input.setSelectionRange(newSelectionStart, newSelectionEnd);
        if (selectedText) {
          input.setSelectionRange(newCursorPos, newCursorPos);
        }
      }
    }, 0);
  }, [message, setMessage, messageInputRef]);

  const handleEmojiSelect = useCallback((emoji) => {
    if (!messageInputRef?.current) return;

    const cursorPosition = messageInputRef.current.selectionStart || message.length;
    const newMessage = 
      message.slice(0, cursorPosition) + 
      emoji.native + 
      message.slice(cursorPosition);
    
    setMessage(newMessage);
    setShowEmojiPicker(false);

    setTimeout(() => {
      if (messageInputRef.current) {
        const newCursorPosition = cursorPosition + emoji.native.length;
        messageInputRef.current.focus();
        messageInputRef.current.setSelectionRange(newCursorPosition, newCursorPosition);
      }
    }, 0);
  }, [message, setMessage, setShowEmojiPicker, messageInputRef]);

  const toggleEmojiPicker = useCallback(() => {
    setShowEmojiPicker(prev => !prev);
  }, [setShowEmojiPicker]);

  const isDisabled = disabled || uploading || externalUploading;

  return (
    <div 
      className={`chat-input-wrapper ${isDragging ? 'dragging' : ''}`}
      ref={dropZoneRef}
      onDragEnter={(e) => {
        e.preventDefault();
        e.stopPropagation();
        setIsDragging(true);
      }}
      onDragLeave={(e) => {
        e.preventDefault();
        e.stopPropagation();
        setIsDragging(false);
      }}
      onDragOver={(e) => {
        e.preventDefault();
        e.stopPropagation();
        setIsDragging(true);
      }}
      onDrop={handleFileDrop}
    >
      <div className="chat-input">
        {files.length > 0 && (
          <FilePreview
            files={files}
            uploading={uploading}
            uploadProgress={uploadProgress}
            uploadError={uploadError}
            onRemove={handleFileRemove}
            onRetry={() => setUploadError(null)}
            showFileName={true}
            showFileSize={true}
            variant="default"
          />
        )}

        <div className="chat-input-toolbar">
          <MarkdownToolbar 
            onAction={handleMarkdownAction}
            size="sm"
          />
        </div>

        <div className="chat-input-main">
          {showMentionList && (
            <MentionDropdown
              participants={getFilteredParticipants(room)} // room 객체 전달
              activeIndex={mentionIndex}
              onSelect={handleMentionSelect}
              onMouseEnter={(index) => setMentionIndex(index)}
            />
          )}
          <textarea
            ref={messageInputRef}
            value={message}
            onChange={handleInputChange}
            onKeyDown={handleKeyDown}
            placeholder={isDragging ? "파일을 여기에 놓아주세요." : "메시지를 입력하세요... (@를 입력하여 멘션, Shift + Enter로 줄바꿈)"}
            disabled={isDisabled}
            className={`${isDragging ? 'dragging' : ''} chat-input-textarea`}
            rows={1}
            autoComplete="off"
            spellCheck="true"
            style={{
              minHeight: '40px',
              maxHeight: `${parseFloat(getComputedStyle(document.documentElement).fontSize) * 1.5 * 10}px`
            }}
          />
        </div>

        <div className="chat-input-actions">
          {showEmojiPicker && (
            <div 
              ref={emojiPickerRef}
              className="emoji-picker-wrapper"
              onClick={(e) => e.stopPropagation()}
            >
              <div className="emoji-picker-container">
                <EmojiPicker 
                  onSelect={handleEmojiSelect}
                  emojiSize={20}
                  emojiButtonSize={36}
                  perLine={8}
                  maxFrequentRows={4}
                />
              </div>
            </div>
          )}          
          <div className="chat-input-actions-left">
            <Button
              ref={emojiButtonRef}
              variant="ghost"
              onClick={toggleEmojiPicker}
              disabled={isDisabled}
              className="toolbar-button"
              title="이모티콘"
            >
              <Smile className="w-4 h-4" />
            </Button>
            <Button
              variant="ghost"
              onClick={() => fileInputRef?.current?.click()}
              disabled={isDisabled}
              className="toolbar-button"
              title="파일 첨부"
            >
              <Paperclip className="w-4 h-4" />
            </Button>
            <input
              type="file"
              ref={fileInputRef}
              onChange={(e) => handleFileValidationAndPreview(e.target.files?.[0])}
              className="hidden"
              accept="image/*,video/*,audio/*,application/pdf"
            />
          </div>

          <Button
            variant="ghost"
            onClick={handleSubmit}
            disabled={isDisabled || (!message.trim() && files.length === 0)}
            className="toolbar-button"
            title="메시지 보내기"
          >
            <Send className="w-4 h-4" />
          </Button>
        </div>
      </div>
    </div>
  );
});

ChatInput.displayName = 'ChatInput';

export default ChatInput;

<frontend/components/chat/ChatMessages.js>
import React, { useEffect, useLayoutEffect, useRef, useCallback, useMemo } from 'react';
import { Spinner, Text } from '@goorm-dev/vapor-components';
import { SystemMessage, FileMessage, UserMessage, AIMessage } from './Message';

// ScrollHandler 클래스 정의
class ScrollHandler {
  constructor(containerRef) {
    // Refs
    this.containerRef = containerRef;
    this.scrollHeightBeforeLoadRef = { current: 0 };
    this.scrollTopBeforeLoadRef = { current: 0 };
    this.isLoadingOldMessages = { current: false };
    this.isRestoringScroll = { current: false };
    this.isNearBottom = { current: true };
    this.scrollTimeoutRef = { current: null };
    this.scrollRestorationRef = { current: null };
    this.temporaryDisableScroll = { current: false };
    this.scrollBehavior = { current: 'smooth' };
    this.isLoadingRef = { current: false };
    this.loadMoreTriggeredRef = { current: false };

    // Constants
    this.SCROLL_THRESHOLD = 30;
    this.SCROLL_DEBOUNCE_DELAY = 100;
  }

  logDebug(action, data) {
    console.debug(`[ScrollHandler] ${action}:`, {
      ...data,
      timestamp: new Date().toISOString()
    });
  }

  saveScrollPosition() {
    const container = this.containerRef.current;
    if (!container) return;
    
    this.logDebug('saveScrollPosition', {
      scrollHeight: container.scrollHeight,
      scrollTop: container.scrollTop
    });
    
    // 이전 스크롤 위치와 높이 저장
    this.scrollHeightBeforeLoadRef.current = container.scrollHeight;
    this.scrollTopBeforeLoadRef.current = container.scrollTop;
    this.isLoadingOldMessages.current = true;
  }

  async startLoadingMessages() {
    if (this.isLoadingRef.current || this.loadMoreTriggeredRef.current) {
      this.logDebug('startLoadingMessages prevented', {
        isLoading: this.isLoadingRef.current,
        loadMoreTriggered: this.loadMoreTriggeredRef.current
      });
      return false;
    }

    this.saveScrollPosition();
    this.isLoadingRef.current = true;
    this.loadMoreTriggeredRef.current = true;
    return true;
  }

  restoreScrollPosition(immediate = true) {
    const container = this.containerRef.current;
    if (!container || !this.isLoadingOldMessages.current) return;

    try {
      this.isRestoringScroll.current = true;
      this.temporaryDisableScroll.current = true;

      const newScrollHeight = container.scrollHeight;
      const heightDifference = newScrollHeight - this.scrollHeightBeforeLoadRef.current;
      const newScrollTop = this.scrollTopBeforeLoadRef.current + heightDifference;

      this.logDebug('restoreScrollPosition', {
        newScrollHeight,
        heightDifference,
        newScrollTop,
        immediate
      });

      if (immediate) {
        const originalScrollBehavior = container.style.scrollBehavior;
        container.style.scrollBehavior = 'auto';
        container.scrollTop = newScrollTop;
        
        requestAnimationFrame(() => {
          container.style.scrollBehavior = originalScrollBehavior;
          this.temporaryDisableScroll.current = false;
          this.isRestoringScroll.current = false;
        });
      } else {
        container.scrollTo({
          top: newScrollTop,
          behavior: 'smooth'
        });
        this.temporaryDisableScroll.current = false;
        this.isRestoringScroll.current = false;
      }
    } finally {
      this.resetScrollState();
    }
  }

  resetScrollState() {
    this.scrollHeightBeforeLoadRef.current = 0;
    this.scrollTopBeforeLoadRef.current = 0;
    this.isLoadingOldMessages.current = false;
    this.isLoadingRef.current = false;
    this.loadMoreTriggeredRef.current = false;

    setTimeout(() => {
      this.isRestoringScroll.current = false;
      this.temporaryDisableScroll.current = false;
    }, 100);
  }

  shouldScrollToBottom(newMessage, isMine) {
    if (this.isLoadingOldMessages.current || this.isRestoringScroll.current) {
      return false;
    }
    return isMine || this.isNearBottom.current;
  }

  updateScrollPosition() {
    const container = this.containerRef.current;
    if (!container) return null;

    const { scrollTop, scrollHeight, clientHeight } = container;
    this.isNearBottom.current = (scrollHeight - scrollTop - clientHeight) < 100;

    const scrollInfo = {
      isAtTop: scrollTop < this.SCROLL_THRESHOLD,
      isAtBottom: this.isNearBottom.current,
      scrollTop,
      scrollHeight,
      clientHeight
    };

    this.logDebug('updateScrollPosition', scrollInfo);
    return scrollInfo;
  }

  async handleScroll(event, options) {
    const {
      hasMoreMessages,
      loadingMessages,
      onLoadMore,
      onScrollPositionChange,
      onScroll
    } = options;

    if (this.temporaryDisableScroll.current || this.isRestoringScroll.current) {
      this.logDebug('handleScroll skipped', {
        temporaryDisableScroll: this.temporaryDisableScroll.current,
        isRestoringScroll: this.isRestoringScroll.current
      });
      return;
    }

    const scrollInfo = this.updateScrollPosition();
    if (!scrollInfo) return;

    if (this.scrollTimeoutRef.current) {
      clearTimeout(this.scrollTimeoutRef.current);
    }

    this.scrollTimeoutRef.current = setTimeout(async () => {
      if (scrollInfo.isAtTop && hasMoreMessages && !loadingMessages) {
        this.logDebug('handleScroll loadMore', {
          isAtTop: scrollInfo.isAtTop,
          hasMoreMessages,
          loadingMessages
        });

        if (await this.startLoadingMessages()) {
          try {
            await onLoadMore();
          } catch (error) {
            console.error('Load more error:', error);
            this.resetScrollState();
          }
        }
      }

      onScrollPositionChange?.(scrollInfo);
      onScroll?.(scrollInfo);
    }, this.SCROLL_DEBOUNCE_DELAY);
  }

  scrollToBottom(behavior = 'smooth') {
    if (this.isLoadingOldMessages.current || this.isRestoringScroll.current) {
      return;
    }

    const container = this.containerRef.current;
    if (!container) return;

    requestAnimationFrame(() => {
      try {
        const scrollHeight = container.scrollHeight;
        const height = container.clientHeight;
        const maxScrollTop = scrollHeight - height;

        container.scrollTo({
          top: maxScrollTop,
          behavior
        });

        this.logDebug('scrollToBottom', {
          scrollHeight,
          height,
          maxScrollTop,
          behavior
        });
      } catch (error) {
        console.error('Scroll to bottom error:', error);
        container.scrollTop = container.scrollHeight;
      }
    });
  }

  cleanup() {
    if (this.scrollTimeoutRef.current) {
      clearTimeout(this.scrollTimeoutRef.current);
    }
    if (this.scrollRestorationRef.current) {
      cancelAnimationFrame(this.scrollRestorationRef.current);
    }
  }
}

const LoadingIndicator = React.memo(({ text }) => (
  <div className="loading-messages">
    <Spinner size="sm" className="text-primary" />
    <Text size="sm" color="secondary">{text}</Text>
  </div>
));
LoadingIndicator.displayName = 'LoadingIndicator';

const MessageHistoryEnd = React.memo(() => (
  <div className="message-history-end">
    <Text size="sm" color="secondary">더 이상 불러올 메시지가 없습니다.</Text>
  </div>
));
MessageHistoryEnd.displayName = 'MessageHistoryEnd';

const EmptyMessages = React.memo(() => (
  <div className="empty-messages">
    <p>아직 메시지가 없습니다.</p>
    <p>첫 메시지를 보내보세요!</p>
  </div>
));
EmptyMessages.displayName = 'EmptyMessages';

const ChatMessages = ({ 
  messages = [], 
  streamingMessages = {}, 
  currentUser = null,
  room = null,
  loadingMessages = false,
  hasMoreMessages = true,
  onScroll = () => {},
  onLoadMore = () => {},
  onReactionAdd = () => {},
  onReactionRemove = () => {},
  messagesEndRef,
  socketRef,
  scrollToBottomOnNewMessage = true,
  onScrollPositionChange = () => {}
}) => {
  const containerRef = useRef(null);
  const lastMessageRef = useRef(null);
  const initialScrollRef = useRef(false);
  const lastMessageCountRef = useRef(messages.length);
  const initialLoadRef = useRef(true);
  const loadingTimeoutRef = useRef(null);
  const scrollHandler = useRef(new ScrollHandler(containerRef));

  const logDebug = useCallback((action, data) => {
    console.debug(`[ChatMessages] ${action}:`, {
      ...data,
      loadingMessages,
      hasMoreMessages,
      isLoadingOldMessages: scrollHandler.current.isLoadingOldMessages.current,
      messageCount: messages.length,
      timestamp: new Date().toISOString(),
      isInitialLoad: initialLoadRef.current
    });
  }, [loadingMessages, hasMoreMessages, messages.length]);

  const isMine = useCallback((msg) => {
    if (!msg?.sender || !currentUser?.id) return false;
    return (
      msg.sender._id === currentUser.id || 
      msg.sender.id === currentUser.id ||
      msg.sender === currentUser.id
    );
  }, [currentUser?.id]);

  const handleScroll = useCallback((event) => {
    scrollHandler.current.handleScroll(event, {
      hasMoreMessages,
      loadingMessages,
      onLoadMore,
      onScrollPositionChange,
      onScroll
    });
  }, [hasMoreMessages, loadingMessages, onLoadMore, onScrollPositionChange, onScroll]);

  // 새 메시지 도착 시 스크롤 처리
  useLayoutEffect(() => {
    if (messages.length > lastMessageCountRef.current) {
      const newMessages = messages.slice(lastMessageCountRef.current);
      const lastMessage = newMessages[newMessages.length - 1];
      
      const shouldScroll = scrollToBottomOnNewMessage && 
        scrollHandler.current.shouldScrollToBottom(lastMessage, isMine(lastMessage));

      if (shouldScroll) {
        scrollHandler.current.scrollToBottom('smooth');
      }

      lastMessageCountRef.current = messages.length;
    }
  }, [messages, scrollToBottomOnNewMessage, isMine]);

  // 과거 메시지 로드 후 스크롤 위치 복원
  useLayoutEffect(() => {
    if (!loadingMessages && scrollHandler.current.isLoadingOldMessages.current) {
      if (scrollHandler.current.scrollRestorationRef.current) {
        cancelAnimationFrame(scrollHandler.current.scrollRestorationRef.current);
      }

      scrollHandler.current.scrollRestorationRef.current = requestAnimationFrame(() => {
        scrollHandler.current.restoreScrollPosition(true);
      });
    }
  }, [loadingMessages]);

  // 스트리밍 메시지 처리
  useEffect(() => {
    const streamingMessagesArray = Object.values(streamingMessages);
    if (streamingMessagesArray.length > 0) {
      const lastMessage = streamingMessagesArray[streamingMessagesArray.length - 1];
      
      if (lastMessage && scrollHandler.current.shouldScrollToBottom(lastMessage, isMine(lastMessage))) {
        scrollHandler.current.scrollToBottom('smooth');
      }
    }
  }, [streamingMessages, isMine]);

  // 초기 스크롤 설정
  useLayoutEffect(() => {
    if (!initialScrollRef.current && messages.length > 0) {
      scrollHandler.current.scrollToBottom('auto');
      initialScrollRef.current = true;
      
      if (initialLoadRef.current) {
        setTimeout(() => {
          initialLoadRef.current = false;
        }, 1000);
      }
    }
  }, [messages.length]);

  // 스크롤 이벤트 리스너 설정
  useEffect(() => {
    const container = containerRef.current;
    if (!container) return;

    container.addEventListener('scroll', handleScroll, { passive: true });
    
    return () => {
      scrollHandler.current.cleanup();
      if (loadingTimeoutRef.current) {
        clearTimeout(loadingTimeoutRef.current);
      }
      container.removeEventListener('scroll', handleScroll);
    };
  }, [handleScroll]);

  const allMessages = useMemo(() => {
    if (!Array.isArray(messages)) return [];
    
    const streamingArray = Object.values(streamingMessages || {});
    const combinedMessages = [...messages, ...streamingArray];

    return combinedMessages.sort((a, b) => {
      if (!a?.timestamp || !b?.timestamp) return 0;
      return new Date(a.timestamp) - new Date(b.timestamp);
    });
  }, [messages, streamingMessages]);

  const renderMessage = useCallback((msg, idx) => {
    if (!msg || !SystemMessage || !FileMessage || !UserMessage || !AIMessage) {
      console.error('Message component undefined:', {
        msgType: msg?.type,
        hasSystemMessage: !!SystemMessage,
        hasFileMessage: !!FileMessage,
        hasUserMessage: !!UserMessage,
        hasAIMessage: !!AIMessage
      });
      return null;
    }

    const isLast = idx === allMessages.length - 1;
    const commonProps = {
      currentUser,
      room,
      onReactionAdd,
      onReactionRemove
    };

    const MessageComponent = {
      system: SystemMessage,
      file: FileMessage,
      ai: AIMessage
    }[msg.type] || UserMessage;

    return (
      <MessageComponent
        key={msg._id || `msg-${idx}`}
        ref={isLast ? lastMessageRef : null}
        {...commonProps}
        msg={msg}
        content={msg.content}
        isMine={msg.type !== 'system' ? isMine(msg) : undefined}
        isStreaming={msg.type === 'ai' ? (msg.isStreaming || false) : undefined}
        messageRef={msg}
        socketRef={socketRef}
      />
    );
  }, [allMessages.length, currentUser, room, isMine, onReactionAdd, onReactionRemove, socketRef]);

  return (
    <div 
      className="message-list" 
      ref={containerRef}
      role="log"
      aria-live="polite"
      aria-atomic="false"
    >
      {loadingMessages && <LoadingIndicator text="이전 메시지를 불러오는 중..." />}

      {!loadingMessages && !hasMoreMessages && messages.length > 0 && (
        <MessageHistoryEnd />
      )}

      {allMessages.length === 0 ? (
        <EmptyMessages />
      ) : (
        allMessages.map((msg, idx) => renderMessage(msg, idx))
      )}
    </div>
  );
};

ChatMessages.displayName = 'ChatMessages';

export default React.memo(ChatMessages);

<frontend/components/chat/EmojiPicker.js>
// components/EmojiPicker.js

import React from 'react';
import data from '@emoji-mart/data/sets/14/native';
import Picker from '@emoji-mart/react';

function EmojiPicker({ onSelect }) {
  return (
    <div className="emoji-picker-wrapper">
      <Picker
        data={data}
        onEmojiSelect={onSelect}
        theme="light"
        set="native"
        locale="ko"
        previewPosition="none"
        skinTonePosition="none"
        emojiButtonSize={30}
        emojiSize={20}
        maxFrequentRows={4}
        perLine={9}
      />
    </div>
  );
}

export default EmojiPicker;

<frontend/components/chat/FilePreview.js>
import React, { useEffect, useRef, useCallback, memo } from 'react';
import { Button } from '@goorm-dev/vapor-components';
import { 
  X, 
  AlertCircle, 
  Image as ImageIcon, 
  FileText, 
  Film, 
  Loader,
  Music,
  File
} from 'lucide-react';
import fileService from '../../services/fileService';

const FilePreview = ({ 
  files = [],
  uploading = false, 
  uploadProgress = 0, 
  uploadError = null, 
  onRemove,
  onRetry,
  onDrop,
  className = '',
  showFileName = true,
  showFileSize = true,
  variant = 'default',
  previewSize = 'md',
  allowPaste = true,
  maxFiles = 10
}) => {
  const containerRef = useRef(null);
  const previewUrlsRef = useRef(new Map());
  const dragCounter = useRef(0);

  // 파일 객체 URL 정리를 위한 클린업
  useEffect(() => {
    return () => {
      previewUrlsRef.current.forEach(url => {
        URL.revokeObjectURL(url);
      });
      previewUrlsRef.current.clear();
    };
  }, []);

  // 파일 유효성 검사 및 처리를 위한 공통 함수
  const processFile = useCallback(async (file) => {
    try {
      await fileService.validateFile(file);
      const fileObject = {
        file,
        name: file.name || `file-${Date.now()}.${file.type.split('/')[1]}`,
        type: file.type,
        size: file.size
      };

      const previewUrl = URL.createObjectURL(file);
      previewUrlsRef.current.set(fileObject.name, previewUrl);
      
      return fileObject;
    } catch (error) {
      console.error('File processing error:', error);
      throw error;
    }
  }, []);

  // 붙여넣기 이벤트 핸들러
  useEffect(() => {
    if (!allowPaste) return;

    const handlePaste = async (e) => {
      if (!containerRef.current?.contains(e.target)) return;
      if (files.length >= maxFiles) return;

      const items = e.clipboardData?.items;
      if (!items) return;

      const fileItems = Array.from(items).filter(
        item => item.kind === 'file' && 
        (item.type.startsWith('image/') || 
         item.type.startsWith('video/') || 
         item.type.startsWith('audio/') || 
         item.type === 'application/pdf')
      );

      if (fileItems.length === 0) return;

      e.preventDefault();

      const availableSlots = maxFiles - files.length;
      const itemsToProcess = fileItems.slice(0, availableSlots);

      for (const item of itemsToProcess) {
        const file = item.getAsFile();
        if (!file) continue;

        try {
          const processedFile = await processFile(file);
          onDrop?.(processedFile);
        } catch (error) {
          console.error('Paste handling error:', error);
        }
      }
    };

    document.addEventListener('paste', handlePaste);
    return () => document.removeEventListener('paste', handlePaste);
  }, [allowPaste, files.length, maxFiles, onDrop, processFile]);

  // 드래그 앤 드롭 이벤트 핸들러
  useEffect(() => {
    if (!containerRef.current || !onDrop) return;

    const handleDrop = async (e) => {
      e.preventDefault();
      e.stopPropagation();
      dragCounter.current = 0;

      containerRef.current.classList.remove('drag-over');

      if (files.length >= maxFiles) return;

      const droppedFiles = Array.from(e.dataTransfer.files)
        .filter(file => 
          file.type.startsWith('image/') || 
          file.type.startsWith('video/') || 
          file.type.startsWith('audio/') || 
          file.type === 'application/pdf'
        );

      if (droppedFiles.length === 0) return;

      const availableSlots = maxFiles - files.length;
      const filesToProcess = droppedFiles.slice(0, availableSlots);

      for (const file of filesToProcess) {
        try {
          const processedFile = await processFile(file);
          onDrop(processedFile);
        } catch (error) {
          console.error('Drop handling error:', error);
        }
      }
    };

    const handleDragOver = (e) => {
      e.preventDefault();
      e.stopPropagation();
      if (files.length < maxFiles) {
        containerRef.current.classList.add('drag-over');
      }
    };

    const handleDragEnter = (e) => {
      e.preventDefault();
      e.stopPropagation();
      dragCounter.current++;
      if (dragCounter.current === 1 && files.length < maxFiles) {
        containerRef.current.classList.add('drag-over');
      }
    };

    const handleDragLeave = (e) => {
      e.preventDefault();
      e.stopPropagation();
      dragCounter.current--;
      if (dragCounter.current === 0) {
        containerRef.current.classList.remove('drag-over');
      }
    };

    const elem = containerRef.current;
    elem.addEventListener('drop', handleDrop);
    elem.addEventListener('dragover', handleDragOver);
    elem.addEventListener('dragenter', handleDragEnter);
    elem.addEventListener('dragleave', handleDragLeave);

    return () => {
      elem.removeEventListener('drop', handleDrop);
      elem.removeEventListener('dragover', handleDragOver);
      elem.removeEventListener('dragenter', handleDragEnter);
      elem.removeEventListener('dragleave', handleDragLeave);
    };
  }, [files.length, maxFiles, onDrop, processFile]);

  const getFileIcon = useCallback((file) => {
    const iconProps = {
      size: variant === 'compact' ? 20 : 24,
      className: 'file-icon',
      'aria-hidden': true
    };

    if (file.type.startsWith('image/')) {
      return <ImageIcon {...iconProps} color="#00C853" />;
    } else if (file.type.startsWith('video/')) {
      return <Film {...iconProps} color="#2196F3" />;
    } else if (file.type.startsWith('audio/')) {
      return <Music {...iconProps} color="#9C27B0" />;
    } else if (file.type === 'application/pdf') {
      return <FileText {...iconProps} color="#F44336" />;
    } else {
      return <File {...iconProps} color="#757575" />;
    }
  }, [variant]);

  const renderFilePreview = useCallback((file) => {
    const previewUrl = previewUrlsRef.current.get(file.name);
    const previewContainer = "rounded-lg overflow-hidden relative";
    const previewBackground = "bg-transparent-pattern";

    if (file.type.startsWith('image/')) {
      return (
        <div className={`${previewContainer} ${previewBackground}`}>
          <img
            src={previewUrl || file.url}
            alt={`${file.name} 미리보기`}
            className="w-full h-full object-cover"
            onError={(e) => {
              e.target.onerror = null;
              e.target.src = '/placeholder-image.png';
              e.target.alt = '이미지 로드 실패';
            }}
            loading="lazy"
          />
        </div>
      );
    }

    if (file.type.startsWith('video/')) {
      return (
        <div className={`${previewContainer}`}>
          <video
            src={previewUrl || file.url}
            className="w-full h-full object-cover"
            controls={variant !== 'compact'}
            controlsList="nodownload"
            preload="metadata"
            aria-label={`${file.name} 비디오 미리보기`}
          >
            <source src={previewUrl || file.url} type={file.type} />
            <track kind="captions" />
            비디오 미리보기를 지원하지 않는 브라우저입니다.
          </video>
          <div className="absolute inset-0 flex items-center justify-center bg-black bg-opacity-30">
            {getFileIcon(file)}
          </div>
        </div>
      );
    }

    return (
      <div className={`${previewContainer} flex flex-col items-center justify-center`}
           role="img"
           aria-label={`${file.name} 파일 아이콘`}>
        {getFileIcon(file)}
        {showFileName && (
          <span className="mt-2 text-xs text-gray-600 truncate max-w-[80px]">
            {file.type.split('/')[1].toUpperCase()}
          </span>
        )}
      </div>
    );
  }, [variant, showFileName, getFileIcon]);

  const renderProgressBar = () => {
    if (!uploading) return null;

    return (
      <div 
        className="mt-4 h-1 w-full bg-gray-200 rounded-full overflow-hidden"
        role="progressbar"
        aria-valuenow={uploadProgress}
        aria-valuemin="0"
        aria-valuemax="100"
      >
        <div 
          className="h-full bg-primary transition-all duration-300 ease-in-out"
          style={{ width: `${uploadProgress}%` }}
        />
      </div>
    );
  };

  const renderUploadStatus = useCallback(() => {
    if (uploadError) {
      return (
        <div className="mt-2 flex items-center gap-2 text-danger text-sm" role="alert">
          <AlertCircle className="w-4 h-4" aria-hidden="true" />
          <span className="flex-1">{uploadError}</span>
          {onRetry && (
            <Button
              variant="ghost"
              size="sm"
              onClick={onRetry}
              className="text-xs"
            >
              다시 시도
            </Button>
          )}
        </div>
      );
    }

    if (uploading) {
      return (
        <div className="mt-2 flex items-center gap-2 text-sm text-gray-600">
          <Loader className="w-4 h-4 animate-spin" aria-hidden="true" />
          <span>{uploadProgress}% 업로드 중...</span>
        </div>
      );
    }

    return null;
  }, [uploadError, uploading, uploadProgress, onRetry]);

  if (files.length === 0) return null;

  return (
    <div 
      ref={containerRef}
      className={`file-preview-scroll-container ${className} ${onDrop ? 'cursor-pointer' : ''}`}
      role="region"
      aria-label="파일 미리보기"
    >
      <div className="file-preview-list">
        {files.map((file, index) => (
          <div 
            key={`${file.name}-${index}`}
            className="file-preview-item"
          >
            <div className="file-preview-content">
              {renderFilePreview(file)}
              
              <div className="flex-1 min-w-0">
                {showFileName && (
                  <div 
                    className="text-sm font-medium truncate" 
                    title={file.name}
                  >
                    {file.name}
                  </div>
                )}
                {showFileSize && (
                  <div className="text-xs text-gray-500 mt-1">
                    {fileService.formatFileSize(file.size)}
                  </div>
                )}
              </div>

              {variant !== 'readonly' && (
                <div className="flex-shrink-0">
                  {!uploading && onRemove && (
                    <Button
                      variant="ghost"
                      size="sm"
                      onClick={() => {
                        const url = previewUrlsRef.current.get(file.name);
                        if (url) {
                          URL.revokeObjectURL(url);
                          previewUrlsRef.current.delete(file.name);
                        }
                        onRemove(file);
                      }}
                      className="remove-button"
                      title={`${file.name} 파일 제거`}
                      aria-label={`${file.name} 파일 제거`}
                    >
                      <X className="w-4 h-4" aria-hidden="true" />
                    </Button>
                  )}
                </div>
              )}
            </div>
          </div>
        ))}
      </div>

      {renderProgressBar()}
      {renderUploadStatus()}

      {files.length >= maxFiles && (
        <div className="file-limit-warning" role="alert">
          <AlertCircle className="w-4 h-4" aria-hidden="true" />
          <span>파일은 최대 {maxFiles}개까지만 업로드할 수 있습니다.</span>
        </div>
      )}

      {onDrop && (
        <div 
          className="absolute inset-0 bg-primary/10 border-2 border-primary border-dashed rounded-lg opacity-0 pointer-events-none transition-opacity drag-over:opacity-100"
          aria-hidden="true"
        >
          <div className="absolute inset-0 flex items-center justify-center">
            <span className="text-primary font-medium">
              파일을 여기에 놓으세요
            </span>
          </div>
        </div>
      )}
    </div>
  );
};

FilePreview.defaultProps = {
  files: [],
  uploading: false,
  uploadProgress: 0,
  uploadError: null,
  showFileName: true,
  showFileSize: true,
  previewSize: 'md',
  variant: 'default',
  allowPaste: true,
  maxFiles: 10
};

export default memo(FilePreview);

<frontend/components/chat/MarkdownToolbar.js>
import React, { useCallback } from 'react';
import { Button, ButtonGroup } from '@goorm-dev/vapor-components';
import {
  Bold,
  Italic,
  Code,
  FileCode2,
  List,
  ListOrdered,
  Quote,
  Heading2,
  Link2
} from 'lucide-react';

const MarkdownToolbar = ({ onAction, className = '', size = 'xs' }) => {
  // OS 확인
  const isMac = typeof window !== 'undefined' && navigator.platform.toUpperCase().indexOf('MAC') >= 0;
  const modifierKey = isMac ? '⌘' : 'Ctrl';
  
  const toolbarActions = [
    { 
      id: 'bold',
      icon: Bold, 
      markdown: '**',
      tooltip: '굵게',
      shortcut: `${modifierKey}+B`,
      keyBinding: { key: 'b', modifier: true }
    },
    { 
      id: 'italic',
      icon: Italic, 
      markdown: '_',
      tooltip: '기울임',
      shortcut: `${modifierKey}+I`,
      keyBinding: { key: 'i', modifier: true }
    },
    { 
      id: 'inline-code',
      icon: Code, 
      markdown: '`',
      tooltip: '인라인 코드',
      shortcut: `${modifierKey}+\``,
      keyBinding: { key: '`', modifier: true }
    },
    { 
      id: 'code-block',
      icon: FileCode2, 
      markdown: '```\n\n```',
      tooltip: '코드 블록',
      shortcut: `${modifierKey}+Shift+C`,
      keyBinding: { key: 'c', modifier: true, shift: true }
    },
    { 
      id: 'bullet-list',
      icon: List, 
      markdown: '- ',
      tooltip: '글머리 기호',
      shortcut: `${modifierKey}+U`,
      keyBinding: { key: 'u', modifier: true }
    },
    { 
      id: 'numbered-list',
      icon: ListOrdered, 
      markdown: '1. ',
      tooltip: '번호 매기기',
      shortcut: `${modifierKey}+O`,
      keyBinding: { key: 'o', modifier: true }
    },
    { 
      id: 'quote',
      icon: Quote, 
      markdown: '> ',
      tooltip: '인용',
      shortcut: `${modifierKey}+Q`,
      keyBinding: { key: 'q', modifier: true }
    },
    { 
      id: 'heading',
      icon: Heading2, 
      markdown: '## ',
      tooltip: '제목',
      shortcut: `${modifierKey}+H`,
      keyBinding: { key: 'h', modifier: true }
    },
    { 
      id: 'link',
      icon: Link2, 
      markdown: '[](url)',
      tooltip: '링크',
      shortcut: `${modifierKey}+K`,
      keyBinding: { key: 'k', modifier: true }
    }
  ];

  const handleKeyDown = useCallback((e) => {
    const isModifierPressed = isMac ? e.metaKey : e.ctrlKey;
    
    const action = toolbarActions.find(action => {
      const kb = action.keyBinding;
      return kb.key === e.key.toLowerCase() &&
        kb.modifier === isModifierPressed &&
        (!kb.shift || kb.shift === e.shiftKey);
    });

    if (action) {
      e.preventDefault();
      onAction(action.markdown);
    }
  }, [onAction, isMac, toolbarActions]);

  React.useEffect(() => {
    document.addEventListener('keydown', handleKeyDown);
    return () => {
      document.removeEventListener('keydown', handleKeyDown);
    };
  }, [handleKeyDown]);

  const ToolbarButton = ({ action }) => {
    const Icon = action.icon;
    return (
      <Button
        variant="ghost"
        onClick={() => onAction(action.markdown)}
        type="button"
        className="toolbar-button"
        title={`${action.tooltip} (${action.shortcut})`}
      >
        <Icon className="w-4 h-4" />
      </Button>
    );
  };

  return (
    <div className={`markdown-toolbar ${className}`}>
      <ButtonGroup size={size}>
        {toolbarActions.map((action) => (
          <ToolbarButton key={action.id} action={action} />
        ))}
      </ButtonGroup>
    </div>
  );
};

export default MarkdownToolbar;

<frontend/components/chat/MentionDropdown.js>
import React, { useCallback, memo, useRef, useEffect } from 'react';
import { Avatar } from '@goorm-dev/vapor-core';
import { getAIAvatarStyles, generateColorFromEmail, getContrastTextColor } from '../../utils/colorUtils';

const MentionDropdown = ({ 
  participants = [], 
  activeIndex = 0, 
  onSelect = () => {}, 
  onMouseEnter = () => {}
}) => {
  const dropdownRef = useRef(null);
  const itemRefs = useRef([]);

  // 활성 항목이 변경될 때마다 스크롤 조정
  useEffect(() => {
    if (!dropdownRef.current || !itemRefs.current[activeIndex]) return;

    const container = dropdownRef.current;
    const activeItem = itemRefs.current[activeIndex];
    
    // 활성 항목의 위치 계산
    const itemTop = activeItem.offsetTop;
    const itemBottom = itemTop + activeItem.offsetHeight;
    const containerTop = container.scrollTop;
    const containerBottom = containerTop + container.offsetHeight;

    // 활성 항목이 보이는 영역을 벗어났는지 확인
    if (itemTop < containerTop) {
      container.scrollTo({
        top: itemTop,
        behavior: 'smooth'
      });
    } else if (itemBottom > containerBottom) {
      container.scrollTo({
        top: itemBottom - container.offsetHeight,
        behavior: 'smooth'
      });
    }
  }, [activeIndex]);

  const getAvatarStyles = useCallback((user) => {
    if (!user) return {};

    if (user.isAI) {
      const aiStyles = getAIAvatarStyles(user.name);
      return {
        backgroundColor: aiStyles.backgroundColor,
        color: aiStyles.color,
        boxShadow: '0 2px 4px rgba(0, 0, 0, 0.2)'
      };
    }
    
    const backgroundColor = generateColorFromEmail(user.email);
    const color = getContrastTextColor(backgroundColor);
    return { 
      backgroundColor, 
      color,
      boxShadow: '0 2px 4px rgba(0, 0, 0, 0.1)'
    };
  }, []);

  const renderUserBadge = useCallback((user) => {
    if (user.isAI) {
      return (
        <span className="mention-badge ai">
          AI 어시스턴트
        </span>
      );
    }
    
    return (
      <span className="mention-badge user" title={user.email}>
        {user.email}
      </span>
    );
  }, []);

  const getAvatarContent = useCallback((user) => {
    if (user.isAI) {
      return user.name === 'wayneAI' ? 'W' : 'C';
    }
    return user.name.charAt(0).toUpperCase();
  }, []);

  const handleKeyDown = useCallback((e, user) => {
    if (e.key === 'Enter' || e.key === ' ') {
      e.preventDefault();
      onSelect(user);
    }
  }, [onSelect]);

  if (!participants?.length) return null;

  return (
    <div 
      className="mention-dropdown" 
      role="listbox" 
      aria-label="멘션할 사용자 목록"
      ref={dropdownRef}
    >
      {participants.map((user, index) => (
        <div
          key={user._id || `ai-${user.name}`}
          ref={el => itemRefs.current[index] = el}
          role="option"
          aria-selected={index === activeIndex}
          tabIndex={0}
          className={`mention-item ${index === activeIndex ? 'active' : ''}`}
          onClick={() => onSelect(user)}
          onKeyDown={(e) => handleKeyDown(e, user)}
          onMouseEnter={() => onMouseEnter(index)}
        >
          <div className="mention-item-content">
            <Avatar 
              size="lg"
              style={getAvatarStyles(user)}
              className="mention-avatar"
              aria-label={`${user.name}의 아바타`}
            >
              {getAvatarContent(user)}
            </Avatar>
            
            <div className="mention-info">
              <span className="mention-name">
                {user.isAI ? (user.name === 'wayneAI' ? 'Wayne AI' : 'Consulting AI') : user.name}
              </span>
              {renderUserBadge(user)}
            </div>
          </div>
        </div>
      ))}
    </div>
  );
};

export default memo(MentionDropdown);

<frontend/components/chat/Message/AIMessage.js>
import React from 'react';
import PersistentAvatar from '../../common/PersistentAvatar';
import MessageContent from './MessageContent';
import MessageActions from './MessageActions';
import ReadStatus from '../ReadStatus';

const AIMessage = ({ 
  msg = {}, 
  isStreaming = false,                   
  isMine = false, 
  currentUser = null,
  onReactionAdd,
  onReactionRemove,
  room = null,
  messageRef,
  socketRef
}) => {
  const formattedTime = new Date(msg.timestamp).toLocaleString('ko-KR', {
    year: 'numeric',
    month: 'long',
    day: 'numeric',
    hour: '2-digit',
    minute: '2-digit',
    second: '2-digit',
    hour12: false
  }).replace(/\./g, '년').replace(/\s/g, ' ').replace('일 ', '일 ');

  // AI 사용자 정보 생성
  const aiUser = {
    name: msg.aiType === 'wayneAI' ? 'Wayne AI' : 'Consulting AI',
    email: msg.aiType === 'wayneAI' ? 'ai@wayne.ai' : 'ai@consulting.ai',
    avatarInitial: msg.aiType === 'wayneAI' ? 'W' : 'C'
  };

  const renderContent = () => {
    if (isStreaming) {
      return (
        <>
          <MessageContent content={msg.content} />
          <div className="typing-indicator">
            <span></span>
            <span></span>
            <span></span>
          </div>
        </>
      );
    }
    return <MessageContent content={msg.content} />;
  };

  return (
    <div className="message-group yours">
      <div className="message-sender-info">
        <PersistentAvatar 
          user={aiUser}
          size="lg"
          showInitials={true}
        />
        <span className="sender-name">
          {aiUser.name}
        </span>
      </div>
      <div className="message-bubble message-ai last relative group">
        <div className="message-content">
          {renderContent()}
        </div>
        
        {!isStreaming && (
          <div className="message-footer">
            <div className="message-time mr-3">
              {formattedTime}
            </div>
            <ReadStatus 
              messageType={msg.type}
              participants={room.participants}
              readers={msg.readers}
              messageId={msg._id}
              messageRef={messageRef}
              currentUserId={currentUser.id}
              socketRef={socketRef}
            />
          </div>
        )}        
      </div>
      
      <MessageActions 
        messageId={msg._id}
        messageContent={msg.content}
        reactions={msg.reactions}
        currentUserId={currentUser?.id}
        onReactionAdd={onReactionAdd}
        onReactionRemove={onReactionRemove}
        isMine={isMine}
        room={room}
      />
    </div>
  );
};

AIMessage.defaultProps = {
  msg: {},
  isStreaming: false,
  currentUser: null,
  onReactionAdd: () => {},
  onReactionRemove: () => {},
  room: null
};

export default React.memo(AIMessage);

<frontend/components/chat/Message/FileMessage.js>
import React, { useState, useEffect } from 'react';
import { Button } from '@goorm-dev/vapor-core';
import { 
  FileText, 
  Image, 
  Film, 
  CheckCheck, 
  Check, 
  Music, 
  ExternalLink, 
  Download,
  AlertCircle 
} from 'lucide-react';
import { Text, Alert } from '@goorm-dev/vapor-components';
import PersistentAvatar from '../../common/PersistentAvatar';
import MessageContent from './MessageContent';
import MessageActions from './MessageActions';
import ReadStatus from '../ReadStatus';
import fileService from '../../../services/fileService';
import authService from '../../../services/authService';

const FileMessage = ({ 
  msg = {}, 
  isMine = false, 
  currentUser = null,
  onReactionAdd,
  onReactionRemove,
  room = null,
  messageRef,
  socketRef
}) => {
  const [error, setError] = useState(null);
  const [previewUrl, setPreviewUrl] = useState('');

  useEffect(() => {
    if (msg?.file) {
      const url = fileService.getPreviewUrl(msg.file, true);
      setPreviewUrl(url);
      console.debug('Preview URL generated:', {
        filename: msg.file.filename,
        url
      });
    }
  }, [msg?.file]);

  if (!msg?.file) {
    console.error('File data is missing:', msg);
    return null;
  }

  const formattedTime = new Date(msg.timestamp).toLocaleString('ko-KR', {
    year: 'numeric',
    month: 'long',
    day: 'numeric',
    hour: '2-digit',
    minute: '2-digit',
    second: '2-digit',
    hour12: false
  }).replace(/\./g, '년').replace(/\s/g, ' ').replace('일 ', '일 ');

  const getFileIcon = () => {
    const mimetype = msg.file?.mimetype || '';
    const iconProps = { className: "w-5 h-5 flex-shrink-0" };

    if (mimetype.startsWith('image/')) return <Image {...iconProps} color="#00C853" />;
    if (mimetype.startsWith('video/')) return <Film {...iconProps} color="#2196F3" />;
    if (mimetype.startsWith('audio/')) return <Music {...iconProps} color="#9C27B0" />;
    return <FileText {...iconProps} color="#ffffff" />;
  };

  const getDecodedFilename = (encodedFilename) => {
    try {
      if (!encodedFilename) return 'Unknown File';
      
      const base64 = encodedFilename
        .replace(/-/g, '+')
        .replace(/_/g, '/');
      
      const pad = base64.length % 4;
      const paddedBase64 = pad ? base64 + '='.repeat(4 - pad) : base64;
      
      if (paddedBase64.match(/^[A-Za-z0-9+/=]+$/)) {
        return Buffer.from(paddedBase64, 'base64').toString('utf8');
      }

      return decodeURIComponent(encodedFilename);
    } catch (error) {
      console.error('Filename decoding error:', error);
      return encodedFilename;
    }
  };

  const renderAvatar = () => (
    <PersistentAvatar 
      user={isMine ? currentUser : msg.sender}
      size="lg"
      className="flex-shrink-0"
      showInitials={true}
    />
  );

  const handleFileDownload = async (e) => {
    e.preventDefault();
    e.stopPropagation();
    setError(null);
    
    try {
      if (!msg.file?.filename) {
        throw new Error('파일 정보가 없습니다.');
      }

      const user = authService.getCurrentUser();
      if (!user?.token || !user?.sessionId) {
        throw new Error('인증 정보가 없습니다.');
      }

      const baseUrl = fileService.getFileUrl(msg.file.filename, false);
      const authenticatedUrl = `${baseUrl}?token=${encodeURIComponent(user.token)}&sessionId=${encodeURIComponent(user.sessionId)}&download=true`;

      const link = document.createElement('a');
      link.href = authenticatedUrl;
      link.download = getDecodedFilename(msg.file.originalname);
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);

    } catch (error) {
      console.error('File download error:', error);
      setError(error.message || '파일 다운로드 중 오류가 발생했습니다.');
    }
  };

  const handleViewInNewTab = (e) => {
    e.preventDefault();
    e.stopPropagation();
    setError(null);

    try {
      if (!msg.file?.filename) {
        throw new Error('파일 정보가 없습니다.');
      }

      const user = authService.getCurrentUser();
      if (!user?.token || !user?.sessionId) {
        throw new Error('인증 정보가 없습니다.');
      }

      const baseUrl = fileService.getFileUrl(msg.file.filename, true);
      const authenticatedUrl = `${baseUrl}?token=${encodeURIComponent(user.token)}&sessionId=${encodeURIComponent(user.sessionId)}`;

      const newWindow = window.open(authenticatedUrl, '_blank');
      if (!newWindow) {
        throw new Error('팝업이 차단되었습니다. 팝업 차단을 해제해주세요.');
      }
      newWindow.opener = null;
    } catch (error) {
      console.error('File view error:', error);
      setError(error.message || '파일 보기 중 오류가 발생했습니다.');
    }
  };

  const renderImagePreview = (originalname) => {
    try {
      if (!msg?.file?.filename) {
        return (
          <div className="flex items-center justify-center h-full bg-gray-100">
            <Image className="w-8 h-8 text-gray-400" />
          </div>
        );
      }

      const user = authService.getCurrentUser();
      if (!user?.token || !user?.sessionId) {
        throw new Error('인증 정보가 없습니다.');
      }

      const previewUrl = fileService.getPreviewUrl(msg.file, true);

      return (
        <div className="bg-transparent-pattern">
          <img 
            src={previewUrl}
            alt={originalname}
            className="object-cover rounded-sm"
            onLoad={() => {
              console.debug('Image loaded successfully:', originalname);
            }}
            onError={(e) => {
              console.error('Image load error:', {
                error: e.error,
                originalname
              });
              e.target.onerror = null; 
              e.target.src = '/images/placeholder-image.png';
              setError('이미지를 불러올 수 없습니다.');
            }}
            loading="lazy"
          />
        </div>
      );
    } catch (error) {
      console.error('Image preview error:', error);
      setError(error.message || '이미지 미리보기를 불러올 수 없습니다.');
      return (
        <div className="flex items-center justify-center h-full bg-gray-100">
          <Image className="w-8 h-8 text-gray-400" />
        </div>
      );
    }
  };

  const renderFilePreview = () => {
    const mimetype = msg.file?.mimetype || '';
    const originalname = getDecodedFilename(msg.file?.originalname || 'Unknown File');
    const size = fileService.formatFileSize(msg.file?.size || 0);
    
    const FileActions = () => (
      <div className="file-actions mt-2 pt-2 border-t border-gray-200">
        <Button
          onClick={handleViewInNewTab}
          className="file-action-button hover:bg-gray-100"
          title="새 탭에서 보기"
        >
          <ExternalLink size={16} />
          <span>새 탭에서 보기</span>
        </Button>
        <Button
          onClick={handleFileDownload}
          className="file-action-button hover:bg-gray-100"
          title="다운로드"
        >
          <Download size={16} />
          <span>다운로드</span>
        </Button>
      </div>
    );

    const previewWrapperClass = 
      "overflow-hidden";
    const fileInfoClass = 
      "flex items-center gap-3 p-1 mt-2";

    if (mimetype.startsWith('image/')) {
      return (
        <div className={previewWrapperClass}>
          {renderImagePreview(originalname)}
          <div className={fileInfoClass}>
            <div className="flex-1 min-w-0">
              <div className="font-medium truncate">{getFileIcon()} {originalname}</div>
              <Text typography="body2" as="span">{size}</Text>
            </div>
          </div>
          <FileActions />
        </div>
      );
    }

    if (mimetype.startsWith('video/')) {
      return (
        <div className={previewWrapperClass}>
          <div>
            {previewUrl ? (
              <video 
                className="object-cover rounded-sm"
                controls
                preload="metadata"
                aria-label={`${originalname} 비디오`}
                crossOrigin="use-credentials"
              >
                <source src={previewUrl} type={mimetype} />
                <track kind="captions" />
                비디오를 재생할 수 없습니다.
              </video>
            ) : (
              <div className="flex items-center justify-center h-full">
                <Film className="w-8 h-8 text-gray-400" />
              </div>
            )}
          </div>
          <div className={fileInfoClass}>
            <div className="flex-1 min-w-0">
              <div className="font-medium truncate">{getFileIcon()} {originalname}</div>
              <Text typography="body2" as="span">{size}</Text>
            </div>
          </div>
          <FileActions />
        </div>
      );
    }

    if (mimetype.startsWith('audio/')) {
      return (
        <div className={previewWrapperClass}>
          <div className={fileInfoClass}>
            <div className="flex-1 min-w-0">
              <div className="font-medium truncate">{getFileIcon()} {originalname}</div>
              <Text typography="body2" as="span">{size}</Text>
            </div>
          </div>
          <div className="px-3 pb-3">
            {previewUrl && (
              <audio 
                className="w-full"
                controls
                preload="metadata"
                aria-label={`${originalname} 오디오`}
                crossOrigin="use-credentials"
              >
                <source src={previewUrl} type={mimetype} />
                오디오를 재생할 수 없습니다.
              </audio>
            )}
          </div>
          <FileActions />
        </div>
      );
    }

    return (
      <div className={previewWrapperClass}>
        <div className={fileInfoClass}>
          <div className="flex-1 min-w-0">
            <div className="font-medium truncate">{getFileIcon()} {originalname}</div>
            <Text typography="body2" as="span">{size}</Text>
          </div>
        </div>
        <FileActions />
      </div>
    );
  };

  return (
    <div className="messages">
      <div className={`message-group ${isMine ? 'mine' : 'yours'}`}>
        <div className="message-sender-info">
          {renderAvatar()}
          <span className="sender-name">
            {isMine ? '나' : msg.sender?.name}
          </span>
        </div>
        <div className={`message-bubble ${isMine ? 'message-mine' : 'message-other'} last file-message`}>
          <div className="message-content">
            {error && (
              <Alert 
                color="danger" 
                className="mb-3"
                onClose={() => setError(null)}
              >
                <AlertCircle className="w-4 h-4" />
                <span>{error}</span>
              </Alert>
            )}
            {renderFilePreview()}
            {msg.content && (
              <div className="mt-3">
                <MessageContent content={msg.content} />
              </div>
            )}
          </div>
          <div className="message-footer">
            <div 
              className="message-time mr-3" 
              title={new Date(msg.timestamp).toLocaleString('ko-KR')}
            >
              {formattedTime}
            </div>
            <ReadStatus 
              messageType={msg.type}
              participants={room.participants}
              readers={msg.readers}
              messageId={msg._id}
              messageRef={messageRef}
              currentUserId={currentUser.id}
              socketRef={socketRef}
            />
          </div>
        </div>
        <MessageActions 
          messageId={msg._id}
          messageContent={msg.content}
          reactions={msg.reactions}
          currentUserId={currentUser?.id}
          onReactionAdd={onReactionAdd}
          onReactionRemove={onReactionRemove}
          isMine={isMine}
          room={room}
        />        
      </div>
    </div>
  );
};

FileMessage.defaultProps = {
  msg: {
    file: {
      mimetype: '',
      filename: '',
      originalname: '',
      size: 0
    }
  },
  isMine: false,
  currentUser: null
};

export default React.memo(FileMessage);

<frontend/components/chat/Message/MessageActions.js>
import React, { useState, useCallback, useRef, useEffect } from 'react';
import { SmilePlus, Copy } from 'lucide-react';
import { Button, Tooltip } from '@goorm-dev/vapor-components';
import EmojiPicker from '../EmojiPicker';
import { Toast } from '../../Toast';

const MessageActions = ({ 
  messageId,
  messageContent,
  reactions,
  currentUserId,
  onReactionAdd,
  onReactionRemove,
  isMine = false,
  room = null
}) => {
  const [showEmojiPicker, setShowEmojiPicker] = useState(false);
  const [tooltipStates, setTooltipStates] = useState({});
  const [leftOffset, setLeftOffset] = useState(0);
  const emojiPickerRef = useRef(null);
  const emojiButtonRef = useRef(null);
  const containerRef = useRef(null);
  const reactionRefs = useRef({});
  const rafId = useRef(null);

  const handleClickOutside = useCallback((event) => {
    const isClickInsideEmojiPicker = emojiPickerRef.current?.contains(event.target);
    const isClickOnEmojiButton = emojiButtonRef.current?.contains(event.target);

    if (!isClickInsideEmojiPicker && !isClickOnEmojiButton) {
      setShowEmojiPicker(false);
    }
  }, []);

  useEffect(() => {
    if (showEmojiPicker) {
      document.addEventListener('mousedown', handleClickOutside);
    }

    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
    };
  }, [showEmojiPicker, handleClickOutside]);

  const handleCopy = useCallback(async () => {
    try {
      await navigator.clipboard.writeText(messageContent);
      Toast.success('메시지가 클립보드에 복사되었습니다.');
    } catch (error) {
      console.error('Copy failed:', error);
      Toast.error('메시지 복사에 실패했습니다.');
    }
  }, [messageContent]);

  const handleReactionSelect = useCallback((emoji) => {
    try {
      const emojiChar = emoji.native || emoji;
      const hasReacted = reactions?.[emojiChar]?.includes(currentUserId);

      if (hasReacted) {
        onReactionRemove?.(messageId, emojiChar);
      } else {
        onReactionAdd?.(messageId, emojiChar);
      }
      setShowEmojiPicker(false);
    } catch (error) {
      console.error('Reaction handling error:', error);
    }
  }, [messageId, reactions, currentUserId, onReactionAdd, onReactionRemove]);

  const toggleTooltip = useCallback((emoji) => {
    setTooltipStates(prev => ({
      ...prev,
      [emoji]: !prev[emoji]
    }));
  }, []);

  const getReactionTooltip = useCallback((emoji, userIds) => {
    if (!userIds || !room?.participants) {
      return '';
    }

    // room.participants가 배열인지 확인
    if (!Array.isArray(room.participants)) {
      console.warn('room.participants is not an array:', room.participants);
      return '';
    }

    // 사용자 ID들을 문자열로 변환하여 비교하기 위한 Map 생성
    const participantMap = new Map(
      room.participants.map(p => [
        String(p._id || p.id), 
        p.name
      ])
    );

    const reactionUsers = userIds.map(userId => {
      const userIdStr = String(userId);
      
      // 현재 사용자인 경우
      if (userIdStr === String(currentUserId)) {
        return '나';
      }
      
      // 참여자 목록에서 해당 사용자 찾기
      const userName = participantMap.get(userIdStr);
      return userName || '알 수 없는 사용자';
    });

    // 중복 제거 및 정렬
    const uniqueUsers = [...new Set(reactionUsers)].sort((a, b) => {
      if (a === '나') return -1;
      if (b === '나') return 1;
      return a.localeCompare(b);
    });

    return uniqueUsers.join(', ');
  }, [currentUserId, room]);

  const renderReactions = useCallback(() => {
    if (!reactions || Object.keys(reactions).length === 0) {
      return null;
    }

    return (
      <div className="message-reactions">
        {Object.entries(reactions).map(([emoji, users]) => {
          const reactionId = `reaction-${messageId}-${emoji}`;
          
          if (!reactionRefs.current[emoji]) {
            reactionRefs.current[emoji] = React.createRef();
          }

          const tooltipContent = getReactionTooltip(emoji, users);

          return (
            <React.Fragment key={emoji}>
              <Button
                ref={reactionRefs.current[emoji]}
                id={reactionId}
                className={`reaction-badge ${users.includes(currentUserId) ? 'active' : ''}`}
                onClick={() => handleReactionSelect(emoji)}
                onMouseEnter={() => toggleTooltip(emoji)}
                onMouseLeave={() => toggleTooltip(emoji)}
              >
                <span className="reaction-emoji">{emoji}</span>
                <span className="reaction-count">{users.length}</span>
              </Button>
              {tooltipContent && (
                <Tooltip
                  id={reactionId}
                  target={reactionId}
                  placement="top"
                  hideArrow={false}
                  isOpen={tooltipStates[emoji] || false}
                  toggle={() => toggleTooltip(emoji)}
                >
                  {tooltipContent}
                </Tooltip>
              )}
            </React.Fragment>
          );
        })}
      </div>
    );
  }, [reactions, messageId, currentUserId, tooltipStates, handleReactionSelect, toggleTooltip, getReactionTooltip]);

  const toggleEmojiPicker = useCallback((e) => {    
    e.stopPropagation();
    setShowEmojiPicker(prev => !prev);
  }, []);

  return (
    <div className={`flex flex-col ${isMine ? 'items-end' : 'items-start'}`} ref={containerRef}>
      {renderReactions()}
      
      <div className={`message-actions-wrapper ${isMine ? 'mine' : ''}`}>
        <div className="message-actions">
          <div style={{ position: 'relative' }}>
            <Button
              ref={emojiButtonRef}
              size="sm"
              variant="ghost"
              className="action-button"
              onClick={toggleEmojiPicker}
              title="리액션 추가"
            >
              <SmilePlus className="w-4 h-4" />
            </Button>

            {showEmojiPicker && (
              <div 
                ref={emojiPickerRef}
                className={`emoji-picker ${isMine ? 'mine' : ''}`}
                onClick={e => e.stopPropagation()}
              >
                <div className="emoji-picker-container">
                  <EmojiPicker 
                    onSelect={handleReactionSelect}
                    emojiSize={20}
                    perLine={8}
                    theme="light"
                  />
                </div>
              </div>
            )}
            <Button
              size="sm"
              variant="ghost"
              className="action-button"
              onClick={handleCopy}
              title="메시지 복사"
            >
              <Copy className="w-4 h-4" />
            </Button>            
          </div>
        </div>
      </div>
    </div>
  );
};

MessageActions.defaultProps = {
  messageId: '',
  messageContent: '',
  reactions: {},
  currentUserId: null,
  onReactionAdd: () => {},
  onReactionRemove: () => {},
  isMine: false,
  room: null
};

export default React.memo(MessageActions);

<frontend/components/chat/Message/MessageContent.js>
import React, { useMemo, useCallback, useState } from 'react';
import ReactMarkdown from 'react-markdown';
import remarkGfm from 'remark-gfm';
import remarkBreaks from 'remark-breaks';
import remarkEmoji from 'remark-emoji';
import { Prism as SyntaxHighlighter } from 'react-syntax-highlighter';
import { tomorrow } from 'react-syntax-highlighter/dist/cjs/styles/prism';
import { Copy, Check } from 'lucide-react';
import { Toast } from '../../Toast';

const MessageContent = ({ content, isAI = false }) => {
  const [copyingMap, setCopyingMap] = useState(new Map());

  // 복사 기능 구현
  const copyToClipboard = useCallback(async (text, blockId) => {
    try {
      await navigator.clipboard.writeText(text);
      setCopyingMap(prev => new Map(prev).set(blockId, true));
      Toast.success('코드가 클립보드에 복사되었습니다.');

      // 1초 후 복사 상태 초기화
      setTimeout(() => {
        setCopyingMap(prev => {
          const newMap = new Map(prev);
          newMap.delete(blockId);
          return newMap;
        });
      }, 1000);
    } catch (err) {
      console.error('Failed to copy:', err);
      Toast.error('복사에 실패했습니다.');
    }
  }, []);

  // 멘션 패턴을 찾아서 React 엘리먼트로 변환하는 함수
  const renderContentWithMentions = useMemo(() => (text) => {
    const mentionPattern = /@(wayneAI|consultingAI|[\w.-]+)/g;
    const parts = [];
    let lastIndex = 0;
    let match;

    while ((match = mentionPattern.exec(text)) !== null) {
      if (match.index > lastIndex) {
        parts.push(
          <span key={`text-${lastIndex}`}>
            {text.slice(lastIndex, match.index)}
          </span>
        );
      }

      const mentionedName = match[1];
      const isAIMention = mentionedName === 'wayneAI' || mentionedName === 'consultingAI';
      const displayName = isAIMention 
        ? (mentionedName === 'wayneAI' ? 'Wayne AI' : 'Consulting AI')
        : mentionedName;

      const mentionClass = isAIMention 
        ? `mention mention-bot ${mentionedName === 'wayneAI' ? 'mention-wayne' : 'mention-consulting'}`
        : 'mention mention-user';

      parts.push(
        <span
          key={`mention-${match.index}`}
          className={mentionClass}
        >
          @{displayName}
        </span>
      );

      lastIndex = match.index + match[0].length;
    }

    if (lastIndex < text.length) {
      parts.push(
        <span key={`text-${lastIndex}`}>
          {text.slice(lastIndex)}
        </span>
      );
    }

    return parts;
  }, []);

  // 마크다운 렌더링을 위한 커스텀 컴포넌트
  const components = useMemo(() => ({
    p: ({ children }) => {
      if (
        children.length === 1 && 
        typeof children[0] === 'string' && 
        !children[0].includes('\n')
      ) {
        return <p>{renderContentWithMentions(children[0])}</p>;
      }
      return <p>{children}</p>;
    },
    code({ node, inline, className, children, ...props }) {
      const match = /language-(\w+)/.exec(className || '');
      const blockId = Math.random().toString(36).substr(2, 9);

      return !inline && match ? (
        <div className="relative group">
          <button
            onClick={() => copyToClipboard(String(children).replace(/\n$/, ''), blockId)}
            className="absolute right-2 top-2 p-2 rounded bg-gray-800/50 hover:bg-gray-800/80 transition-all duration-200 opacity-0 group-hover:opacity-100 z-10"
            title="코드 복사"
          >
            {copyingMap.get(blockId) ? (
              <Check className="w-4 h-4 text-green-400" />
            ) : (
              <Copy className="w-4 h-4 text-gray-300" />
            )}
          </button>
          <SyntaxHighlighter
            style={tomorrow}
            language={match[1]}
            PreTag="div"
            showLineNumbers={true}
            wrapLines={true}
            {...props}
          >
            {String(children).replace(/\n$/, '')}
          </SyntaxHighlighter>
        </div>
      ) : (
        <code
          className="rounded px-1.5 py-0.5 text-sm bg-black/10"
          {...props}
        >
          {children}
        </code>
      );
    },
    h1: ({ node, children, ...props }) => (
      <h1 className="md-heading md-h1" {...props}>
        {children}
      </h1>
    ),
    h2: ({ node, children, ...props }) => (
      <h2 className="md-heading md-h2" {...props}>
        {children}
      </h2>
    ),
    h3: ({ node, children, ...props }) => (
      <h3 className="md-heading md-h3" {...props}>
        {children}
      </h3>
    ),
    ul: ({ node, children, ...props }) => (
      <ul className="md-list md-ul" {...props}>
        {children}
      </ul>
    ),
    ol: ({ node, children, ...props }) => (
      <ol className="md-list md-ol" {...props}>
        {children}
      </ol>
    ),
    li: ({ node, children, ...props }) => {
      // 체크박스가 포함된 리스트 아이템인지 확인
      const hasCheckbox = node.children.some(child => 
        child.type === 'element' && 
        child.tagName === 'input' && 
        child.properties.type === 'checkbox'
      );

      return (
        <li 
          className={`md-list-item ${hasCheckbox ? 'list-none' : ''}`} 
          {...props}
        >
          {children}
        </li>
      );
	  },
    a: ({ node, children, href, ...props }) => (
      <a
        href={href}
        target="_blank"
        rel="noopener noreferrer"
        className="md-link"
        {...props}
      >
        {children}
      </a>
    ),
    img: ({ node, src, alt, ...props }) => (
      <img
        src={src}
        alt={alt}
        className="md-image"
        loading="lazy"
        onError={(e) => {
          e.target.src = '/placeholder-image.png';
        }}
        {...props}
      />
    ),
    table: ({ node, children, ...props }) => (
      <div className="md-table-wrapper">
        <table className="md-table" {...props}>
          {children}
        </table>
      </div>
    ),
    blockquote: ({ node, children, ...props }) => (
      <blockquote className="md-blockquote" {...props}>
        {children}
      </blockquote>
    ),
    em: ({ node, children, ...props }) => (
      <em className="md-italic" {...props}>
        {children}
      </em>
    ),
    strong: ({ node, children, ...props }) => (
      <strong className="md-bold" {...props}>
        {children}
      </strong>
    )
  }), [renderContentWithMentions, copyToClipboard, copyingMap]);

  // 순수 텍스트 내용 여부 확인
  const isPlainText = useMemo(() => {
    return typeof content === 'string' && 
           !content.includes('```') && 
           !content.includes('`') && 
           !content.includes('#') && 
           !content.includes('*') && 
           !content.includes('_') && 
           !content.includes('[') && 
           !content.includes('|');
  }, [content]);

  if (typeof content !== 'string') {
    return String(content);
  }

  // 순수 텍스트이면서 멘션이 포함된 경우 직접 렌더링
  if (isPlainText && content.includes('@')) {
    return <div className="message-text">{renderContentWithMentions(content)}</div>;
  }

  // 마크다운 콘텐츠의 경우 ReactMarkdown 사용
  return (
    <ReactMarkdown
      remarkPlugins={[remarkGfm, remarkBreaks, remarkEmoji]}
      components={components}
    >
      {content}
    </ReactMarkdown>
  );
};

export default React.memo(MessageContent);

<frontend/components/chat/Message/SystemMessage.js>
import React from 'react';

const SystemMessage = ({ msg }) => {
  const formattedTime = new Date(msg.timestamp).toLocaleString('ko-KR', {
    year: 'numeric',
    month: 'long',
    day: 'numeric',
    hour: '2-digit',
    minute: '2-digit',
    second: '2-digit',
    hour12: false
  }).replace(/\./g, '년').replace(/\s/g, ' ').replace('일 ', '일 ');

  console.log(formattedTime);
  
  return (
    <div className="message-system">
      {msg.content}
      {formattedTime && (
        <div className="message-time">
          {formattedTime}
        </div>
      )}
    </div>
  );
};

export default React.memo(SystemMessage);

<frontend/components/chat/Message/UserMessage.js>
import React, { useMemo } from 'react';
import MessageContent from './MessageContent';
import MessageActions from './MessageActions';
import PersistentAvatar from '../../common/PersistentAvatar';
import ReadStatus from '../ReadStatus';
import { generateColorFromEmail, getContrastTextColor } from '../../../utils/colorUtils';

const UserMessage = ({
  msg = {}, 
  isMine = false, 
  currentUser = null,
  onReactionAdd,
  onReactionRemove,
  room = null,
  messageRef,
  socketRef
}) => {
  const formattedTime = new Date(msg.timestamp).toLocaleString('ko-KR', {
    year: 'numeric',
    month: 'long',
    day: 'numeric',
    hour: '2-digit',
    minute: '2-digit',
    second: '2-digit',
    hour12: false
  }).replace(/\./g, '년').replace(/\s/g, ' ').replace('일 ', '일 ');

  // 아바타 스타일을 메모이제이션
  const avatarStyles = useMemo(() => {
    const email = isMine ? currentUser?.email : msg.sender?.email;
    if (!email) return {};
    const backgroundColor = generateColorFromEmail(email);
    const color = getContrastTextColor(backgroundColor);
    return { backgroundColor, color };
  }, [isMine, currentUser?.email, msg.sender?.email]);

  const user = isMine ? currentUser : msg.sender;

  return (
    <div className="messages">
      <div className={`message-group ${isMine ? 'mine' : 'yours'}`}>
        <div className="message-sender-info">
          <PersistentAvatar
            user={user}
            size="lg"
            style={avatarStyles}
            showInitials={true}
          />
          <span className="sender-name">
            {isMine ? '나' : msg.sender?.name}
          </span>
        </div>
        <div className={`message-bubble ${isMine ? 'message-mine' : 'message-other'} last relative group`}>
          <div className="message-content">
            <MessageContent content={msg.content} />
          </div>
          <div className="message-footer">
            <div className="message-time mr-3">
              {formattedTime}
            </div>
            <ReadStatus 
              messageType={msg.type}
              participants={room.participants}
              readers={msg.readers}
              messageId={msg._id}
              messageRef={messageRef}
              currentUserId={currentUser.id}
              socketRef={socketRef}
            />            
          </div>
        </div>
          
        <MessageActions 
          messageId={msg._id}
          messageContent={msg.content}
          reactions={msg.reactions}
          currentUserId={currentUser?.id}
          onReactionAdd={onReactionAdd}
          onReactionRemove={onReactionRemove}
          isMine={isMine}
          room={room}
        />
      </div>
    </div>
  );
};

UserMessage.defaultProps = {
  msg: {},
  isMine: false,
  currentUser: null,
  onReactionAdd: () => {},
  onReactionRemove: () => {},
  room: null
};

export default React.memo(UserMessage);

<frontend/components/chat/Message/index.js>
export { default as SystemMessage } from './SystemMessage';
export { default as FileMessage } from './FileMessage';
export { default as UserMessage } from './UserMessage';
export { default as AIMessage } from './AIMessage';


<frontend/components/chat/ReadStatus.js>
import React, { useMemo, useEffect, useState, useCallback, useRef } from 'react';
import { Text, Tooltip } from '@goorm-dev/vapor-components';
import { CheckCheck, Check } from 'lucide-react';

const ReadStatus = ({ 
  messageType = 'text',
  participants = [],
  readers = [],
  className = '',
  socketRef = null,
  messageId = null,
  messageRef = null, // 메시지 요소의 ref 추가
  currentUserId = null // 현재 사용자 ID 추가
}) => {
  const [currentReaders, setCurrentReaders] = useState(readers || []);
  const [tooltipOpen, setTooltipOpen] = useState(false);
  const [hasMarkedAsRead, setHasMarkedAsRead] = useState(false);
  const statusRef = useRef(null);
  const observerRef = useRef(null);

  // 읽지 않은 참여자 명단 생성 
  const unreadParticipants = useMemo(() => {
    if (messageType === 'system') return [];
    
    return participants.filter(participant => 
      !currentReaders.some(reader => 
        reader.userId === participant._id || 
        reader.userId === participant.id
      )
    );
  }, [participants, currentReaders, messageType]);

  // 읽지 않은 참여자 수 계산
  const unreadCount = useMemo(() => {
    if (messageType === 'system') {
      return 0;
    }
    return unreadParticipants.length;
  }, [unreadParticipants.length, messageType]);

  // 메시지를 읽음으로 표시하는 함수
  const markMessageAsRead = useCallback(async () => {
    if (!messageId || !currentUserId || hasMarkedAsRead || 
        messageType === 'system' || !socketRef?.current) {
      return;
    }

    try {
      // Socket.IO를 통해 서버에 읽음 상태 전송
      socketRef.current.emit('markMessagesAsRead', {
        messageIds: [messageId]
      });

      setHasMarkedAsRead(true);

      // 현재 사용자를 읽은 목록에 추가
      setCurrentReaders(prev => {
        if (prev.some(reader => reader.userId === currentUserId)) {
          return prev;
        }
        return [...prev, {
          userId: currentUserId,
          readAt: new Date()
        }];
      });

    } catch (error) {
      console.error('Error marking message as read:', error);
    }
  }, [messageId, currentUserId, hasMarkedAsRead, messageType, socketRef]);

  // Intersection Observer 설정
  useEffect(() => {
    if (!messageRef?.current || !currentUserId || hasMarkedAsRead || messageType === 'system') {
      return;
    }

    // 이미 읽은 메시지인지 확인
    const isAlreadyRead = currentReaders.some(reader => 
      reader.userId === currentUserId
    );

    if (isAlreadyRead) {
      setHasMarkedAsRead(true);
      return;
    }

    const observerOptions = {
      root: null,
      rootMargin: '0px',
      threshold: 0.5 // 메시지의 50%가 보여야 읽음으로 처리
    };

    const handleIntersect = (entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting && !hasMarkedAsRead) {
          markMessageAsRead();
        }
      });
    };

    observerRef.current = new IntersectionObserver(handleIntersect, observerOptions);
    observerRef.current.observe(messageRef.current);

    return () => {
      if (observerRef.current) {
        observerRef.current.disconnect();
      }
    };
  }, [messageRef, currentUserId, hasMarkedAsRead, messageType, currentReaders, markMessageAsRead]);

  // 툴팁 텍스트 생성
  const getTooltipText = useCallback(() => {
    if (unreadCount === 0) return "모두 읽음";
    const unreadNames = unreadParticipants.map(p => p.name);
    return `${unreadNames.join(', ')}이 읽지 않음`;
  }, [unreadCount, unreadParticipants]);

  // 읽음 상태 업데이트 핸들러
  const handleReadStatusUpdate = useCallback(({ userId, messageIds, timestamp }) => {
    if (!messageId || !messageIds.includes(messageId)) return;

    setCurrentReaders(prev => {
      if (prev.some(reader => reader.userId === userId)) {
        return prev;
      }
      
      return [...prev, { 
        userId, 
        readAt: timestamp || new Date()
      }];
    });
  }, [messageId]);

  // 참여자 업데이트 핸들러
  const handleParticipantsUpdate = useCallback((updatedParticipants) => {
    setCurrentReaders(prev => 
      prev.filter(reader => 
        updatedParticipants.some(p => 
          p._id === reader.userId || p.id === reader.userId
        )
      )
    );
  }, []);

  // props나 참여자 변경 시 readers 업데이트
  useEffect(() => {
    setCurrentReaders(readers);
  }, [readers]);

  // Socket.IO 이벤트 리스너 설정
  useEffect(() => {
    if (!socketRef?.current) return;

    socketRef.current.on('messagesRead', handleReadStatusUpdate);
    socketRef.current.on('participantsUpdate', handleParticipantsUpdate);

    return () => {
      if (socketRef.current) {
        socketRef.current.off('messagesRead', handleReadStatusUpdate);
        socketRef.current.off('participantsUpdate', handleParticipantsUpdate);
      }
    };
  }, [socketRef, handleReadStatusUpdate, handleParticipantsUpdate]);

  const toggle = () => setTooltipOpen(prev => !prev);

  // 시스템 메시지는 읽음 상태 표시 안 함
  if (messageType === 'system') {
    return null;
  }

  // 모두 읽은 경우
  if (unreadCount === 0) {
    return (
      <div 
        className={`read-status ${className}`}
        ref={statusRef}
        role="status"
        aria-label="모든 참여자가 메시지를 읽었습니다"
      >
        <CheckCheck size={12} className="text-green-400 mr-1" />
        <Text typography="body3" color="green-400">
          모두 읽음
        </Text>
        <Tooltip
          id="read-status-tooltip"
          target={statusRef}
          placement="top"
          hideArrow={false}
          isOpen={tooltipOpen}
          toggle={toggle}
        >
          모두 읽음
        </Tooltip>
      </div>
    );
  }

  // 읽지 않은 사람이 있는 경우
  return (
    <div 
      className={`read-status ${className}`}
      ref={statusRef}
      role="status"
      aria-label={`${unreadCount}명이 메시지를 읽지 않았습니다`}
    >
      <div className="flex items-center gap-1">
        <Check size={12} className="text-gray-700 mr-1" />
        {unreadCount > 0 && (
          <Text typography="body3" color="gray-700">
            {unreadCount}
          </Text>
        )}
      </div>
      <Tooltip
        id="read-status-tooltip"
        target={statusRef}
        placement="top"
        hideArrow={false}
        isOpen={tooltipOpen}
        toggle={toggle}
      >
        {getTooltipText()}
      </Tooltip>
    </div>
  );
};

ReadStatus.displayName = 'ReadStatus';

export default React.memo(ReadStatus);

<frontend/components/common/PersistentAvatar.js>
import React, { useState, useEffect, useCallback, forwardRef } from 'react';
import { Avatar } from '@goorm-dev/vapor-core';
import { getConsistentAvatarStyles } from '../../utils/colorUtils';

const PersistentAvatar = forwardRef(({
  user,
  size = "md",
  className = "",
  onClick,
  showInitials = true,
  ...props
}, ref) => {
  const [currentImage, setCurrentImage] = useState('');
  const [imageError, setImageError] = useState(false);

  // getProfileImageUrl 함수 memoization
  const getProfileImageUrl = useCallback((imagePath) => {
    if (!imagePath) return null;
    return imagePath.startsWith('http') ? 
      imagePath : 
      `${process.env.NEXT_PUBLIC_API_URL}${imagePath}`;
  }, []);

  // 프로필 이미지 URL 처리
  useEffect(() => {
    const imageUrl = getProfileImageUrl(user?.profileImage);
    if (imageUrl && imageUrl !== currentImage) {
      setImageError(false);
      setCurrentImage(imageUrl);
    } else if (!imageUrl) {
      setCurrentImage('');
    }
  }, [user?.profileImage, getProfileImageUrl, currentImage]);

  // 전역 프로필 업데이트 리스너
  useEffect(() => {
    const handleProfileUpdate = () => {
      try {
        const updatedUser = JSON.parse(localStorage.getItem('user') || '{}');
        // 현재 사용자의 프로필이 업데이트된 경우에만 이미지 업데이트
        if (user?.id === updatedUser.id && updatedUser.profileImage !== user.profileImage) {
          const newImageUrl = getProfileImageUrl(updatedUser.profileImage);
          setImageError(false);
          setCurrentImage(newImageUrl);
        }
      } catch (error) {
        console.error('Profile update handling error:', error);
      }
    };
    
    window.addEventListener('userProfileUpdate', handleProfileUpdate);
    return () => {
      window.removeEventListener('userProfileUpdate', handleProfileUpdate);
    };
  }, [getProfileImageUrl, user?.id, user?.profileImage]);

  // 이메일 기반의 일관된 스타일 가져오기
  const avatarStyles = getConsistentAvatarStyles(user?.email);

  const combinedStyles = {
    ...avatarStyles,
    position: 'relative',
    overflow: 'hidden'
  };

  const imageOverlayStyle = {
    backgroundColor: avatarStyles.backgroundColor,
    width: '100%',
    height: '100%',
    objectFit: 'cover',
    borderRadius: 'inherit'
  };

  const handleImageError = (e) => {
    e.preventDefault();
    e.target.style.display = 'none';
    setImageError(true);

    // 이미지 로드 실패 시 이니셜 표시
    if (e.target.parentElement && showInitials) {
      e.target.parentElement.textContent = user?.name?.[0]?.toUpperCase() || '';
      Object.assign(e.target.parentElement.style, avatarStyles);
    }

    // 콘솔에 디버그 정보 출력
    console.debug('Avatar image load failed:', {
      user: user?.name,
      email: user?.email,
      imageUrl: currentImage
    });
  };

  return (
    <Avatar
      ref={ref}
      size={size}
      className={`persistent-avatar ${className}`}
      onClick={onClick}
      style={combinedStyles}
      {...props}
    >
      {currentImage && !imageError ? (
        <Avatar.Image
          src={currentImage}
          alt={`${user?.name}'s profile`}
          style={imageOverlayStyle}
          onError={handleImageError}
          loading="lazy"
        />
      ) : showInitials ? (
        <span 
          style={{ 
            position: 'relative', 
            zIndex: 1,
            fontSize: size === 'sm' ? '0.875rem' : size === 'lg' ? '1.25rem' : '1rem',
            fontWeight: '500'
          }}
          title={user?.name}
        >
          {user?.name?.[0]?.toUpperCase()}
        </span>
      ) : null}
    </Avatar>
  );
});

PersistentAvatar.displayName = 'PersistentAvatar';

export default PersistentAvatar;

<frontend/hooks/useAIMessageHandling.js>
import { useState, useCallback } from 'react';
import { Toast } from '../components/Toast';

export const useAIMessageHandling = (
  socketRef,
  setMessages,
  isNearBottom,
  scrollToBottom
) => {
  const [streamingMessages, setStreamingMessages] = useState({});

  const handleAIMessageStart = useCallback((data) => {
    console.log('AI message stream started:', data.messageId);
    
    setStreamingMessages(prev => ({
      ...prev,
      [data.messageId]: {
        _id: data.messageId,
        type: 'ai',
        aiType: data.aiType,
        content: '',
        timestamp: new Date(data.timestamp),
        isStreaming: true
      }
    }));
    scrollToBottom();
  }, [scrollToBottom]);

  const handleAIMessageChunk = useCallback((data) => {
    if (!data.messageId) {
      console.warn('Received AI message chunk without messageId');
      return;
    }

    console.log('AI message chunk received:', {
      messageId: data.messageId,
      chunkLength: data.fullContent?.length,
      isCodeBlock: data.isCodeBlock
    });

    setStreamingMessages(prev => {
      // 해당 메시지 ID가 없는 경우 무시
      if (!prev[data.messageId]) {
        console.warn('No existing streaming message for chunk:', data.messageId);
        return prev;
      }

      return {
        ...prev,
        [data.messageId]: {
          ...prev[data.messageId],
          content: data.fullContent,
          isCodeBlock: data.isCodeBlock
        }
      };
    });

    if (isNearBottom) {
      scrollToBottom();
    }
  }, [isNearBottom, scrollToBottom]);

  const handleAIMessageComplete = useCallback((data) => {
    console.log('AI message stream completed:', data.messageId);

    setStreamingMessages(prev => {
      const { [data.messageId]: completed, ...rest } = prev;
      return rest;
    });

    setMessages(prev => [...prev, {
      _id: data._id,
      type: 'ai',
      aiType: data.aiType,
      content: data.content,
      timestamp: new Date(data.timestamp),
      isComplete: true
    }]);
    
    scrollToBottom();
  }, [setMessages, scrollToBottom]);

  const handleAIMessageError = useCallback((data) => {
    console.error('AI message error:', data);

    setStreamingMessages(prev => {
      const { [data.messageId]: failed, ...rest } = prev;
      return rest;
    });

    Toast.error(`AI 응답 오류: ${data.error}`);
  }, []);

  // Socket.IO 이벤트 리스너 설정 함수
  const setupAIMessageListeners = useCallback(() => {
    if (!socketRef.current) {
      console.warn('Cannot setup AI message listeners: socket not initialized');
      return;
    }

    const socket = socketRef.current;

    // 기존 리스너 제거
    socket.off('aiMessageStart')
          .off('aiMessageChunk')
          .off('aiMessageComplete')
          .off('aiMessageError');

    // 새 리스너 등록
    socket.on('aiMessageStart', handleAIMessageStart);
    socket.on('aiMessageChunk', handleAIMessageChunk);
    socket.on('aiMessageComplete', handleAIMessageComplete);
    socket.on('aiMessageError', handleAIMessageError);

    return () => {
      socket.off('aiMessageStart')
            .off('aiMessageChunk')
            .off('aiMessageComplete')
            .off('aiMessageError');
    };
  }, [
    socketRef,
    handleAIMessageStart,
    handleAIMessageChunk,
    handleAIMessageComplete,
    handleAIMessageError
  ]);

  // AI 메시지 전송 함수
  const sendAIMessage = useCallback(async (aiType, content) => {
    if (!socketRef.current?.connected) {
      throw new Error('Socket not connected');
    }

    try {
      console.log('Sending AI message:', { aiType, content });
      
      socketRef.current.emit('chatMessage', {
        type: 'ai',
        aiType,
        content: content.trim()
      });

    } catch (error) {
      console.error('Send AI message error:', error);
      Toast.error('AI 메시지 전송에 실패했습니다.');
      throw error;
    }
  }, [socketRef]);

  return {
    streamingMessages,
    setStreamingMessages,
    handleAIMessageStart,
    handleAIMessageChunk,
    handleAIMessageComplete,
    handleAIMessageError,
    setupAIMessageListeners,
    sendAIMessage
  };
};

export default useAIMessageHandling;


<frontend/hooks/useChatRoom.js>
import { useState, useEffect, useRef, useCallback, useMemo } from 'react';
import { useRouter } from 'next/router';
import authService from '../services/authService';
import socketService from '../services/socket';
import { useFileHandling } from './useFileHandling';
import { useMessageHandling } from './useMessageHandling';
import { useReactionHandling } from './useReactionHandling';
import { useAIMessageHandling } from './useAIMessageHandling';
import { useScrollHandling } from './useScrollHandling';
import { useSocketHandling } from './useSocketHandling';
import { useRoomHandling } from './useRoomHandling';
import { Toast } from '../components/Toast';

const CLEANUP_REASONS = {
  DISCONNECT: 'disconnect',
  MANUAL: 'manual',
  RECONNECT: 'reconnect',
  UNMOUNT: 'unmount',
  ERROR: 'error'
};

export const useChatRoom = () => {
  const router = useRouter();
  const [room, setRoom] = useState(null);
  const [messages, setMessages] = useState([]);
  const [currentUser, setCurrentUser] = useState(null);
  const [error, setError] = useState('');
  const [loading, setLoading] = useState(true);
  const [connectionStatus, setConnectionStatus] = useState('checking');
  const [messageLoadError, setMessageLoadError] = useState(null);
  const [isInitialized, setIsInitialized] = useState(false);
  
  // Refs
  const messageInputRef = useRef(null);
  const messageLoadAttemptRef = useRef(0);
  const mountedRef = useRef(true);
  const initializingRef = useRef(false);
  const setupCompleteRef = useRef(false);
  const socketInitializedRef = useRef(false);
  const cleanupInProgressRef = useRef(false);
  const cleanupCountRef = useRef(0);
  const userRooms = useRef(new Map());
  const previousMessagesRef = useRef(new Set());
  const messageProcessingRef = useRef(false);
  const initialLoadCompletedRef = useRef(false);
  const scrollPositionRef = useRef(0);
  const processedMessageIds = useRef(new Set());
  const loadMoreTimeoutRef = useRef(null);
  const previousScrollHeightRef = useRef(0);
  const isLoadingRef = useRef(false);
  const loadMoreTriggeredRef = useRef(false);

  // Socket handling setup
  const {
    connected,
    socketRef,
    handleConnectionError,
    handleReconnect,
    setConnected
  } = useSocketHandling(router);

  // Scroll handling hook
  const {
    isNearBottom,
    hasMoreMessages,
    loadingMessages,
    messagesEndRef,
    scrollToBottom,
    handleScroll,
    setHasMoreMessages,
    setLoadingMessages
  } = useScrollHandling(socketRef, router, messages);  
  
  // AI Message handling hook
  const {
    streamingMessages,
    setStreamingMessages,
    handleAIMessageStart,
    handleAIMessageChunk,
    handleAIMessageComplete,
    handleAIMessageError,
    setupAIMessageListeners
  } = useAIMessageHandling(
    socketRef,
    setMessages,
    isNearBottom,
    scrollToBottom
  );

  // Message handling hook
  const {
    message,
    showEmojiPicker,
    showMentionList,
    mentionFilter,
    mentionIndex,
    filePreview,
    uploading,
    uploadProgress,
    uploadError,
    setMessage,
    setShowEmojiPicker,
    setShowMentionList,
    setMentionFilter,
    setMentionIndex,
    setFilePreview,
    handleMessageChange,
    handleMessageSubmit,
    handleLoadMore,
    handleEmojiToggle,
    getFilteredParticipants,
    insertMention,
    removeFilePreview
  } = useMessageHandling(socketRef, currentUser, router);

  // Cleanup 함수 수정
  const cleanup = useCallback((reason = 'MANUAL') => {
    if (!mountedRef.current || !router.query.room) return;

    try {
      // cleanup이 이미 진행 중인지 확인
      if (cleanupInProgressRef.current) {
        console.log('[Chat] Cleanup already in progress, skipping...');
        return;
      }

      cleanupInProgressRef.current = true;
      console.log(`[Chat] Starting cleanup (reason: ${reason})`);

      // Socket cleanup
      if (reason !== 'UNMOUNT' && router.query.room && socketRef.current?.connected) {
        console.log('[Chat] Emitting leaveRoom event');
        socketRef.current.emit('leaveRoom', router.query.room);
      }

      if (socketRef.current && reason !== 'RECONNECT') {
        console.log('[Chat] Cleaning up socket listeners...');
        socketRef.current.off('message');
        socketRef.current.off('previousMessages');
        socketRef.current.off('previousMessagesLoaded');
        socketRef.current.off('aiMessageStart');
        socketRef.current.off('aiMessageChunk');
        socketRef.current.off('aiMessageComplete');
        socketRef.current.off('aiMessageError');
        socketRef.current.off('messageReactionUpdate');
        socketRef.current.off('session_ended');
        socketRef.current.off('error');
      }

      // Clear timeouts
      if (loadMoreTimeoutRef.current) {
        clearTimeout(loadMoreTimeoutRef.current);
        loadMoreTimeoutRef.current = null;
      }

      // Reset refs
      processedMessageIds.current.clear();
      previousMessagesRef.current.clear();
      messageProcessingRef.current = false;

      // Reset states only if needed
      if (reason === 'MANUAL' && mountedRef.current) {
        setStreamingMessages({});
        setError(null);
        setLoading(false);
        setLoadingMessages(false);
        setMessages([]);
        
        if (userRooms.current.size > 0) {
          userRooms.current.clear();
        }
      } else if (reason === 'DISCONNECT' && mountedRef.current) {
        setError('채팅 연결이 끊어졌습니다. 재연결을 시도합니다.');
      }

      console.log(`[Chat] Cleanup completed (reason: ${reason})`);

    } catch (error) {
      console.error('[Chat] Cleanup error:', error);
      if (mountedRef.current) {
        setError('채팅방 정리 중 오류가 발생했습니다.');
      }
    } finally {
      cleanupInProgressRef.current = false;
    }
  }, [
    setMessages, 
    setStreamingMessages, 
    setError, 
    setLoading, 
    setLoadingMessages, 
    mountedRef,
    socketRef,
    router.query.room
  ]);
  
  // Connection state utility
  const getConnectionState = useCallback(() => {
    if (!socketRef.current) return 'disconnected';
    if (loading) return 'connecting';
    if (error) return 'error';
    return socketRef.current.connected ? 'connected' : 'disconnected';
  }, [loading, error, socketRef]);

  // Reaction handling hook
  const {
    handleReactionAdd,
    handleReactionRemove,
    handleReactionUpdate
  } = useReactionHandling(socketRef, currentUser, messages, setMessages);

  // 메시지 처리 유틸리티 함수
  const processMessages = useCallback((loadedMessages, hasMore, isInitialLoad = false) => {
    try {
      if (!Array.isArray(loadedMessages)) {
        throw new Error('Invalid messages format');
      }

      setMessages(prev => {
        // 중복 메시지 필터링 개선
        const newMessages = loadedMessages.filter(msg => {
          if (!msg._id) return false;
          if (processedMessageIds.current.has(msg._id)) return false;
          processedMessageIds.current.add(msg._id);
          return true;
        });

        // 기존 메시지와 새 메시지 결합 및 정렬
        const allMessages = [...prev, ...newMessages].sort((a, b) => {
          return new Date(a.timestamp || 0) - new Date(b.timestamp || 0);
        });

        // 중복 제거 (가장 최근 메시지 유지)
        const messageMap = new Map();
        allMessages.forEach(msg => messageMap.set(msg._id, msg));
        return Array.from(messageMap.values());
      });

      // 메시지 로드 상태 업데이트
      if (isInitialLoad) {
        setHasMoreMessages(hasMore);
        initialLoadCompletedRef.current = true;
        if (isNearBottom) {
          requestAnimationFrame(() => scrollToBottom('auto'));
        }
      } else {
        setHasMoreMessages(hasMore);
      }

    } catch (error) {
      console.error('Message processing error:', error);
      throw error;
    }
  }, [setMessages, setHasMoreMessages, isNearBottom, scrollToBottom]);

  // 이전 메시지 로드 함수
  const loadPreviousMessages = useCallback(async () => {
    if (!socketRef.current?.connected || loadingMessages) {
      console.warn('Cannot load messages: Socket not connected or already loading');
      return;
    }

    try {
      setLoadingMessages(true);
      const firstMessageTimestamp = messages[0]?.timestamp;

      if (loadMoreTimeoutRef.current) {
        clearTimeout(loadMoreTimeoutRef.current);
      }

      const responsePromise = new Promise((resolve, reject) => {
        socketRef.current.emit('fetchPreviousMessages', {
          roomId: router?.query?.room,
          before: firstMessageTimestamp
        });

        socketRef.current.once('previousMessagesLoaded', resolve);
        socketRef.current.once('error', reject);
      });

      const timeoutPromise = new Promise((_, reject) => {
        loadMoreTimeoutRef.current = setTimeout(() => {
          reject(new Error('Message loading timed out'));
        }, 10000);
      });

      const response = await Promise.race([responsePromise, timeoutPromise]);

      if (response.messages) {
        processMessages(response.messages, response.hasMore, false);
      }

    } catch (error) {
      console.error('Load previous messages error:', error);
      Toast.error('이전 메시지를 불러오는데 실패했습니다.');
      setHasMoreMessages(false);
    } finally {
      setLoadingMessages(false);
      if (loadMoreTimeoutRef.current) {
        clearTimeout(loadMoreTimeoutRef.current);
      }
    }
  }, [socketRef, router?.query?.room, loadingMessages, messages, processMessages, setHasMoreMessages]);

  // Event listeners setup
  const setupEventListeners = useCallback(() => {
    if (!socketRef.current || !mountedRef.current) return;

    console.log('Setting up event listeners...');

    // 메시지 이벤트
    socketRef.current.on('message', message => {
      if (!message || !mountedRef.current || messageProcessingRef.current || !message._id) return;
      
      if (processedMessageIds.current.has(message._id)) {
        return;
      }

      console.log('Received message:', message);
      processedMessageIds.current.add(message._id);

      setMessages(prev => {
        if (prev.some(msg => msg._id === message._id)) {
          return prev;
        }
        return [...prev, message];
      });

      if (isNearBottom) {
        scrollToBottom();
      }
    });

    // 이전 메시지 이벤트
    socketRef.current.on('previousMessages', (response) => {
      if (!mountedRef.current || messageProcessingRef.current) return;
      
      try {
        messageProcessingRef.current = true;
        console.log('Previous messages response:', response);

        if (!response || typeof response !== 'object') {
          throw new Error('Invalid response format');
        }

        const { messages: loadedMessages = [], hasMore } = response;
        const isInitialLoad = messages.length === 0;

        processMessages(loadedMessages, hasMore, isInitialLoad);
        setLoadingMessages(false);

      } catch (error) {
        console.error('Error processing messages:', error);
        setLoadingMessages(false);
        setError('메시지 처리 중 오류가 발생했습니다.');
        setHasMoreMessages(false);
      } finally {
        messageProcessingRef.current = false;
      }
    });

    setupAIMessageListeners();

    // 리액션 이벤트
    socketRef.current.on('messageReactionUpdate', (data) => {
      if (!mountedRef.current) return;
      handleReactionUpdate(data);
    });

    // 세션 이벤트
    socketRef.current.on('session_ended', () => {
      if (!mountedRef.current) return;
      cleanup();
      authService.logout();
      router.replace('/?error=session_expired');
    });

    socketRef.current.on('error', (error) => {
      if (!mountedRef.current) return;
      console.error('Socket error:', error);
      setError(error.message || '채팅 연결에 문제가 발생했습니다.');
    });

  }, [isNearBottom, scrollToBottom, messages.length, processMessages, setupAIMessageListeners, setHasMoreMessages, cleanup, router, handleReactionUpdate, setLoadingMessages, setError]);

  // Room handling hook initialization
  const {
    setupRoom,
    joinRoom,
    loadInitialMessages,
    fetchRoomData,
    handleSessionError
  } = useRoomHandling(
    socketRef,
    currentUser,
    mountedRef,
    router,
    setRoom,
    setError,
    setMessages,
    setHasMoreMessages,
    setLoadingMessages,
    setLoading,
    setupEventListeners,
    cleanup,
    loading,
    setIsInitialized,
    initializingRef,
    setupCompleteRef,
    userRooms.current,
    processMessages
  );

  // Socket connection monitoring
  useEffect(() => {
    if (!socketRef.current || !currentUser) return;

    const handleConnect = () => {
      if (!mountedRef.current) return;
      console.log('Socket connected successfully');
      setConnectionStatus('connected');
      setConnected(true);
      
      if (router.query.room && !setupCompleteRef.current && 
          !initializingRef.current && !isInitialized) {
        socketInitializedRef.current = true;
        setupRoom().catch(error => {
          console.error('Setup room error:', error);
          setError('채팅방 연결에 실패했습니다.');
        });
      }
    };

    const handleDisconnect = (reason) => {
      if (!mountedRef.current) return;
      console.log('Socket disconnected:', reason);
      setConnectionStatus('disconnected');
      socketInitializedRef.current = false;
      setupCompleteRef.current = false;
    };

    const handleError = (error) => {
      if (!mountedRef.current) return;
      console.error('Socket connection error:', error);
      setConnectionStatus('error');
      setError('채팅 서버와의 연결이 끊어졌습니다.');
    };

    const handleReconnecting = (attemptNumber) => {
      if (!mountedRef.current) return;
      console.log(`Reconnection attempt ${attemptNumber}`);
      setConnectionStatus('connecting');
    };

    const handleReconnectSuccess = () => {
      if (!mountedRef.current) return;
      console.log('Reconnected successfully');
      setConnectionStatus('connected');
      setConnected(true);
      setError('');
      
      // 재연결 시 채팅방 재접속
      if (router.query.room) {
        setupRoom().catch(error => {
          console.error('Room reconnection error:', error);
          setError('채팅방 재연결에 실패했습니다.');
        });
      }
    };

    socketRef.current.on('connect', handleConnect);
    socketRef.current.on('disconnect', handleDisconnect);
    socketRef.current.on('connect_error', handleError);
    socketRef.current.on('reconnecting', handleReconnecting);
    socketRef.current.on('reconnect', handleReconnectSuccess);

    setConnectionStatus(socketRef.current.connected ? 'connected' : 'disconnected');

    return () => {
      if (socketRef.current) {
        socketRef.current.off('connect', handleConnect);
        socketRef.current.off('disconnect', handleDisconnect);
        socketRef.current.off('connect_error', handleError);
        socketRef.current.off('reconnecting', handleReconnecting);
        socketRef.current.off('reconnect', handleReconnectSuccess);
      }
    };
  }, [router.query.room, setupRoom, setConnected, currentUser, isInitialized, setError]);

  // Component initialization and cleanup
  useEffect(() => {
    const initializeChat = async () => {
      if (initializingRef.current) return;
      
      const user = authService.getCurrentUser();
      if (!user) {
        router.replace('/?redirect=' + router.asPath);
        return;
      }

      if (!currentUser) {
        setCurrentUser(user);
      }

      // 채팅방이 있을 때만 초기화 진행
      if (!isInitialized && router.query.room) {
        try {
          initializingRef.current = true;
          console.log('Initializing chat room...');
          await setupRoom();
        } catch (error) {
          console.error('Chat initialization error:', error);
          setError('채팅방 초기화에 실패했습니다.');
        } finally {
          initializingRef.current = false;
        }
      }
    };

    mountedRef.current = true;
    
    // 라우터 쿼리가 준비되면 초기화 진행
    if (router.query.room) {
      initializeChat();
    }

    const tokenCheckInterval = setInterval(() => {
      if (!mountedRef.current) return;
      
      const user = authService.getCurrentUser();
      if (!user) {
        clearInterval(tokenCheckInterval);
        router.replace('/?redirect=' + router.asPath);
      }
    }, 60000);

    return () => {
      console.log('[Chat] Component unmounting...');
      mountedRef.current = false;
      clearInterval(tokenCheckInterval);
      
      if (loadMoreTimeoutRef.current) {
        clearTimeout(loadMoreTimeoutRef.current);
      }

      // Run cleanup only if socket is connected and room exists
      if (socketRef.current?.connected && router.query.room && !cleanupInProgressRef.current) {
        cleanup(CLEANUP_REASONS.UNMOUNT);
      }
    };
  }, [router, cleanup, setupRoom, currentUser, isInitialized, setError]);

  // File handling hook
  const {
    fileInputRef,
    uploading: fileUploading,
    uploadProgress: fileUploadProgress,
    uploadError: fileUploadError,
    handleFileUpload,
    handleFileSelect,
    handleFileDrop,
    removeFilePreview: removeFile
  } = useFileHandling(socketRef, currentUser, router);

  // Enter key handler
  const handleKeyDown = useCallback((e) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      handleMessageSubmit(e);
    }
  }, [handleMessageSubmit]);

  return {
    // State
    room,
    messages,
    streamingMessages,
    error,
    loading,
    connected,
    currentUser,
    message,
    showEmojiPicker,
    showMentionList,
    mentionFilter,
    mentionIndex,
    filePreview,
    uploading,
    uploadProgress,
    uploadError,
    isNearBottom,
    hasMoreMessages,
    loadingMessages,
    
    // Refs
    fileInputRef,
    messageInputRef,
    messagesEndRef,
    socketRef,
    
    // Handlers
    handleMessageChange,
    handleMessageSubmit,
    handleEmojiToggle,
    handleKeyDown,
    handleScroll,
    handleLoadMore: loadPreviousMessages,
    handleConnectionError,
    handleReconnect,
    getFilteredParticipants,
    insertMention,
    scrollToBottom,
    removeFilePreview,
    handleReactionAdd,
    handleReactionRemove,
    cleanup,
    
    // Setters
    setMessage,
    setShowEmojiPicker,
    setShowMentionList,
    setMentionFilter,
    setMentionIndex,
    setStreamingMessages,
    setError,
    
    // Status
    connectionStatus: getConnectionState(),
    messageLoadError,
    
    // Retry handler
    retryMessageLoad: useCallback(() => {
      if (mountedRef.current) {
        messageLoadAttemptRef.current = 0;
        previousMessagesRef.current.clear();
        processedMessageIds.current.clear();
        initialLoadCompletedRef.current = false;
        loadInitialMessages(router.query.room);
      }
    }, [loadInitialMessages, router.query.room])
  };
};

export default useChatRoom;

<frontend/hooks/useFileHandling.js>
import { useState, useEffect, useRef, useCallback } from 'react';
import { Toast } from '../components/Toast';
import fileService from '../services/fileService';

export const useFileHandling = (socketRef, currentUser, router, handleSessionError) => {
  const [filePreview, setFilePreview] = useState(null);
  const [uploading, setUploading] = useState(false);
  const [uploadProgress, setUploadProgress] = useState(0);
  const [uploadError, setUploadError] = useState(null);
  const fileInputRef = useRef(null);

  const handleFileUpload = useCallback(async (file, content = '') => {
    if (!socketRef.current?.connected || !currentUser) {
      Toast.error('채팅 서버와 연결이 끊어졌습니다.');
      return;
    }

    // router.query가 초기화되지 않았을 때 처리
    const roomId = router?.query?.room;
    if (!roomId) {
      Toast.error('채팅방 정보를 찾을 수 없습니다.');
      return;
    }

    try {
      setUploading(true);
      setUploadError(null);
      setUploadProgress(0);

      const uploadResponse = await fileService.uploadFile(
        file,
        (progress) => setUploadProgress(progress)
      );

      if (!uploadResponse.success) {
        throw new Error(uploadResponse.message || '파일 업로드에 실패했습니다.');
      }

      await socketRef.current.emit('chatMessage', {
        room: roomId,
        type: 'file',
        content: content,
        fileData: {
          _id: uploadResponse.data.file._id,
          filename: uploadResponse.data.file.filename,
          originalname: uploadResponse.data.file.originalname,
          mimetype: uploadResponse.data.file.mimetype,
          size: uploadResponse.data.file.size
        }
      });

      setFilePreview(null);
      setUploading(false);
      setUploadProgress(0);

    } catch (error) {
      console.error('File upload error:', error);
      
      if (error.message?.includes('세션') || 
          error.message?.includes('인증') || 
          error.message?.includes('토큰')) {
        await handleSessionError();
        return;
      }

      setUploadError(error.message || '파일 업로드에 실패했습니다.');
      Toast.error(error.message || '파일 업로드에 실패했습니다.');
    } finally {
      setUploading(false);
    }
  }, [socketRef, currentUser, router, handleSessionError]);

  const handleFileSelect = useCallback(async (file) => {
    try {
      // 파일 유효성 검사
      const validationResult = await fileService.validateFile(file);
      if (!validationResult.success) {
        throw new Error(validationResult.message);
      }

      // 미리보기 생성
      const preview = {
        file,
        url: URL.createObjectURL(file),
        name: file.name,
        type: file.type,
        size: file.size
      };

      setFilePreview(preview);
      setUploadError(null);

    } catch (error) {
      console.error('File selection error:', error);
      Toast.error(error.message || '파일 선택 중 오류가 발생했습니다.');
      
      if (fileInputRef.current) {
        fileInputRef.current.value = '';
      }
    }
  }, []);

  const handleFileDrop = useCallback(async (e) => {
    e.preventDefault();
    e.stopPropagation();

    const files = Array.from(e.dataTransfer.files);
    if (files.length === 0) return;

    try {
      await handleFileSelect(files[0]);
    } catch (error) {
      console.error('File drop error:', error);
      Toast.error(error.message || '파일 드롭 중 오류가 발생했습니다.');
    }
  }, [handleFileSelect]);

  const removeFilePreview = useCallback(() => {
    if (filePreview?.url) {
      URL.revokeObjectURL(filePreview.url);
    }
    setFilePreview(null);
    setUploadError(null);
    setUploadProgress(0);

    if (fileInputRef.current) {
      fileInputRef.current.value = '';
    }
  }, [filePreview]);

  const handlePaste = useCallback(async (e) => {
    const items = e.clipboardData?.items;
    if (!items) return;

    const fileItem = Array.from(items).find(
      item => item.kind === 'file' && (
        item.type.startsWith('image/') ||
        item.type.startsWith('video/') ||
        item.type.startsWith('audio/') ||
        item.type === 'application/pdf'
      )
    );

    if (!fileItem) return;

    const file = fileItem.getAsFile();
    if (!file) return;

    try {
      await handleFileSelect(file);
      e.preventDefault();
    } catch (error) {
      console.error('File paste error:', error);
      Toast.error(error.message || '파일 붙여넣기 중 오류가 발생했습니다.');
    }
  }, [handleFileSelect]);

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      if (filePreview?.url) {
        URL.revokeObjectURL(filePreview.url);
      }
    };
  }, [filePreview]);

  return {
    filePreview,
    uploading,
    uploadProgress,
    uploadError,
    fileInputRef,
    setFilePreview,
    setUploading,
    setUploadProgress,
    setUploadError,
    handleFileUpload,
    handleFileSelect,
    handleFileDrop,
    handlePaste,
    removeFilePreview
  };
};

export default useFileHandling;

<frontend/hooks/useMessageHandling.js>
import { useState, useCallback } from 'react';
import { Toast } from '../components/Toast';
import fileService from '../services/fileService';

export const useMessageHandling = (socketRef, currentUser, router, handleSessionError, messages = []) => {
 const [message, setMessage] = useState('');
 const [showEmojiPicker, setShowEmojiPicker] = useState(false);
 const [showMentionList, setShowMentionList] = useState(false);
 const [mentionFilter, setMentionFilter] = useState('');
 const [mentionIndex, setMentionIndex] = useState(0);
 const [filePreview, setFilePreview] = useState(null);
 const [uploading, setUploading] = useState(false);
 const [uploadProgress, setUploadProgress] = useState(0);
 const [uploadError, setUploadError] = useState(null);
 const [loadingMessages, setLoadingMessages] = useState(false);

 const handleMessageChange = useCallback((e) => {
   const newValue = e.target.value;
   setMessage(newValue);

   const cursorPosition = e.target.selectionStart;
   const textBeforeCursor = newValue.slice(0, cursorPosition);
   const atSymbolIndex = textBeforeCursor.lastIndexOf('@');

   if (atSymbolIndex !== -1) {
     const mentionText = textBeforeCursor.slice(atSymbolIndex + 1);
     if (!mentionText.includes(' ')) {
       setMentionFilter(mentionText.toLowerCase());
       setShowMentionList(true);
       setMentionIndex(0);
       return;
     }
   }
   
   setShowMentionList(false);
 }, []);

 const handleLoadMore = useCallback(async () => {
   if (!socketRef.current?.connected) {
     console.warn('Cannot load messages: Socket not connected');
     return;
   }

   try {
     if (loadingMessages) {
       console.log('Already loading messages, skipping...');
       return;
     }

     setLoadingMessages(true);
     const firstMessageTimestamp = messages[0]?.timestamp;

     console.log('Loading more messages:', {
       roomId: router?.query?.room,
       before: firstMessageTimestamp,
       currentMessageCount: messages.length
     });

     // Promise를 반환하도록 수정
     return new Promise((resolve, reject) => {
       const timeout = setTimeout(() => {
         setLoadingMessages(false);
         reject(new Error('Message loading timed out'));
       }, 10000);

       socketRef.current.emit('fetchPreviousMessages', {
         roomId: router?.query?.room,
         before: firstMessageTimestamp
       });

       socketRef.current.once('previousMessagesLoaded', (response) => {
         clearTimeout(timeout);
         setLoadingMessages(false);
         resolve(response);
       });

       socketRef.current.once('error', (error) => {
         clearTimeout(timeout);
         setLoadingMessages(false);
         reject(error);
       });
     });

   } catch (error) {
     console.error('Load more messages error:', error);
     Toast.error('이전 메시지를 불러오는데 실패했습니다.');
     setLoadingMessages(false);
     throw error;
   }
 }, [socketRef, router?.query?.room, loadingMessages, messages]);

 const handleMessageSubmit = useCallback(async (messageData) => {
   if (!socketRef.current?.connected || !currentUser) {
     console.error('[Chat] Cannot send message: Socket not connected');
     Toast.error('채팅 서버와 연결이 끊어졌습니다.');
     return;
   }

   const roomId = router?.query?.room;
   if (!roomId) {
     Toast.error('채팅방 정보를 찾을 수 없습니다.');
     return;
   }

   try {
     console.log('[Chat] Sending message:', messageData);

     if (messageData.type === 'file') {
       setUploading(true);
       setUploadError(null);
       setUploadProgress(0);

       const uploadResponse = await fileService.uploadFile(
         messageData.fileData.file,
         (progress) => setUploadProgress(progress)
       );

       if (!uploadResponse.success) {
         throw new Error(uploadResponse.message || '파일 업로드에 실패했습니다.');
       }

       socketRef.current.emit('chatMessage', {
         room: roomId,
         type: 'file',
         content: messageData.content || '',
         fileData: {
           _id: uploadResponse.data.file._id,
           filename: uploadResponse.data.file.filename,
           originalname: uploadResponse.data.file.originalname,
           mimetype: uploadResponse.data.file.mimetype,
           size: uploadResponse.data.file.size
         }
       });

       setFilePreview(null);
       setMessage('');
       setUploading(false);
       setUploadProgress(0);

     } else if (messageData.content?.trim()) {
       socketRef.current.emit('chatMessage', {
         room: roomId,
         type: 'text',
         content: messageData.content.trim()
       });

       setMessage('');
     }

     setShowEmojiPicker(false);
     setShowMentionList(false);

   } catch (error) {
     console.error('[Chat] Message submit error:', error);

     if (error.message?.includes('세션') || 
         error.message?.includes('인증') || 
         error.message?.includes('토큰')) {
       await handleSessionError();
       return;
     }

     Toast.error(error.message || '메시지 전송 중 오류가 발생했습니다.');
     if (messageData.type === 'file') {
       setUploadError(error.message);
       setUploading(false);
     }
   }
 }, [currentUser, router, handleSessionError, socketRef]);

 const handleEmojiToggle = useCallback(() => {
   setShowEmojiPicker(prev => !prev);
 }, []);

 const getFilteredParticipants = useCallback((room) => {
   if (!room?.participants) return [];

   const allParticipants = [
     {
       _id: 'wayneAI',
       name: 'wayneAI',
       email: 'ai@wayne.ai',
       isAI: true
     },
     {
       _id: 'consultingAI',
       name: 'consultingAI',
       email: 'ai@consulting.ai',
       isAI: true
     },
     ...room.participants
   ];

   return allParticipants.filter(user => 
     user.name.toLowerCase().includes(mentionFilter) ||
     user.email.toLowerCase().includes(mentionFilter)
   );
 }, [mentionFilter]);

 const insertMention = useCallback((messageInputRef, user) => {
   if (!messageInputRef?.current) return;

   const cursorPosition = messageInputRef.current.selectionStart;
   const textBeforeCursor = message.slice(0, cursorPosition);
   const atSymbolIndex = textBeforeCursor.lastIndexOf('@');

   if (atSymbolIndex !== -1) {
     const textBeforeAt = message.slice(0, atSymbolIndex);
     const newMessage = 
       textBeforeAt +
       `@${user.name} ` +
       message.slice(cursorPosition);

     setMessage(newMessage);
     setShowMentionList(false);

     setTimeout(() => {
       const newPosition = atSymbolIndex + user.name.length + 2;
       messageInputRef.current.focus();
       messageInputRef.current.setSelectionRange(newPosition, newPosition);
     }, 0);
   }
 }, [message]);

 const removeFilePreview = useCallback(() => {
   setFilePreview(null);
   setUploadError(null);
   setUploadProgress(0);
 }, []);

 return {
   message,
   showEmojiPicker,
   showMentionList,
   mentionFilter,
   mentionIndex,
   filePreview,
   uploading,
   uploadProgress,
   uploadError,
   loadingMessages,
   setMessage,
   setShowEmojiPicker,
   setShowMentionList,
   setMentionFilter,
   setMentionIndex,
   setFilePreview,
   setLoadingMessages,
   handleMessageChange,
   handleMessageSubmit,
   handleEmojiToggle,
   handleLoadMore,
   getFilteredParticipants,
   insertMention,
   removeFilePreview
 };
};

export default useMessageHandling;

<frontend/hooks/useReactionHandling.js>
// hooks/useReactionHandling.js

import { useCallback, useState } from 'react';
import { Toast } from '../components/Toast';

export const useReactionHandling = (socketRef, currentUser, messages, setMessages) => {
  const [pendingReactions] = useState(new Map());

  const handleReactionAdd = useCallback(async (messageId, reaction) => {
    try {
      if (!socketRef.current?.connected) {
        throw new Error('Socket not connected');
      }

      // 낙관적 업데이트
      setMessages(prevMessages => 
        prevMessages.map(msg => {
          if (msg._id === messageId) {
            const currentReactions = msg.reactions || {};
            const currentUsers = currentReactions[reaction] || [];
            
            // 중복 추가 방지
            if (!currentUsers.includes(currentUser.id)) {
              return {
                ...msg,
                reactions: {
                  ...currentReactions,
                  [reaction]: [...currentUsers, currentUser.id]
                }
              };
            }
          }
          return msg;
        })
      );

      await socketRef.current.emit('messageReaction', {
        messageId,
        reaction,
        type: 'add'
      });

    } catch (error) {
      console.error('Add reaction error:', error);
      Toast.error('리액션 추가에 실패했습니다.');

      // 실패 시 롤백
      setMessages(prevMessages => 
        prevMessages.map(msg => 
          msg._id === messageId ? 
          { ...msg, reactions: messages.find(m => m._id === messageId)?.reactions || {} } : 
          msg
        )
      );
    }
  }, [socketRef, currentUser, messages, setMessages]);

  const handleReactionRemove = useCallback(async (messageId, reaction) => {
    try {
      if (!socketRef.current?.connected) {
        throw new Error('Socket not connected');
      }

      // 낙관적 업데이트
      setMessages(prevMessages => 
        prevMessages.map(msg => {
          if (msg._id === messageId) {
            const currentReactions = msg.reactions || {};
            const currentUsers = currentReactions[reaction] || [];
            return {
              ...msg,
              reactions: {
                ...currentReactions,
                [reaction]: currentUsers.filter(id => id !== currentUser.id)
              }
            };
          }
          return msg;
        })
      );

      await socketRef.current.emit('messageReaction', {
        messageId,
        reaction,
        type: 'remove'
      });

    } catch (error) {
      console.error('Remove reaction error:', error);
      Toast.error('리액션 제거에 실패했습니다.');

      // 실패 시 롤백
      setMessages(prevMessages => 
        prevMessages.map(msg => 
          msg._id === messageId ? 
          { ...msg, reactions: messages.find(m => m._id === messageId)?.reactions || {} } : 
          msg
        )
      );
    }
  }, [socketRef, currentUser, messages, setMessages]);

  const handleReactionUpdate = useCallback(({ messageId, reactions }) => {
    setMessages(prevMessages => 
      prevMessages.map(msg => 
        msg._id === messageId ? { ...msg, reactions } : msg
      )
    );
  }, [setMessages]);

  return {
    handleReactionAdd,
    handleReactionRemove,
    handleReactionUpdate
  };
};

export default useReactionHandling;

<frontend/hooks/useRoomHandling.js>
import { useRef, useEffect, useCallback } from 'react';
import socketService from '../services/socket';
import authService from '../services/authService';
import { Toast } from '../components/Toast';

export const useRoomHandling = (
  socketRef,
  currentUser,
  mountedRef,
  router,
  setRoom,
  setError,
  setMessages,
  setHasMoreMessages,
  setLoadingMessages,
  setLoading,
  setupEventListeners,
  cleanup,
  loading,
  setIsInitialized,
  initializingRef,
  setupCompleteRef,
  userRooms,
  processMessages
) => {
  const setupPromiseRef = useRef(null);
  const setupTimeoutRef = useRef(null);
  const joinTimeoutRef = useRef(null);
  const reconnectTimeoutRef = useRef(null);
  const socketReconnectAttempts = useRef(0);
  const messageRetryCountRef = useRef(0);
  const MAX_SOCKET_RECONNECT_ATTEMPTS = 5;
  const MAX_MESSAGE_RETRY_ATTEMPTS = 3;
  const MESSAGE_TIMEOUT = 30000;
  const MESSAGE_RETRY_DELAY = 2000;

  const clearAllTimeouts = useCallback(() => {
    if (setupTimeoutRef.current) {
      clearTimeout(setupTimeoutRef.current);
      setupTimeoutRef.current = null;
    }
    if (joinTimeoutRef.current) {
      clearTimeout(joinTimeoutRef.current);
      joinTimeoutRef.current = null;
    }
    if (reconnectTimeoutRef.current) {
      clearTimeout(reconnectTimeoutRef.current);
      reconnectTimeoutRef.current = null;
    }
  }, []);

  const handleSessionError = async () => {
    try {
      const user = authService.getCurrentUser();
      if (!user) {
        throw new Error('No user session found');
      }

      const refreshed = await authService.refreshToken();
      if (refreshed && mountedRef.current) {
        return true;
      }
    } catch (error) {
      console.error('Token refresh failed:', error);
    }
    
    if (mountedRef.current) {
      await authService.logout();
      router.replace('/?redirect=' + router.asPath);
    }
    return false;
  };

  const setupSocket = useCallback(async () => {
    try {
      const user = authService.getCurrentUser();
      if (!user?.token || !user?.sessionId) {
        throw new Error('Invalid authentication state');
      }

      if (socketRef.current?.connected) {
        console.log('Reusing existing socket connection');
        return socketRef.current;
      }

      if (socketRef.current) {
        console.log('Cleaning up existing socket');
        const currentSocket = socketRef.current;

        if (userRooms?.get(currentSocket.id)) {
          await new Promise((resolve) => {
            currentSocket.emit('leaveRoom', userRooms.get(currentSocket.id));
            setTimeout(resolve, 1000);
          });
          userRooms.delete(currentSocket.id);
        }

        currentSocket.disconnect();
        currentSocket.removeAllListeners();
        socketRef.current = null;

        await new Promise(resolve => setTimeout(resolve, 2000));
      }

      const socket = await socketService.connect({
        auth: {
          token: user.token,
          sessionId: user.sessionId
        },
        transports: ['websocket', 'polling'],
        reconnection: true,
        reconnectionAttempts: MAX_SOCKET_RECONNECT_ATTEMPTS,
        reconnectionDelay: 1000,
        reconnectionDelayMax: 5000,
        timeout: 30000,
        pingTimeout: 30000,
        pingInterval: 25000,
        forceNew: true,
        autoConnect: true
      });

      return new Promise((resolve, reject) => {
        let socketConnected = false;
        const connectionTimeout = setTimeout(() => {
          if (!socketConnected) {
            cleanup();
            reject(new Error('Socket connection timeout'));
          }
        }, 30000);

        const handleConnect = () => {
          if (!socketConnected) {
            socketConnected = true;
            clearTimeout(connectionTimeout);
            socket.removeListener('connect_error', handleError);
            socket.removeListener('error', handleError);
            socketReconnectAttempts.current = 0;
            resolve(socket);
          }
        };

        const handleError = (error) => {
          if (!socketConnected) {
            socketConnected = true;
            clearTimeout(connectionTimeout);
            console.error('Socket connection error:', error);
            reject(error);
          }
        };

        if (socket.connected) {
          handleConnect();
          return;
        }

        socket.once('connect', handleConnect);
        socket.once('connect_error', handleError);
        socket.once('error', handleError);
      });

    } catch (error) {
      console.error('Socket setup error:', error);
      if (error.message === 'Invalid authentication state') {
        router.replace('/?error=auth_required');
      }
      throw error;
    }
  }, [userRooms, cleanup, router]);

  const fetchRoomData = useCallback(async (roomId) => {
    try {
      const user = authService.getCurrentUser();
      if (!user?.token || !user?.sessionId) {
        await handleSessionError();
        throw new Error('인증 정보가 유효하지 않습니다.');
      }

      if (!roomId || !mountedRef.current) {
        throw new Error('채팅방 정보가 올바르지 않습니다.');
      }

      const response = await fetch(
        `${process.env.NEXT_PUBLIC_API_URL}/api/rooms/${roomId}`,
        {
          method: 'GET',
          headers: {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'x-auth-token': user.token,
            'x-session-id': user.sessionId
          },
          credentials: 'include'
        }
      );

      if (!response.ok) {
        if (response.status === 401) {
          const refreshed = await handleSessionError();
          if (refreshed && mountedRef.current) {
            return fetchRoomData(roomId);
          }
          throw new Error('인증이 만료되었습니다.');
        }
        throw new Error('채팅방 정보를 불러오는데 실패했습니다.');
      }

      const data = await response.json();
      if (!data.success || !data.data) {
        throw new Error('채팅방 데이터가 올바르지 않습니다.');
      }

      return data.data;
    } catch (error) {
      console.error('Fetch room data error:', error);
      throw error;
    }
  }, [mountedRef, handleSessionError]);

  const joinRoom = useCallback(async (roomId) => {
    if (!roomId || !mountedRef.current) {
      throw new Error('잘못된 채팅방 정보입니다.');
    }

    const socket = socketRef.current;
    if (!socket?.connected) {
      throw new Error('Socket not connected');
    }

    return new Promise((resolve, reject) => {
      const timeout = setTimeout(() => {
        reject(new Error('채팅방 입장 시간이 초과되었습니다.'));
      }, 20000);

      const handleSuccess = (data) => {
        clearTimeout(timeout);
        userRooms?.set(socket.id, roomId);
        socket.off('joinRoomError', handleError);
        socket.off('error', handleError);
        resolve(data);
      };

      const handleError = (error) => {
        clearTimeout(timeout);
        socket.off('joinRoomSuccess', handleSuccess);
        socket.off('error', handleError);
        reject(error);
      };

      socket.once('joinRoomSuccess', handleSuccess);
      socket.once('joinRoomError', handleError);
      socket.once('error', handleError);

      socket.emit('joinRoom', roomId);
    });
  }, [socketRef, mountedRef, userRooms]);

  const loadInitialMessages = useCallback(async (roomId) => {
    const loadMessagesWithRetry = async (retryCount = 0) => {
      return new Promise((resolve, reject) => {
        if (!socketRef.current?.connected) {
          reject(new Error('Socket not connected'));
          return;
        }

        let timeoutId;
        const cleanup = () => {
          if (timeoutId) clearTimeout(timeoutId);
          socketRef.current?.off('previousMessagesLoaded', handleSuccess);
          socketRef.current?.off('error', handleError);
        };

        const handleSuccess = (response) => {
          cleanup();
          
          if (!response || !Array.isArray(response.messages)) {
            if (retryCount < MAX_MESSAGE_RETRY_ATTEMPTS) {
              console.log(`Invalid message format, retrying (${retryCount + 1}/${MAX_MESSAGE_RETRY_ATTEMPTS})...`);
              setTimeout(() => {
                loadMessagesWithRetry(retryCount + 1)
                  .then(resolve)
                  .catch(reject);
              }, MESSAGE_RETRY_DELAY);
            } else {
              reject(new Error('잘못된 메시지 응답 형식입니다.'));
            }
            return;
          }

          processMessages(response.messages, response.hasMore, true);
          resolve(response);
        };

        const handleError = (error) => {
          cleanup();
          if (retryCount < MAX_MESSAGE_RETRY_ATTEMPTS) {
            console.log(`Message loading failed, retrying (${retryCount + 1}/${MAX_MESSAGE_RETRY_ATTEMPTS})...`);
            setTimeout(() => {
              loadMessagesWithRetry(retryCount + 1)
                .then(resolve)
                .catch(reject);
            }, MESSAGE_RETRY_DELAY);
          } else {
            reject(error);
          }
        };

        const handleTimeout = () => {
          cleanup();
          if (retryCount < MAX_MESSAGE_RETRY_ATTEMPTS) {
            console.log(`Message loading timed out, retrying (${retryCount + 1}/${MAX_MESSAGE_RETRY_ATTEMPTS})...`);
            setTimeout(() => {
              loadMessagesWithRetry(retryCount + 1)
                .then(resolve)
                .catch(reject);
            }, MESSAGE_RETRY_DELAY);
          } else {
            reject(new Error('메시지 로딩 시간이 초과되었습니다.'));
          }
        };

        socketRef.current.once('previousMessagesLoaded', handleSuccess);
        socketRef.current.once('error', handleError);
        timeoutId = setTimeout(handleTimeout, MESSAGE_TIMEOUT);

        socketRef.current.emit('fetchPreviousMessages', {
          roomId,
          limit: 30
        });
      });
    };

    try {
      return await loadMessagesWithRetry();
    } catch (error) {
      if (!socketRef.current?.connected) {
        console.log('Socket disconnected, attempting to reconnect...');
        await setupSocket();
        return loadMessagesWithRetry();
      }
      throw error;
    }
  }, [socketRef, processMessages, setupSocket]);

  const setupRoom = useCallback(async () => {
    if (setupPromiseRef.current) {
      return setupPromiseRef.current;
    }

    setupPromiseRef.current = (async () => {
      try {
        initializingRef.current = true;
        setLoading(true);
        setError(null);
        messageRetryCountRef.current = 0;

        // 1. Socket Setup
        console.log('Setting up socket connection...');
        socketRef.current = await setupSocket();

        // 2. Fetch Room Data
        console.log('Fetching room data...');
        const roomData = await fetchRoomData(router.query.room);
        setRoom(roomData);

        // 3. Setup Event Listeners
        console.log('Setting up event listeners...');
        if (mountedRef.current) {
          setupEventListeners();
        }

        // 4. Join Room and Load Messages
        if (mountedRef.current && socketRef.current?.connected) {
          console.log('Joining room...');
          await joinRoom(router.query.room);
          
          console.log('Loading initial messages...');
          await loadInitialMessages(router.query.room);
        }

        if (mountedRef.current) {
          setupCompleteRef.current = true;
          setIsInitialized(true);
        }

        console.log('Room setup completed successfully');

      } catch (error) {
        console.error('Room setup error:', error);
        
        if (mountedRef.current) {
          const errorMessage = error.message.includes('시간 초과') ?
            '채팅방 연결 시간이 초과되었습니다.' :
            error.message || '채팅방 연결에 실패했습니다.';
            
          setError(errorMessage);
          cleanup();

          if (socketRef.current) {
            socketRef.current.disconnect();
            socketRef.current = null;
          }
        }

        throw error;
      } finally {
        if (mountedRef.current) {
          setLoading(false);
          initializingRef.current = false;
        }
        
        clearAllTimeouts();
        setupPromiseRef.current = null;
      }
    })();

    return setupPromiseRef.current;
  }, [
    router,
    socketRef,
    mountedRef,
    setupSocket,
    fetchRoomData,
    joinRoom,
    loadInitialMessages,
    cleanup,
    setupEventListeners,
    setError,
    setRoom,
    setLoading,
    setIsInitialized,
    initializingRef,
    setupCompleteRef,
    clearAllTimeouts
  ]);

  useEffect(() => {
    return () => {
      clearAllTimeouts();
      setupPromiseRef.current = null;
      initializingRef.current = false;
      setupCompleteRef.current = false;
      socketReconnectAttempts.current = 0;
      messageRetryCountRef.current = 0;

      if (socketRef.current) {
        console.log("Cleaning up socket connection");
        socketRef.current.disconnect();
        socketRef.current = null;
      }
    };
  }, [clearAllTimeouts]);

  useEffect(() => {
    const handleOnline = () => {
      if (!setupCompleteRef.current && mountedRef.current) {
        console.log('Network is back online, attempting to reconnect...');
        setupRoom().catch(error => {
          console.error('Auto reconnect failed:', error);
        });
      }
    };

    window.addEventListener('online', handleOnline);
    
    return () => {
      window.removeEventListener('online', handleOnline);
    };
  }, [setupRoom]);

  return {
    setupRoom,
    joinRoom,
    loadInitialMessages,
    fetchRoomData,
    handleSessionError
  };
};

export default useRoomHandling;

<frontend/hooks/useScrollHandling.js>
import { useState, useRef, useCallback, useEffect } from 'react';

export const useScrollHandling = (socketRef, router, messages = []) => {
  const [isNearBottom, setIsNearBottom] = useState(true);
  const [hasMoreMessages, setHasMoreMessages] = useState(true);
  const [loadingMessages, setLoadingMessages] = useState(false);
  const [initialScrollDone, setInitialScrollDone] = useState(false);
  const [isLoadingPreviousMessages, setIsLoadingPreviousMessages] = useState(false);

  const messagesEndRef = useRef(null);
  const previousScrollHeightRef = useRef(0);
  const previousScrollTopRef = useRef(0);
  const scrollPositionRef = useRef(0);
  const isLoadingRef = useRef(false);
  const lastMessageCountRef = useRef(messages?.length || 0);
  const scrollTimeoutRef = useRef(null);
  const retryTimeoutRef = useRef(null);
  const scrollRestorationRef = useRef(null);
  const loadMoreTriggeredRef = useRef(false);

  const logDebug = useCallback((action, data) => {
    console.debug(`[ScrollHandling] ${action}:`, {
      ...data,
      timestamp: new Date().toISOString()
    });
  }, []);

  const checkScrollPosition = useCallback(() => {
    if (!messagesEndRef.current) return { isAtBottom: true, isAtTop: false };

    const container = messagesEndRef.current;
    const { scrollTop, scrollHeight, clientHeight } = container;
    const distanceFromBottom = scrollHeight - (scrollTop + clientHeight);
    const isAtBottom = distanceFromBottom < 100;
    const isAtTop = scrollTop < 30;

    return { isAtBottom, isAtTop, scrollTop, scrollHeight, clientHeight };
  }, []);

  const scrollToBottom = useCallback((behavior = 'smooth') => {
    // 과거 메시지 로딩 중에는 스크롤 하단 이동 방지
    if (isLoadingPreviousMessages) {
      return;
    }

    if (!messagesEndRef.current) return;

    requestAnimationFrame(() => {
      try {
        const container = messagesEndRef.current;
        if (!container) return;

        const { scrollHeight, clientHeight } = container;
        const maxScrollTop = scrollHeight - clientHeight;

        container.scrollTo({
          top: maxScrollTop,
          behavior: behavior === 'auto' ? 'auto' : 'smooth'
        });

        logDebug('scrollToBottom', {
          scrollHeight,
          clientHeight,
          maxScrollTop,
          behavior,
          isLoadingPrevious: isLoadingPreviousMessages
        });
      } catch (error) {
        console.error('Scroll error:', error);
      }
    });
  }, [isLoadingPreviousMessages, logDebug]);

  const tryLoadMoreMessages = useCallback(async () => {  
    if (!hasMoreMessages || loadingMessages || isLoadingRef.current || loadMoreTriggeredRef.current) {
      logDebug('loadMore prevented', {
        hasMoreMessages,
        loadingMessages,
        isLoading: isLoadingRef.current,
        loadMoreTriggered: loadMoreTriggeredRef.current
      });
      return;
    }

    try {
      if (!socketRef?.current?.connected) {
        throw new Error('Socket not connected');
      }
      
      const container = messagesEndRef.current;
      if (!container) return;
      
      // 이전 메시지 로딩 상태 설정
      setIsLoadingPreviousMessages(true);
      isLoadingRef.current = true;
      loadMoreTriggeredRef.current = true;
      
      // 현재 스크롤 위치와 높이 저장
      previousScrollHeightRef.current = container.scrollHeight;
      previousScrollTopRef.current = container.scrollTop;
      scrollPositionRef.current = container.scrollTop;

      setLoadingMessages(true);

      const firstMessage = messages?.[0];
      if (!firstMessage) {
        setHasMoreMessages(false);
        isLoadingRef.current = false;
        loadMoreTriggeredRef.current = false;
        setLoadingMessages(false);
        setIsLoadingPreviousMessages(false);
        return;
      }

      // Socket.IO 이벤트 emit 및 응답 대기
      const responsePromise = new Promise((resolve, reject) => {
        socketRef.current.emit('fetchPreviousMessages', {
          roomId: router?.query?.room,
          before: firstMessage.timestamp
        });

        socketRef.current.once('previousMessagesLoaded', (data) => {
          resolve(data);
        });

        socketRef.current.once('error', (error) => {
          setIsLoadingPreviousMessages(false);
          reject(error);
        });

        // 타임아웃 설정
        setTimeout(() => {
          setIsLoadingPreviousMessages(false);
          reject(new Error('Timeout loading messages'));
        }, 10000);
      });

      await responsePromise;

    } catch (error) {
      console.error('Load more error:', error);
      setIsLoadingPreviousMessages(false);
      isLoadingRef.current = false;
      loadMoreTriggeredRef.current = false;
      setLoadingMessages(false);
    }
  }, [
    hasMoreMessages,
    loadingMessages,
    messages,
    socketRef,
    router?.query?.room,
    setLoadingMessages
  ]);

  const handleScroll = useCallback(() => {
    console.log('Scroll event triggered'); // 스크롤 이벤트 확인용 로그

    if (!messagesEndRef.current) {
      console.log('No messagesEndRef');
      return;
    }

    if (scrollTimeoutRef.current) {
      clearTimeout(scrollTimeoutRef.current);
    }

    scrollTimeoutRef.current = setTimeout(() => {
      console.log('Scroll timeout triggered'); // 타임아웃 실행 확인

      const container = messagesEndRef.current;
      if (!container) {
        console.log('No container in timeout');
        return;
      }

      const { scrollTop, scrollHeight, clientHeight } = container;
      const isAtBottom = scrollHeight - (scrollTop + clientHeight) < 100;
      const isAtTop = scrollTop < 30;

      console.log('Scroll position:', { // 스크롤 위치 확인
        scrollTop,
        scrollHeight,
        clientHeight,
        isAtTop,
        isAtBottom
      });

      setIsNearBottom(isAtBottom);

      if (isAtTop) {
        console.log('Is at top, checking conditions:', { // 조건 확인
          hasMoreMessages,
          loadingMessages,
          isLoading: isLoadingRef.current,
          loadMoreTriggered: loadMoreTriggeredRef.current
        });

        if (hasMoreMessages && !loadingMessages && !isLoadingRef.current && !loadMoreTriggeredRef.current) {
          console.log('Calling tryLoadMoreMessages'); // 함수 호출 확인
          tryLoadMoreMessages();
        }
      }
    }, 150);
  }, [hasMoreMessages, loadingMessages, tryLoadMoreMessages, logDebug]);
  
  // Handle new messages
  useEffect(() => {
    const currentMessageCount = messages?.length || 0;
    if (currentMessageCount > lastMessageCountRef.current && !isLoadingPreviousMessages) {
      if (isNearBottom) {
        scrollToBottom();
      }
      lastMessageCountRef.current = currentMessageCount;
    }
  }, [messages, isNearBottom, scrollToBottom, isLoadingPreviousMessages]);

  // Initial scroll setup
  useEffect(() => {
    if (!initialScrollDone && messages?.length > 0 && !isLoadingPreviousMessages) {
      scrollToBottom('auto');
      setInitialScrollDone(true);
      logDebug('initialScroll');
    }
  }, [messages?.length, initialScrollDone, scrollToBottom, isLoadingPreviousMessages, logDebug]);

  // Restore scroll position after loading more messages
  useEffect(() => {
    if (!loadingMessages && previousScrollHeightRef.current > 0) {
      if (scrollRestorationRef.current) {
        cancelAnimationFrame(scrollRestorationRef.current);
      }

      scrollRestorationRef.current = requestAnimationFrame(() => {
        try {
          const container = messagesEndRef.current;
          if (!container) return;

          const newScrollHeight = container.scrollHeight;
          const heightDiff = newScrollHeight - previousScrollHeightRef.current;
          const newScrollTop = previousScrollTopRef.current + heightDiff;
          
          logDebug('scroll restoration', {
            previousHeight: previousScrollHeightRef.current,
            newHeight: newScrollHeight,
            heightDiff,
            previousScrollTop: previousScrollTopRef.current,
            newScrollTop,
            isLoadingPrevious: isLoadingPreviousMessages
          });

          // isLoadingPreviousMessages가 true일 때만 스크롤 위치 복원
          if (isLoadingPreviousMessages) {
            const originalScrollBehavior = container.style.scrollBehavior;
            container.style.scrollBehavior = 'auto';
            container.scrollTop = newScrollTop;
            requestAnimationFrame(() => {
              container.style.scrollBehavior = originalScrollBehavior;
            });
          }

          // 상태 초기화
          previousScrollHeightRef.current = 0;
          previousScrollTopRef.current = 0;
          scrollPositionRef.current = newScrollTop;
          isLoadingRef.current = false;
          loadMoreTriggeredRef.current = false;
          
          // 모든 작업이 완료된 후 isLoadingPreviousMessages 상태 변경
          setTimeout(() => {
            setIsLoadingPreviousMessages(false);
          }, 100);

        } catch (error) {
          console.error('Scroll restoration error:', error);
          isLoadingRef.current = false;
          loadMoreTriggeredRef.current = false;
          setIsLoadingPreviousMessages(false);
        }
      });
    }
  }, [loadingMessages, logDebug]);

  // Cleanup
  useEffect(() => {
    return () => {
      if (scrollTimeoutRef.current) {
        clearTimeout(scrollTimeoutRef.current);
      }
      if (retryTimeoutRef.current) {
        clearTimeout(retryTimeoutRef.current);
      }
      if (scrollRestorationRef.current) {
        cancelAnimationFrame(scrollRestorationRef.current);
      }
      isLoadingRef.current = false;
      loadMoreTriggeredRef.current = false;
      setIsLoadingPreviousMessages(false);
    };
  }, []);

  return {
    isNearBottom,
    hasMoreMessages,
    loadingMessages,
    initialScrollDone,
    messagesEndRef,
    scrollToBottom,
    handleScroll,
    tryLoadMoreMessages,
    checkScrollPosition,
    setHasMoreMessages,
    setLoadingMessages,
    setInitialScrollDone,
    setIsNearBottom,
    isLoadingPreviousMessages
  };
};

export default useScrollHandling;

<frontend/hooks/useSocketHandling.js>
import { useState, useRef, useCallback, useEffect } from 'react';
import socketService from '../services/socket';
import { Toast } from '../components/Toast';

export const useSocketHandling = (router, maxRetries = 5) => { // 최대 재시도 횟수 증가
  const [connected, setConnected] = useState(false);
  const [error, setError] = useState(null);
  const [retryCount, setRetryCount] = useState(0);
  const [isReconnecting, setIsReconnecting] = useState(false);
  const socketRef = useRef(null);
  const retryTimeoutRef = useRef(null);
  const reconnectIntervalRef = useRef(null);
  const connectionTimeoutRef = useRef(null);

  const cleanup = useCallback(() => {
    if (retryTimeoutRef.current) {
      clearTimeout(retryTimeoutRef.current);
    }
    if (reconnectIntervalRef.current) {
      clearInterval(reconnectIntervalRef.current);
    }
    if (connectionTimeoutRef.current) {
      clearTimeout(connectionTimeoutRef.current);
    }
  }, []);

  const getRetryDelay = useCallback((retryAttempt) => {
    return Math.min(1000 * Math.pow(2, retryAttempt), 10000); // 최대 10초
  }, []);

  const handleConnectionError = useCallback(async (error, handleSessionError) => {
    console.error('Connection error:', error);
    setConnected(false);
    setIsReconnecting(true);
    
    try {
      if (error?.message?.includes('세션') || 
          error?.message?.includes('인증') || 
          error?.message?.includes('토큰')) {
        await handleSessionError?.();
        return;
      }

      if (retryCount < maxRetries) {
        const retryDelay = getRetryDelay(retryCount);
        console.log(`Retrying connection in ${retryDelay}ms... (Attempt ${retryCount + 1}/${maxRetries})`);
        
        cleanup();

        retryTimeoutRef.current = setTimeout(async () => {
          try {
            if (socketRef.current) {
              await socketRef.current.connect();
              setConnected(true);
              setIsReconnecting(false);
              setRetryCount(0);
              setError(null);
              
              // 재연결 성공 시 채팅방 재접속
              if (router?.query?.room) {
                socketRef.current.emit('joinRoom', router.query.room);
              }
            }
          } catch (retryError) {
            console.error('Retry connection failed:', retryError);
            setRetryCount(prev => prev + 1);
            handleConnectionError(retryError, handleSessionError);
          }
        }, retryDelay);
      } else {
        setIsReconnecting(false);
        Toast.error('채팅 서버와 연결할 수 없습니다. 페이지를 새로고침해주세요.');
      }
    } catch (err) {
      console.error('Error handling connection error:', err);
      setIsReconnecting(false);
    }
  }, [retryCount, maxRetries, cleanup, getRetryDelay, router?.query?.room]);

  const handleReconnect = useCallback(async (currentUser, handleSessionError) => {
    if (isReconnecting) return;

    try {
      if (!currentUser?.token || !currentUser?.sessionId) {
        throw new Error('Invalid user credentials');
      }

      setError(null);
      setRetryCount(0);
      setIsReconnecting(true);
      
      cleanup();
      
      if (socketRef.current) {
        socketRef.current.disconnect();
        setConnected(false);
      }

      const socket = await socketService.connect({
        auth: {
          token: currentUser.token,
          sessionId: currentUser.sessionId
        },
        transports: ['websocket', 'polling'],
        reconnection: true,
        reconnectionAttempts: maxRetries,
        reconnectionDelay: getRetryDelay(0),
        reconnectionDelayMax: 10000,
        timeout: 20000
      });

      socketRef.current = socket;
      
      // 연결 타임아웃 설정
      connectionTimeoutRef.current = setTimeout(() => {
        if (!socket.connected) {
          handleConnectionError(new Error('Connection timeout'), handleSessionError);
        }
      }, 20000);

      // 연결 이벤트 핸들러
      socket.on('connect', () => {
        setConnected(true);
        setIsReconnecting(false);
        cleanup();

        if (router?.query?.room) {
          socket.emit('joinRoom', router.query.room);
        }
      });

      socket.on('connect_error', (error) => {
        handleConnectionError(error, handleSessionError);
      });

      socket.on('disconnect', (reason) => {
        console.log('Socket disconnected:', reason);
        setConnected(false);
        
        if (reason === 'io server disconnect' || reason === 'io client disconnect') {
          return;
        }
        
        handleConnectionError(new Error(`Disconnected: ${reason}`), handleSessionError);
      });
      
    } catch (error) {
      console.error('Reconnection failed:', error);
      setConnected(false);
      setIsReconnecting(false);
      
      if (error.message?.includes('세션') || 
          error.message?.includes('인증') || 
          error.message?.includes('토큰')) {
        await handleSessionError?.();
        return;
      }
      
      Toast.error('재연결에 실패했습니다.');
    }
  }, [isReconnecting, cleanup, getRetryDelay, maxRetries, router?.query?.room, handleConnectionError]);

  useEffect(() => {
    return cleanup;
  }, [cleanup]);

  useEffect(() => {
    const socket = socketRef.current;
    if (!socket) return;

    const handleConnect = () => {
      console.log('Socket connected');
      setConnected(true);
      setIsReconnecting(false);
      setRetryCount(0);
      setError(null);
    };

    const handleDisconnect = () => {
      console.log('Socket disconnected');
      setConnected(false);
    };

    socket.on('connect', handleConnect);
    socket.on('disconnect', handleDisconnect);

    setConnected(socket.connected);

    return () => {
      socket.off('connect', handleConnect);
      socket.off('disconnect', handleDisconnect);
    };
  }, [socketRef.current]);

  // 네트워크 상태 모니터링
  useEffect(() => {
    const handleOnline = () => {
      console.log('Network is online');
      if (!connected && !isReconnecting) {
        handleReconnect();
      }
    };

    const handleOffline = () => {
      console.log('Network is offline');
      setConnected(false);
    };

    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);

    return () => {
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
    };
  }, [connected, isReconnecting, handleReconnect]);

  return {
    connected,
    error,
    socketRef,
    isReconnecting,
    setConnected,
    setError,
    handleConnectionError,
    handleReconnect,
    cleanup
  };
};

export default useSocketHandling;

<frontend/middleware/withAuth.js>
import { useEffect, useState } from 'react';
import { useRouter } from 'next/router';
import authService from '../services/authService';

export const withAuth = (WrappedComponent) => {
  const WithAuthComponent = (props) => {
    const router = useRouter();
    const [isLoading, setIsLoading] = useState(true);

    useEffect(() => {
      const checkAuth = () => {
        const user = authService.getCurrentUser();
        if (!user) {
          router.replace('/?redirect=' + router.asPath);
        } else {
          setIsLoading(false);
        }
      };

      checkAuth();
    }, [router]);

    if (isLoading) {
      return null;
    }

    return <WrappedComponent {...props} />;
  };

  // HOC에 displayName 설정
  const displayName = WrappedComponent.displayName || WrappedComponent.name || 'Component';
  WithAuthComponent.displayName = `WithAuth(${displayName})`;

  return WithAuthComponent;
};

export const withoutAuth = (WrappedComponent) => {
  const WithoutAuthComponent = (props) => {
    const router = useRouter();
    const [isLoading, setIsLoading] = useState(true);

    useEffect(() => {
      const checkAuth = () => {
        const user = authService.getCurrentUser();
        if (user) {
          // 이미 로그인된 사용자가 로그인/회원가입 페이지 접근 시
          // chat-rooms로 리디렉션하되, '/'는 예외처리
          if (router.pathname !== '/') {
            router.replace('/chat-rooms');
          }
        } else {
          setIsLoading(false);
        }
      };

      checkAuth();
    }, [router]);

    if (isLoading) {
      return null;
    }

    return <WrappedComponent {...props} />;
  };

  const displayName = WrappedComponent.displayName || WrappedComponent.name || 'Component';
  WithoutAuthComponent.displayName = `WithoutAuth(${displayName})`;

  return WithoutAuthComponent;
};

<frontend/next.config.js>
/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,
};

module.exports = nextConfig;

<frontend/package.json>
{
  "name": "chat-app-frontend",
  "version": "1.0.0",
  "description": "Frontend for Chat App using Next.js",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start"
  },
  "dependencies": {
    "@emoji-mart/data": "^1.1.2",
    "@emoji-mart/react": "^1.1.1",
    "@goorm-dev/vapor-components": "^0.19.1",
    "@goorm-dev/vapor-core": "^0.19.1",
    "@goorm-dev/vapor-hooks": "^0.19.1",
    "@goorm-dev/vapor-icons": "^0.19.1",
    "@goorm-dev/vapor-tables": "^0.19.1",
    "axios": "^1.4.0",
    "bootstrap": "^5.3.3",
    "crypto-js": "^4.2.0",
    "emoji-mart": "^5.5.2",
    "lucide-react": "^0.263.1",
    "marked": "^14.1.3",
    "next": "^15.0.2",
    "prismjs": "^1.29.0",
    "react": "^18.3.1",
    "react-bootstrap": "^2.8.0",
    "react-canvas-confetti": "^2.0.7",
    "react-dom": "^18.3.1",
    "react-markdown": "^9.0.1",
    "react-syntax-highlighter": "^15.6.1",
    "react-toastify": "^10.0.6",
    "reactstrap": "^8.10.1",
    "remark-breaks": "^4.0.0",
    "remark-emoji": "^5.0.1",
    "remark-gfm": "^4.0.0",
    "socket.io-client": "^4.7.2"
  },
  "author": "",
  "license": "ISC"
}


<frontend/pages/_app.js>
import { useEffect, useState } from 'react';
import { useRouter } from 'next/router';
import authService from '../services/authService';
import '../styles/globals.css';
import Navbar from '../components/Navbar';
import { Alert } from '@goorm-dev/vapor-components';
import ToastContainer, { Toast } from '../components/Toast';
import DuplicateLoginModal from '../components/DuplicateLoginModal';

function MyApp({ Component, pageProps }) {
  const router = useRouter();
  const [authChecked, setAuthChecked] = useState(false);
  const [duplicateLoginInfo, setDuplicateLoginInfo] = useState(null);
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [authError, setAuthError] = useState(null);

  useEffect(() => {
    const checkAuth = () => {
      try {
        const protectedRoutes = ['/chat-rooms', '/chat', '/profile'];
        const publicOnlyRoutes = ['/register'];
        const path = router.pathname;
        const user = authService.getCurrentUser();
        
        if (protectedRoutes.includes(path) && !user) {
          router.replace(`/?redirect=${encodeURIComponent(router.asPath)}`);
          return;
        }
        
        if (path !== '/' && publicOnlyRoutes.includes(path) && user) {
          router.replace('/chat-rooms');
          return;
        }
        
        setAuthChecked(true);
      } catch (error) {
        console.error('Auth check error:', error);
        setAuthError(error.message);
      }
    };

    const handleDuplicateLogin = (event) => {
      const { detail } = event;
      if (!detail?.deviceInfo || !detail?.ipAddress) {
        console.error('Invalid duplicate login event data:', detail);
        return;
      }

      // 이전 토스트가 있다면 제거
      if (Toast.isActive('duplicate-login')) {
        Toast.dismiss('duplicate-login');
      }

      Toast.warning('다른 기기에서 로그인이 감지되었습니다.', {
        toastId: 'duplicate-login',
        autoClose: 10000
      });

      setDuplicateLoginInfo({
        deviceInfo: detail.deviceInfo,
        ipAddress: detail.ipAddress,
        timestamp: detail.timestamp
      });
      setIsModalOpen(true);
    };

    const handleSessionExpired = () => {
      // 이전 토스트가 있다면 제거
      if (Toast.isActive('session-expired')) {
        Toast.dismiss('session-expired');
      }

      Toast.warning('세션이 만료되었습니다. 다시 로그인해주세요.', {
        toastId: 'session-expired',
        autoClose: 3000,
        onClose: () => {
          router.replace('/?error=session_expired');
        }
      });

      if (isModalOpen) {
        setIsModalOpen(false);
        setDuplicateLoginInfo(null);
      }
    };

    const handleSocketDisconnect = () => {
      // 이전 토스트가 있다면 제거
      if (Toast.isActive('socket-disconnect')) {
        Toast.dismiss('socket-disconnect');
      }

      Toast.error('채팅 서버와 연결이 끊어졌습니다.', {
        toastId: 'socket-disconnect',
        autoClose: 3000
      });
    };

    checkAuth();
    window.addEventListener('duplicateLogin', handleDuplicateLogin);
    window.addEventListener('sessionExpired', handleSessionExpired);
    window.addEventListener('socketDisconnect', handleSocketDisconnect);

    return () => {
      window.removeEventListener('duplicateLogin', handleDuplicateLogin);
      window.removeEventListener('sessionExpired', handleSessionExpired);
      window.removeEventListener('socketDisconnect', handleSocketDisconnect);
    };
  }, [router, isModalOpen]);

  const handleDuplicateLoginTimeout = async () => {
    try {
      if (Toast.isActive('duplicate-login')) {
        Toast.dismiss('duplicate-login');
      }

      await authService.logout();
      setDuplicateLoginInfo(null);
      setIsModalOpen(false);

      Toast.info('다른 기기에서 로그인하여 로그아웃되었습니다.', {
        toastId: 'logout-info',
        autoClose: 3000,
        onClose: () => {
          router.replace('/?error=duplicate_login');
        }
      });

    } catch (error) {
      console.error('Duplicate login logout error:', error);
      Toast.error('로그아웃 처리 중 오류가 발생했습니다.', {
        toastId: 'logout-error',
        autoClose: 3000,
        onClose: () => {
          router.replace('/');
        }
      });
    }
  };

  const handleModalClose = () => {
    setIsModalOpen(false);
    handleDuplicateLoginTimeout();
  };

  if (!authChecked) {
    return null;
  }

  return (
    <div className="app-container">
      <ToastContainer />
      <Navbar />
      
      {authError && (
        <Alert 
          color="danger" 
          className="fixed top-4 left-1/2 transform -translate-x-1/2 z-50"
          onClose={() => setAuthError(null)}
        >
          {authError}
        </Alert>
      )}

      <main className="main-content">
        <Component {...pageProps} />
      </main>

      <DuplicateLoginModal
        isOpen={isModalOpen}
        onClose={handleModalClose}
        deviceInfo={duplicateLoginInfo?.deviceInfo}
        ipAddress={duplicateLoginInfo?.ipAddress}
        onTimeout={handleDuplicateLoginTimeout}
      />
    </div>
  );
}

export default MyApp;

<frontend/pages/_document.js>
import { Html, Head, Main, NextScript } from 'next/document';

export default function Document() {
  return (
    <Html lang="ko">
      <Head>
        <meta charSet="utf-8" />
        <link
          rel="stylesheet"
          href="https://statics.goorm.io/gds/foundation/v0.19.0/vapor-foundation.dark.min.css"
        />
      </Head>
      <body>
        <Main />
        <NextScript />
      </body>
    </Html>
  );
}

<frontend/pages/chat-rooms/new.js>
import React, { useState, useEffect } from 'react';
import { useRouter } from 'next/router';
import { Card } from '@goorm-dev/vapor-core';
import { 
  Button, 
  Input, 
  Text,
  Alert,
  Switch,
  FormGroup,
  Label
} from '@goorm-dev/vapor-components';
import { AlertCircle } from 'lucide-react';
import authService from '../../services/authService';

function NewChatRoom() {
  const router = useRouter();
  const [formData, setFormData] = useState({
    name: '',
    hasPassword: false,
    password: ''
  });
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');
  const [currentUser, setCurrentUser] = useState(null);

  useEffect(() => {
    const user = authService.getCurrentUser();
    if (!user) {
      router.push('/');
      return;
    }
    setCurrentUser(user);
  }, [router]);

  const joinRoom = async (roomId, password) => {
    try {
      const response = await fetch(`${process.env.NEXT_PUBLIC_API_URL}/api/rooms/${roomId}/join`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'x-auth-token': currentUser.token,
          'x-session-id': currentUser.sessionId
        },
        body: JSON.stringify({ password })
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.message || '채팅방 입장에 실패했습니다.');
      }

      // 채팅방으로 이동
      router.push(`/chat?room=${roomId}`);
    } catch (error) {
      console.error('Room join error:', error);
      throw error;
    }
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    
    if (!formData.name.trim()) {
      setError('채팅방 이름을 입력해주세요.');
      return;
    }

    if (formData.hasPassword && !formData.password) {
      setError('비밀번호를 입력해주세요.');
      return;
    }

    if (!currentUser?.token) {
      setError('인증 정보가 없습니다. 다시 로그인해주세요.');
      return;
    }

    try {
      setLoading(true);
      setError('');

      // 채팅방 생성
      const response = await fetch(`${process.env.NEXT_PUBLIC_API_URL}/api/rooms`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'x-auth-token': currentUser.token,
          'x-session-id': currentUser.sessionId
        },
        body: JSON.stringify({
          name: formData.name.trim(),
          password: formData.hasPassword ? formData.password : undefined
        })
      });

      if (!response.ok) {
        const errorData = await response.json();
        if (response.status === 401) {
          try {
            await authService.refreshToken();
            const updatedUser = authService.getCurrentUser();
            if (updatedUser) {
              setCurrentUser(updatedUser);
              return handleSubmit(e);
            }
          } catch (refreshError) {
            throw new Error('인증이 만료되었습니다. 다시 로그인해주세요.');
          }
        }
        throw new Error(errorData.message || '채팅방 생성에 실패했습니다.');
      }

      const { data } = await response.json();
      
      // 생성된 채팅방에 자동으로 입장
      await joinRoom(data._id, formData.hasPassword ? formData.password : undefined);

    } catch (error) {
      console.error('Room creation/join error:', error);
      setError(error.message);
      
      if (error.message.includes('인증') || error.message.includes('만료')) {
        authService.logout();
        router.push('/');
      }
    } finally {
      setLoading(false);
    }
  };

  const handleSwitchChange = (e) => {
    const checked = e.target.checked;
    setFormData(prev => ({
      ...prev,
      hasPassword: checked,
      password: checked ? prev.password : ''
    }));
  };

  return (
    <div className="auth-container">
      <Card className="auth-card">
        <Card.Header>
          <Text as="h5" typography="heading5">새 채팅방</Text>
        </Card.Header>
        <Card.Body className="p-8">

          {error && (
            <Alert
              color="danger"
              className="mb-6"
            >
              <AlertCircle className="w-4 h-4 mr-2" />
              {error}
            </Alert>
          )}

          <form onSubmit={handleSubmit} className="auth-form">
            <FormGroup>
              <Label for="roomName">채팅방 이름</Label>
              <Input
                id="roomName"
                name="name"
                value={formData.name}
                onChange={(e) => setFormData(prev => ({
                  ...prev,
                  name: e.target.value
                }))}
                placeholder="채팅방 이름을 입력하세요"
                disabled={loading}
              />
            </FormGroup>

            <FormGroup>
              <div className="d-flex justify-content-between align-items-center">
                <Label for="hasPassword" inline>
                  비밀번호 설정
                </Label>
                <Switch
                  id="hasPassword"
                  checked={formData.hasPassword}
                  onChange={handleSwitchChange}
                  disabled={loading}
                />
              </div>
            </FormGroup>

            {formData.hasPassword && (
              <FormGroup>
                <Label for="roomPassword">비밀번호</Label>
                <Input
                  id="roomPassword"
                  name="password"
                  type="password"
                  value={formData.password}
                  onChange={(e) => setFormData(prev => ({
                    ...prev,
                    password: e.target.value
                  }))}
                  placeholder="비밀번호를 입력하세요"
                  disabled={loading}
                />
              </FormGroup>
            )}

            <Button
              type="submit"
              variant="primary"
              size="lg"
              disabled={loading || !formData.name.trim() || (formData.hasPassword && !formData.password)}
            >
              {loading ? '생성 중...' : '채팅방 만들기'}
            </Button>
          </form>
        </Card.Body>
      </Card>
    </div>
  );
}

export default NewChatRoom;

<frontend/pages/chat-rooms.js>
import React, { useState, useEffect, useMemo, useCallback, useRef } from 'react';
import { useRouter } from 'next/router';
import dynamic from 'next/dynamic';
import { Card } from '@goorm-dev/vapor-core';
import { 
  Button, 
  Status,
  Spinner,
  Text,
  Alert
} from '@goorm-dev/vapor-components';
import {
  HScrollTable,
  useHScrollTable,
  cellHelper
} from '@goorm-dev/vapor-tables';
import { Lock, AlertCircle, WifiOff, RefreshCcw } from 'lucide-react';
import socketService from '../services/socket';
import authService from '../services/authService';
import axiosInstance from '../services/axios';
import { withAuth } from '../middleware/withAuth';
import { Toast } from '../components/Toast';

const API_URL = process.env.NEXT_PUBLIC_API_URL;

const CONNECTION_STATUS = {
  CHECKING: 'checking',
  CONNECTING: 'connecting',
  CONNECTED: 'connected',
  DISCONNECTED: 'disconnected',
  ERROR: 'error'
};

const STATUS_CONFIG = {
  [CONNECTION_STATUS.CHECKING]: { label: "연결 확인 중...", color: "warning" },
  [CONNECTION_STATUS.CONNECTING]: { label: "연결 중...", color: "warning" },
  [CONNECTION_STATUS.CONNECTED]: { label: "연결됨", color: "success" },
  [CONNECTION_STATUS.DISCONNECTED]: { label: "연결 끊김", color: "danger" },
  [CONNECTION_STATUS.ERROR]: { label: "연결 오류", color: "danger" }
};

const RETRY_CONFIG = {
  maxRetries: 3,
  baseDelay: 1000,
  maxDelay: 5000,
  backoffFactor: 2,
  reconnectInterval: 30000
};

const SCROLL_THRESHOLD = 50;
const SCROLL_DEBOUNCE_DELAY = 150;
const INITIAL_PAGE_SIZE = 10;

const LoadingIndicator = ({ text }) => (
  <div className="loading-indicator">
    <Spinner size="sm" className="mr-3" />
    <Text size="sm" color="secondary">{text}</Text>
  </div>
);

const TableWrapper = ({ children, onScroll, loadingMore, hasMore, rooms }) => {
  const tableRef = useRef(null);
  const scrollTimeoutRef = useRef(null);
  const lastScrollTime = useRef(Date.now());
  
  const handleScroll = useCallback((e) => {
    const now = Date.now();
    const container = e.target;
    
    // 마지막 스크롤 체크로부터 150ms가 지났는지 확인
    if (now - lastScrollTime.current >= SCROLL_DEBOUNCE_DELAY) {
      const { scrollHeight, scrollTop, clientHeight } = container;
      const distanceToBottom = scrollHeight - (scrollTop + clientHeight);

      console.log('Scroll check:', {
        scrollHeight,
        scrollTop,
        clientHeight,
        distanceToBottom,
        loadingMore,
        hasMore,
        timeSinceLastCheck: now - lastScrollTime.current
      });

      if (distanceToBottom < SCROLL_THRESHOLD && !loadingMore && hasMore) {
        console.log('Triggering load more...');
        lastScrollTime.current = now; // 마지막 체크 시간 업데이트
        onScroll();
        return;
      }

      lastScrollTime.current = now;
    } else if (!scrollTimeoutRef.current) {
      // 디바운스 타이머 설정
      scrollTimeoutRef.current = setTimeout(() => {
        const { scrollHeight, scrollTop, clientHeight } = container;
        const distanceToBottom = scrollHeight - (scrollTop + clientHeight);

        console.log('Debounced scroll check:', {
          scrollHeight,
          scrollTop,
          clientHeight,
          distanceToBottom,
          loadingMore,
          hasMore
        });

        if (distanceToBottom < SCROLL_THRESHOLD && !loadingMore && hasMore) {
          console.log('Triggering load more (debounced)...');
          onScroll();
        }

        scrollTimeoutRef.current = null;
        lastScrollTime.current = Date.now();
      }, SCROLL_DEBOUNCE_DELAY);
    }
  }, [loadingMore, hasMore, onScroll]);

  useEffect(() => {
    const container = tableRef.current;
    if (container) {
      container.addEventListener('scroll', handleScroll, { passive: true });
    }

    return () => {
      if (container) {
        container.removeEventListener('scroll', handleScroll);
      }
      if (scrollTimeoutRef.current) {
        clearTimeout(scrollTimeoutRef.current);
        scrollTimeoutRef.current = null;
      }
    };
  }, [handleScroll]);
  
  return (
    <div 
      ref={tableRef} 
      className="chat-rooms-table"
      style={{
        height: '430px', 
        overflowY: 'auto',
        position: 'relative',
        borderRadius: '0.5rem',
        backgroundColor: 'var(--background-normal)',
        border: '1px solid var(--border-color)',
        scrollBehavior: 'smooth',
        WebkitOverflowScrolling: 'touch'
      }}
    >
      {children}
      {loadingMore && (
        <div className="flex items-center justify-center gap-2 p-4 border-t border-gray-700">
          <LoadingIndicator text="추가 채팅방을 불러오는 중..." />
        </div>
      )}
      {!hasMore && rooms?.length > 0 && (
        <div className="p-4 text-center border-t border-gray-700">
          <Text size="sm" color="secondary">
            모든 채팅방을 불러왔습니다.
          </Text>
        </div>
      )}
    </div>
  );
};

function ChatRoomsComponent() {
  const router = useRouter();
  const [rooms, setRooms] = useState([]);
  const [error, setError] = useState(null);
  const [loading, setLoading] = useState(true);
  const [loadingMore, setLoadingMore] = useState(false);
  const [currentUser] = useState(authService.getCurrentUser());
  const [connectionStatus, setConnectionStatus] = useState(CONNECTION_STATUS.CHECKING);
  const [retryCount, setRetryCount] = useState(0);
  const [isRetrying, setIsRetrying] = useState(false);
  const [sorting, setSorting] = useState([
    { id: 'createdAt', desc: true }
  ]);
  const [pageIndex, setPageIndex] = useState(0);
  const [pageSize] = useState(INITIAL_PAGE_SIZE);
  const [hasMore, setHasMore] = useState(true);
  const [isInitialLoad, setIsInitialLoad] = useState(true);

  // Refs
  const socketRef = useRef(null);
  const tableContainerRef = useRef(null);
  const connectionCheckTimerRef = useRef(null);
  const isLoadingRef = useRef(false);
  const previousRoomsRef = useRef([]);
  const lastLoadedPageRef = useRef(0);

  const getRetryDelay = useCallback((retryCount) => {
    const delay = RETRY_CONFIG.baseDelay * 
      Math.pow(RETRY_CONFIG.backoffFactor, retryCount) *
      (1 + Math.random() * 0.1);
    return Math.min(delay, RETRY_CONFIG.maxDelay);
  }, []);

  const handleAuthError = useCallback(async (error) => {
    try {
      if (error.response?.status === 401 || error.response?.data?.code === 'TOKEN_EXPIRED') {
        const refreshed = await authService.refreshToken();
        if (refreshed) {
          return true;
        }
      }
      authService.logout();
      router.replace('/?error=session_expired');
      return false;
    } catch (error) {
      console.error('Auth error handling failed:', error);
      authService.logout();
      router.replace('/?error=auth_error');
      return false;
    }
  }, [router]);

  const handleFetchError = useCallback((error, isLoadingMore) => {
    let errorMessage = '채팅방 목록을 불러오는데 실패했습니다.';
    let errorType = 'danger';
    let showRetry = !isRetrying;

    if (error.message === 'SERVER_UNREACHABLE') {
      errorMessage = '서버와 연결할 수 없습니다. 잠시 후 자동으로 재시도합니다.';
      errorType = 'warning';
      showRetry = true;

      if (!isLoadingMore && retryCount < RETRY_CONFIG.maxRetries) {
        const delay = getRetryDelay(retryCount);
        setRetryCount(prev => prev + 1);
        setTimeout(() => {
          setIsRetrying(true);
          fetchRooms(isLoadingMore);
        }, delay);
      }
    }

    if (!isLoadingMore) {
      setError({
        title: '채팅방 목록 로드 실패',
        message: errorMessage,
        type: errorType,
        showRetry
      });
    }

    setConnectionStatus(CONNECTION_STATUS.ERROR);
  }, [isRetrying, retryCount, getRetryDelay]);

  const attemptConnection = useCallback(async (retryAttempt = 0) => {
    try {
      setConnectionStatus(CONNECTION_STATUS.CONNECTING);

      const response = await axiosInstance.get('/health', {
        timeout: 5000,
        retries: 1
      });

      const isConnected = response?.data?.status === 'ok' && response?.status === 200;

      if (isConnected) {
        setConnectionStatus(CONNECTION_STATUS.CONNECTED);
        setRetryCount(0);
        return true;
      }

      throw new Error('Server not ready');
    } catch (error) {
      console.error(`Connection attempt ${retryAttempt + 1} failed:`, error);

      if (!error.response && retryAttempt < RETRY_CONFIG.maxRetries) {
        const delay = getRetryDelay(retryAttempt);
        await new Promise(resolve => setTimeout(resolve, delay));
        return attemptConnection(retryAttempt + 1);
      }

      setConnectionStatus(CONNECTION_STATUS.ERROR);
      throw new Error('SERVER_UNREACHABLE');
    }
  }, [getRetryDelay]);

  const fetchRooms = useCallback(async (isLoadingMore = false) => {
    if (!currentUser?.token || isLoadingRef.current) {
      console.log('Fetch prevented:', { 
        hasToken: !!currentUser?.token, 
        isLoading: isLoadingRef.current 
      });
      return;
    }

    try {
      isLoadingRef.current = true;
      console.log('Fetching rooms:', { isLoadingMore, pageIndex });

      if (!isLoadingMore) {
        setLoading(true);
        setError(null);
      } else {
        setLoadingMore(true);
      }

      await attemptConnection();

      const response = await axiosInstance.get('/api/rooms', {
        params: {
          page: isLoadingMore ? pageIndex : 0,
          pageSize,
          sortField: sorting[0]?.id,
          sortOrder: sorting[0]?.desc ? 'desc' : 'asc'
        }
      });
      
      if (!response?.data?.data) {
        throw new Error('INVALID_RESPONSE');
      }

      const { data, metadata } = response.data;
      console.log('Fetched rooms:', { 
        count: data.length, 
        hasMore: metadata.hasMore 
      });

      setRooms(prev => {
        if (isLoadingMore) {
          const existingIds = new Set(prev.map(room => room._id));
          const newRooms = data.filter(room => !existingIds.has(room._id));
          return [...prev, ...newRooms];
        }
        return data;
      });

      setHasMore(data.length === pageSize && metadata.hasMore);

      if (isInitialLoad) {
        setIsInitialLoad(false);
      }

    } catch (error) {
      console.error('Rooms fetch error:', error);
      handleFetchError(error, isLoadingMore);
    } finally {
      if (!isLoadingMore) {
        setLoading(false);
      }
      setLoadingMore(false);
      isLoadingRef.current = false;
    }
  }, [
    currentUser,
    pageIndex,
    pageSize,
    sorting,
    isInitialLoad,
    attemptConnection,
    handleFetchError
  ]);

  const handleLoadMore = useCallback(async () => {
    if (loadingMore || !hasMore || isLoadingRef.current) {
      console.log('Load more prevented:', {
        loadingMore,
        hasMore,
        isLoading: isLoadingRef.current
      });
      return;
    }

    try {
      console.log('Loading more rooms...');
      setLoadingMore(true);
      isLoadingRef.current = true;

      const nextPage = Math.floor(rooms.length / pageSize);
      console.log('Loading page:', nextPage);
      setPageIndex(nextPage);
      
      const response = await axiosInstance.get('/api/rooms', {
        params: {
          page: nextPage,
          pageSize,
          sortField: sorting[0]?.id,
          sortOrder: sorting[0]?.desc ? 'desc' : 'asc'
        }
      });

      if (response.data?.success) {
        const { data: newRooms, metadata } = response.data;
        console.log('Loaded new rooms:', { 
          count: newRooms.length, 
          hasMore: metadata.hasMore 
        });
        
        setRooms(prev => {
          const existingIds = new Set(prev.map(room => room._id));
          const uniqueNewRooms = newRooms.filter(room => !existingIds.has(room._id));
          console.log('Unique new rooms:', uniqueNewRooms.length);
          return [...prev, ...uniqueNewRooms];
        });

        setHasMore(newRooms.length === pageSize && metadata.hasMore);
      }
    } catch (error) {
      console.error('Load more rooms error:', error);
      handleFetchError(error, true);
    } finally {
      setLoadingMore(false);
      isLoadingRef.current = false;
      Toast.info('추가 채팅방을 불러왔습니다.');
    }
  }, [loadingMore, hasMore, rooms.length, pageSize, sorting, handleFetchError]);

  // 페이지 인덱스 변경 시 데이터 로드
  useEffect(() => {
    if (pageIndex > 0) {
      fetchRooms(true);
    }
  }, [pageIndex, fetchRooms]);

  useEffect(() => {
    if (!currentUser) return;

    const initFetch = async () => {
      try {
        await fetchRooms(false);
      } catch (error) {
        console.error('Initial fetch failed:', error);
        setTimeout(() => {
          if (connectionStatus === CONNECTION_STATUS.CHECKING) {
            fetchRooms(false);
          }
        }, 3000);
      }
    };

    initFetch();

    connectionCheckTimerRef.current = setInterval(() => {
      if (connectionStatus === CONNECTION_STATUS.CHECKING) {
        attemptConnection();
      }
    }, 5000);

    return () => {
      if (connectionCheckTimerRef.current) {
        clearInterval(connectionCheckTimerRef.current);
      }
    };
  }, [currentUser, connectionStatus, attemptConnection, fetchRooms]);

  useEffect(() => {
    const handleOnline = () => {
      console.log('Network is online');
      setConnectionStatus(CONNECTION_STATUS.CONNECTING);
      lastLoadedPageRef.current = 0;
      setPageIndex(0);
      fetchRooms(false);
    };

    const handleOffline = () => {
      console.log('Network is offline');
      setConnectionStatus(CONNECTION_STATUS.DISCONNECTED);
      setError({
        title: '네트워크 연결 끊김',
        message: '인터넷 연결을 확인해주세요.',
        type: 'danger'
      });
    };

    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);

    return () => {
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
    };
  }, [fetchRooms]);

  useEffect(() => {
    if (!currentUser?.token) return;

    let isSubscribed = true;

    const connectSocket = async () => {
      try {
        const socket = await socketService.connect({
          auth: {
            token: currentUser.token,
            sessionId: currentUser.sessionId
          }
        });

        if (!isSubscribed || !socket) return;

        socketRef.current = socket;

        const handlers = {
          connect: () => {
            setConnectionStatus(CONNECTION_STATUS.CONNECTED);
            socket.emit('joinRoomList');
          },
          disconnect: (reason) => {
            setConnectionStatus(CONNECTION_STATUS.DISCONNECTED);
            console.log('Socket disconnected:', reason);
          },
          error: (error) => {
            console.error('Socket error:', error);
            setConnectionStatus(CONNECTION_STATUS.ERROR);
          },
          roomCreated: (newRoom) => {
            setRooms(prev => {
              const updatedRooms = [newRoom, ...prev];
              previousRoomsRef.current = updatedRooms;
              return updatedRooms;
            });
          },
          roomDeleted: (roomId) => {
            setRooms(prev => {
              const updatedRooms = prev.filter(room => room._id !== roomId);
              previousRoomsRef.current = updatedRooms;
              return updatedRooms;
            });
          },
          roomUpdated: (updatedRoom) => {
            setRooms(prev => {
              const updatedRooms = prev.map(room => 
                room._id === updatedRoom._id ? updatedRoom : room
              );
              previousRoomsRef.current = updatedRooms;
              return updatedRooms;
            });
          }
        };

        Object.entries(handlers).forEach(([event, handler]) => {
          socket.on(event, handler);
        });

      } catch (error) {
        console.error('Socket connection error:', error);
        if (!isSubscribed) return;
        
        if (error.message?.includes('Authentication required') || 
            error.message?.includes('Invalid session')) {
          handleAuthError({ response: { status: 401 } });
        }
        
        setConnectionStatus(CONNECTION_STATUS.ERROR);
      }
    };

    connectSocket();

    return () => {
      isSubscribed = false;
      if (socketRef.current) {
        socketRef.current.disconnect();
        socketRef.current = null;
      }
    };
  }, [currentUser, handleAuthError]);

  const handleJoinRoom = async (roomId) => {
    if (connectionStatus !== CONNECTION_STATUS.CONNECTED) {
      setError({
        title: '채팅방 입장 실패',
        message: '서버와 연결이 끊어져 있습니다.',
        type: 'danger'
      });
      return;
    }

    try {
      const response = await axiosInstance.post(`/api/rooms/${roomId}/join`, {}, {
        timeout: 5000
      });
      
      if (response.data.success) {
        router.push(`/chat?room=${roomId}`);
      }
    } catch (error) {
      console.error('Room join error:', error);
      
      let errorMessage = '입장에 실패했습니다.';
      if (error.response?.status === 404) {
        errorMessage = '채팅방을 찾을 수 없습니다.';
      } else if (error.response?.status === 403) {
        errorMessage = '채팅방 입장 권한이 없습니다.';
      }
      
      setError({
        title: '채팅방 입장 실패',
        message: error.response?.data?.message || errorMessage,
        type: 'danger'
      });
    }
  };

  const columns = useMemo(() => [
    {
      accessorKey: 'name',
      header: '채팅방',
      cell: cellHelper(({ value, rowData }) => (
        <div className="d-flex align-items-center gap-2">
          <Text className="font-medium">{value}</Text>
          {rowData.hasPassword && <Lock size={14} className="text-gray-500" />}
        </div>
      )),
      size: 200,
      enableSorting: true
    },
    {
      accessorKey: 'participants',
      header: '참여자',
      cell: cellHelper(({ value }) => (
        <Text className="participants-count">
          {value?.length || 0}명
        </Text>
      )),
      size: 100,
      enableSorting: true
    },
    {
      accessorKey: 'createdAt',
      header: '생성일',
      cell: cellHelper(({ value }) => (
        <Text className="created-at">
          {new Date(value).toLocaleString('ko-KR', {
            year: 'numeric',
            month: 'long',
            day: 'numeric',
            hour: '2-digit',
            minute: '2-digit'
          })}
        </Text>
      )),
      size: 200,
      enableSorting: true,
      sortingFn: 'datetime'
    },
    {
      accessorKey: 'actions',
      header: '',
      cell: cellHelper(({ rowData }) => (
        <Button
          variant="primary"
          size="md"
          onClick={() => handleJoinRoom(rowData._id)}
          disabled={connectionStatus !== CONNECTION_STATUS.CONNECTED}
        >
          입장
        </Button>
      )),
      size: 100,
      enableSorting: false
    }
  ], [connectionStatus]);

  const tableInstance = useHScrollTable({
    data: rooms,
    columns,
    extraColumnType: 'index',
    useResizeColumn: true,
    sorting,
    setSorting,
    initialSorting: sorting
  });

  return (
    <div className="chat-container">
      <Card className="chat-rooms-card">
        <Card.Header>
          <div className="flex justify-between items-center">
            <Card.Title>채팅방 목록</Card.Title>
            <div className="flex items-center gap-2">
              <Status 
                label={STATUS_CONFIG[connectionStatus].label} 
                color={STATUS_CONFIG[connectionStatus].color}
              />
              {(error || connectionStatus === CONNECTION_STATUS.ERROR) && (
                <Button
                  variant="ghost"
                  size="sm"
                  onClick={() => {
                    lastLoadedPageRef.current = 0;
                    setPageIndex(0);
                    fetchRooms(false);
                  }}
                  disabled={isRetrying}
                  className="ml-2"
                >
                  <RefreshCcw className="w-4 h-4" />
                  재연결
                </Button>
              )}
            </div>
          </div>
        </Card.Header>
        
        <Card.Body className="p-6">
          {error && (
            <Alert color={error.type} className="mb-4">
              <div className="flex items-start gap-2">
                {connectionStatus === CONNECTION_STATUS.ERROR ? (
                  <WifiOff className="w-4 h-4 mt-1" />
                ) : (
                  <AlertCircle className="w-4 h-4 mt-1" />
                )}
                <div>
                  <div className="font-medium">{error.title}</div>
                  <div className="mt-1">{error.message}</div>
                  {error.showRetry && !isRetrying && (
                    <Button
                      variant="ghost"
                      size="sm"
                      onClick={() => {
                        lastLoadedPageRef.current = 0;
                        setPageIndex(0);
                        fetchRooms(false);
                      }}
                      className="mt-2"
                    >
                      다시 시도
                    </Button>
                  )}
                </div>
              </div>
            </Alert>
          )}
          
          {loading ? (
            <LoadingIndicator text="채팅방 목록을 불러오는 중..." />
          ) : rooms.length > 0 ? (
            <TableWrapper
              onScroll={handleLoadMore}
              loadingMore={loadingMore}
              hasMore={hasMore}
              rooms={rooms}
            >
              <HScrollTable {...tableInstance.getTableProps()} />
            </TableWrapper>
          ) : !error && (
            <div className="chat-rooms-empty">
              <Text className="mb-4">생성된 채팅방이 없습니다.</Text>
              <Button
                variant="primary"
                onClick={() => router.push('/chat-rooms/new')}
                disabled={connectionStatus !== CONNECTION_STATUS.CONNECTED}
              >
                새 채팅방 만들기
              </Button>
            </div>
          )}
        </Card.Body>
      </Card>
    </div>
  );
}

const ChatRooms = dynamic(() => Promise.resolve(ChatRoomsComponent), {
  ssr: false,
  loading: () => (
    <div className="auth-container">
      <Card className="chat-rooms-card">
        <Card.Body className="p-6">
          <LoadingIndicator text="로딩 중..." />
        </Card.Body>
      </Card>
    </div>
  )
});

export default withAuth(ChatRooms);

<frontend/pages/chat.js>
import React from 'react';
import { Card } from '@goorm-dev/vapor-core';
import { 
  Text,
  Status,
  Avatar,
  UserAvatarGroup,
  CountAvatar,
  Spinner,
  Button,
  Alert
} from '@goorm-dev/vapor-components';
import { 
  AlertCircle, 
  WifiOff 
} from 'lucide-react';
import { withAuth } from '../middleware/withAuth';
import { useChatRoom } from '../hooks/useChatRoom';
import ChatMessages from '../components/chat/ChatMessages';
import ChatInput from '../components/chat/ChatInput';
import { generateColorFromEmail, getContrastTextColor } from '../utils/colorUtils';

const ChatPage = () => {
  const {
    room,
    messages,
    streamingMessages,
    connected,
    connectionStatus,
    messageLoadError,
    retryMessageLoad,
    currentUser,
    message,
    showEmojiPicker,
    showMentionList,
    mentionFilter,
    mentionIndex,
    filePreview,
    fileInputRef,
    messageInputRef,
    messagesEndRef,
    socketRef,
    handleMessageChange,
    handleMessageSubmit,
    handleEmojiToggle,
    setMessage,
    setShowEmojiPicker,
    setShowMentionList,
    setMentionFilter,
    setMentionIndex,
    handleKeyDown,
    removeFilePreview,
    getFilteredParticipants,
    insertMention,
    loading,
    error,
    handleReactionAdd,
    handleReactionRemove,
    loadingMessages,
    hasMoreMessages,
    handleLoadMore
  } = useChatRoom();

  const renderParticipants = () => {
    if (!room?.participants) return null;

    const maxVisibleAvatars = 3;
    const participants = room.participants;
    const remainingCount = Math.max(0, participants.length - maxVisibleAvatars);

    return (
      <div className="flex items-center gap-4 mt-2 px-6 border-b">
        <UserAvatarGroup size="md">
          {participants.slice(0, maxVisibleAvatars).map(participant => {
            const backgroundColor = generateColorFromEmail(participant.email);
            const color = getContrastTextColor(backgroundColor);
            
            return (
              <Avatar 
                key={participant._id} 
                style={{ backgroundColor, color }}
                className="participant-avatar"
                name={participant.name}
              />
            );
          })}
          {remainingCount > 0 && (
            <CountAvatar value={remainingCount} />
          )}
          <div className="ml-3">총 {participants.length}명</div>
        </UserAvatarGroup>
      </div>
    );
  };

  const renderLoadingState = () => (
    <div className="chat-container">
      <Card className="chat-room-card">
        <Card.Body className="flex items-center justify-center">
          <div className="text-center mt-5">
            <Spinner size="lg" className="mb-4" />
            <br/>
            <Text size="lg">채팅방 연결 중...</Text>
          </div>
        </Card.Body>
      </Card>
    </div>
  );

  const renderErrorState = () => (
    <div className="chat-container">
      <Card className="chat-room-card">
        <Card.Body className="flex items-center justify-center">
          <Alert color="danger" className="mb-4">
            <AlertCircle className="w-5 h-5" />
            <span className="ml-2">
              {error || '채팅방을 불러오는데 실패했습니다.'}
            </span>
          </Alert>
          <Button
            variant="primary"
            onClick={() => window.location.reload()}
          >
            다시 시도
          </Button>
        </Card.Body>
      </Card>
    </div>
  );

  const renderContent = () => {
    if (loading) {
      return (
        <div className="flex items-center justify-center p-4">
          <Spinner size="sm" />
          <Text className="ml-2">채팅방 연결 중...</Text>
        </div>
      );
    }

    if (error) {
      return (
        <div className="flex flex-col items-center justify-center p-4">
          <Alert color="danger" className="mb-4">
            <AlertCircle className="w-5 h-5" />
            <span className="ml-2">{error}</span>
          </Alert>
          <Button variant="primary" onClick={() => window.location.reload()}>
            다시 시도
          </Button>
        </div>
      );
    }

    if (connectionStatus === 'disconnected') {
      return (
        <Alert color="warning" className="m-4">
          <WifiOff className="w-5 h-5" />
          <span className="ml-2">연결이 끊어졌습니다. 재연결을 시도합니다...</span>
        </Alert>
      );
    }

    if (messageLoadError) {
      return (
        <div className="flex flex-col items-center justify-center p-4">
          <Alert color="danger" className="mb-4">
            <AlertCircle className="w-5 h-5" />
            <span className="ml-2">메시지 로딩 중 오류가 발생했습니다.</span>
          </Alert>
          <Button variant="primary" onClick={retryMessageLoad}>
            메시지 다시 로드
          </Button>
        </div>
      );
    }

    return (
      <ChatMessages
        messages={messages}
        streamingMessages={streamingMessages}
        currentUser={currentUser}
        room={room}
        messagesEndRef={messagesEndRef}
        onReactionAdd={handleReactionAdd}
        onReactionRemove={handleReactionRemove}
        loadingMessages={loadingMessages}
        hasMoreMessages={hasMoreMessages}
        onLoadMore={handleLoadMore}
        socketRef={socketRef}
      />
    );
  };

  if (loading || !room) {
    return renderLoadingState();
  }

  if (error) {
    return renderErrorState();
  }

  const getConnectionStatus = () => {
    if (connectionStatus === 'connecting') {
      return {
        label: "연결 중...",
        color: "warning"
      };
    } else if (connectionStatus === 'connected') {
      return {
        label: "연결됨",
        color: "success"
      };
    } else {
      return {
        label: "연결 끊김",
        color: "danger"
      };
    }
  };

  const status = getConnectionStatus();

  return (
    <div className="chat-container">
      <Card className="chat-room-card">
        <Card.Header className="chat-room-header">
          <div className="flex items-center gap-3">
            <Text size="xl" weight="bold" className="chat-room-title">
              {room.name}
            </Text>
            {renderParticipants()}
          </div>
          <Status
            label={status.label}
            color={status.color}
            title={connectionStatus === 'connecting' ? "재연결 시도 중..." : status.label}
          />
        </Card.Header>

        <Card.Body className="chat-room-body">
          <div className="chat-messages">
            {renderContent()}
          </div>
        </Card.Body>

        <Card.Footer className="chat-room-footer">
          <ChatInput 
            message={message}
            onMessageChange={handleMessageChange}
            onSubmit={handleMessageSubmit}
            onEmojiToggle={handleEmojiToggle}
            fileInputRef={fileInputRef}
            messageInputRef={messageInputRef}
            filePreview={filePreview}
            disabled={connectionStatus !== 'connected'}
            uploading={false}
            showEmojiPicker={showEmojiPicker}
            showMentionList={showMentionList}
            mentionFilter={mentionFilter}
            mentionIndex={mentionIndex}
            getFilteredParticipants={getFilteredParticipants}
            setMessage={setMessage}
            setShowEmojiPicker={setShowEmojiPicker}
            setShowMentionList={setShowMentionList}
            setMentionFilter={setMentionFilter}
            setMentionIndex={setMentionIndex}
            room={room} // room 객체 전달
            onMentionSelect={(user) => {
              insertMention(user);
              setShowMentionList(false);
            }}
            onFileRemove={removeFilePreview}
          />
        </Card.Footer>
      </Card>
    </div>
  );
};

export default withAuth(ChatPage);

<frontend/pages/index.js>
import React, { useState, useEffect } from 'react';
import { useRouter } from 'next/router';
import { Card } from '@goorm-dev/vapor-core';
import { 
  Button, 
  Input, 
  Text,
  Alert,
  Label
} from '@goorm-dev/vapor-components';
import { AlertCircle, Info, Clock, LockKeyhole, Mail, WifiOff } from 'lucide-react';
import authService from '../services/authService';
import { withoutAuth } from '../middleware/withAuth';

const Login = () => {
  const [formData, setFormData] = useState({ 
    email: '', 
    password: '' 
  });
  const [error, setError] = useState(null);
  const [loading, setLoading] = useState(false);
  const [serverStatus, setServerStatus] = useState({ checking: true, connected: false });
  const router = useRouter();
  const { redirect } = router.query;

  // 서버 연결 상태 확인
  useEffect(() => {
    const checkServerConnection = async () => {
      try {
        await authService.checkServerConnection();
        setServerStatus({ checking: false, connected: true });
      } catch (error) {
        console.error('Server connection check failed:', error);
        setServerStatus({ checking: false, connected: false });
        setError({
          type: 'error',
          title: '서버 연결 실패',
          message: '서버와 연결할 수 없습니다.',
          suggestion: '인터넷 연결을 확인하고 잠시 후 다시 시도해주세요.',
          Icon: WifiOff
        });
      }
    };

    checkServerConnection();
  }, []);

  const validateForm = () => {
    // 이메일 검증
    if (!formData.email?.trim()) {
      setError({
        type: 'warning',
        title: '입력 오류',
        message: '이메일을 입력해주세요.',
        field: 'email'
      });
      return false;
    }

    // 이메일 형식 검증
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(formData.email.trim())) {
      setError({
        type: 'warning',
        title: '입력 오류',
        message: '올바른 이메일 형식이 아닙니다.',
        field: 'email'
      });
      return false;
    }

    // 비밀번호 검증
    if (!formData.password) {
      setError({
        type: 'warning',
        title: '입력 오류',
        message: '비밀번호를 입력해주세요.',
        field: 'password'
      });
      return false;
    }

    return true;
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    setError(null);

    // 서버 연결 상태 확인
    if (!serverStatus.connected) {
      setError({
        type: 'error',
        title: '서버 연결 실패',
        message: '서버와 연결할 수 없습니다.',
        suggestion: '인터넷 연결을 확인하고 잠시 후 다시 시도해주세요.',
        Icon: WifiOff
      });
      return;
    }

    // 폼 유효성 검사
    if (!validateForm()) {
      return;
    }

    try {
      setLoading(true);

      // 로그인 요청 데이터 준비
      const loginCredentials = {
        email: formData.email.trim(),
        password: formData.password
      };

      // 디버그 로깅
      console.log('Submitting login request:', {
        email: loginCredentials.email,
        hasPassword: !!loginCredentials.password,
        timestamp: new Date().toISOString()
      });

      // 로그인 요청
      await authService.login(loginCredentials);
      const redirectUrl = router.query.redirect || '/chat-rooms';
      router.push(redirectUrl);

    } catch (err) {
      console.error('Login error:', err);

      if (err.isAxiosError && err.response?.status === 500) {
        setError({
          type: 'error',
          title: '서버 오류',
          message: '서버에서 오류가 발생했습니다.',
          suggestion: '잠시 후 다시 시도해주세요.',
          Icon: AlertCircle
        });
      } else {
        setError({
          type: 'error',
          title: '로그인 실패',
          message: err.message || '로그인 처리 중 오류가 발생했습니다.',
          suggestion: '입력하신 정보를 다시 확인해주세요.',
          Icon: AlertCircle
        });
      }
    } finally {
      setLoading(false);
    }
  };

  const handleInputChange = (e) => {
    const { name, value } = e.target;
    setFormData(prev => ({
      ...prev,
      [name]: value
    }));
    if (error?.field === name) setError(null);
  };

  if (serverStatus.checking) {
    return (
      <div className="auth-container">
        <Card className="auth-card">
          <Card.Body className="auth-card-body">
            <div className="text-center">
              <Text size="lg">서버 연결 확인 중...</Text>
            </div>
          </Card.Body>
        </Card>
      </div>
    );
  }

  return (
    <div className="auth-container">
      <Card className="auth-card">
        <Card.Body className="auth-card-body">
          <div className="auth-header">
            <img src="images/logo-h.png" className="w-50" />
          </div>

          {error && (
            <Alert variant={error.type} className="auth-alert">
              <div className="alert-wrapper">
                {error.Icon && <error.Icon className="w-5 h-5" />}
                <div>
                  <div>{error.title}</div>
                  <div>
                    {error.message}
                    {error.suggestion && (
                      <p className="alert-suggestion">{error.suggestion}</p>
                    )}
                  </div>
                </div>
              </div>
            </Alert>
          )}

          <form onSubmit={handleSubmit} className="auth-form" noValidate>
            <div className="form-item">
              <Label htmlFor="email" weight="medium">
                이메일
              </Label>
              <Input
                id="email"
                name="email"
                type="email"
                value={formData.email}
                onChange={handleInputChange}
                placeholder="이메일을 입력하세요"
                disabled={loading}
                state={error?.field === 'email' ? 'error' : undefined}
                autoComplete="email"
                required
                aria-required="true"
              />
            </div>

            <div className="form-item">
              <Label htmlFor="password" weight="medium">
                비밀번호
              </Label>
              <Input
                id="password"
                name="password"
                type="password"
                value={formData.password}
                onChange={handleInputChange}
                placeholder="비밀번호를 입력하세요"
                disabled={loading}
                state={error?.field === 'password' ? 'error' : undefined}
                autoComplete="current-password"
                required
                aria-required="true"
              />
            </div>

            <Button
              type="submit"
              variant="primary"
              size="lg"
              disabled={loading || !serverStatus.connected}
              className="auth-submit-button"
            >
              {loading ? '로그인 중...' : '로그인'}
            </Button>

            <div className="auth-footer">
              <Text size="sm">
                계정이 없으신가요?
              </Text>
              <br/><br/>
              <Button
                variant="text"
                size="sm"
                onClick={() => router.push('/register')}
                disabled={loading || !serverStatus.connected}
              >
                회원가입
              </Button>
            </div>
          </form>
        </Card.Body>
      </Card>
    </div>
  );
};

export default withoutAuth(Login);

<frontend/pages/login.js>
export { default } from './';  

<frontend/pages/profile.js>
import React, { useState, useEffect, useCallback, useRef } from 'react';
import { useRouter } from 'next/router';
import { Card } from '@goorm-dev/vapor-core';
import { 
  Button, 
  Input, 
  Text,
  Alert,
  Label,
  FormGroup
} from '@goorm-dev/vapor-components';
import { AlertCircle } from 'lucide-react';
import authService from '../services/authService';
import { withAuth } from '../middleware/withAuth';
import ProfileImageUpload from '../components/ProfileImageUpload';
import { generateColorFromEmail, getContrastTextColor } from '../utils/colorUtils';

const Profile = () => {
  const [currentUser, setCurrentUser] = useState(null);
  const [formData, setFormData] = useState({
    name: '',
    currentPassword: '',
    newPassword: '',
    confirmPassword: ''
  });
  const [profileImage, setProfileImage] = useState('');
  const [error, setError] = useState('');
  const [success, setSuccess] = useState('');
  const [loading, setLoading] = useState(false);
  const router = useRouter();
  const avatarStyleRef = useRef(null);

  // 프로필 이미지 URL 생성
  const getProfileImageUrl = useCallback((imagePath) => {
    if (!imagePath) return null;
    return imagePath.startsWith('http') ? 
      imagePath : 
      `${process.env.NEXT_PUBLIC_API_URL}${imagePath}`;
  }, []);

  useEffect(() => {
    const user = authService.getCurrentUser();
    if (!user) {
      router.push('/');
      return;
    }

    // 아바타 스타일과 함께 사용자 정보 설정
    if (!avatarStyleRef.current && user.email) {
      const backgroundColor = generateColorFromEmail(user.email);
      const color = getContrastTextColor(backgroundColor);
      avatarStyleRef.current = { backgroundColor, color };
    }

    setCurrentUser(user);
    setFormData(prev => ({ ...prev, name: user.name }));
    setProfileImage(user.profileImage || '');
  }, [router, getProfileImageUrl]);

  // 전역 이벤트 리스너 설정
  useEffect(() => {
    const handleProfileUpdate = () => {
      const user = authService.getCurrentUser();
      if (user) {
        setCurrentUser(user);
        setProfileImage(user.profileImage || '');
      }
    };

    window.addEventListener('userProfileUpdate', handleProfileUpdate);
    return () => {
      window.removeEventListener('userProfileUpdate', handleProfileUpdate);
    };
  }, []);

  const handleImageChange = useCallback(async (imageUrl) => {
    try {
      // 이미지 URL 업데이트
      const fullImageUrl = getProfileImageUrl(imageUrl);
      setProfileImage(imageUrl);

      // 현재 사용자 정보 가져오기
      const user = authService.getCurrentUser();
      if (!user) throw new Error('사용자 정보를 찾을 수 없습니다.');

      // 기존 상태 유지하면서 사용자 정보 업데이트
      const updatedUser = {
        ...user,
        profileImage: imageUrl
      };
      
      // localStorage 업데이트
      localStorage.setItem('user', JSON.stringify(updatedUser));
      setCurrentUser(updatedUser);

      // 성공 메시지 표시
      setSuccess('프로필 이미지가 업데이트되었습니다.');
      
      // 3초 후 성공 메시지 제거
      setTimeout(() => {
        setSuccess('');
      }, 3000);

      // 전역 이벤트 발생
      window.dispatchEvent(new Event('userProfileUpdate'));

    } catch (error) {
      console.error('Image update error:', error);
      setError('프로필 이미지 업데이트에 실패했습니다.');
      
      setTimeout(() => {
        setError('');
      }, 3000);
    }
  }, [getProfileImageUrl]);

  const handleSubmit = async (e) => {
    e.preventDefault();
    setError('');
    setSuccess('');

    if (formData.newPassword !== formData.confirmPassword) {
      setError('새 비밀번호가 일치하지 않습니다.');
      return;
    }

    setLoading(true);

    try {
      // 비밀번호 변경 처리
      if (formData.currentPassword) {
        if (!formData.newPassword) {
          throw new Error('새 비밀번호를 입력해주세요.');
        }
        await authService.changePassword(formData.currentPassword, formData.newPassword);
      }

      // 이름 변경 처리
      if (formData.name !== currentUser.name) {
        const updatedUser = await authService.updateProfile({ name: formData.name });
        setCurrentUser(updatedUser);
      }

      // 성공 메시지 설정
      setSuccess('프로필이 성공적으로 업데이트되었습니다.');

      // 비밀번호 필드 초기화
      setFormData(prev => ({ 
        ...prev, 
        currentPassword: '', 
        newPassword: '', 
        confirmPassword: '' 
      }));

      // 전역 이벤트 발생
      window.dispatchEvent(new Event('userProfileUpdate'));

    } catch (err) {
      console.error('Profile update error:', err);
      setError(err.response?.data?.message || err.message || '프로필 업데이트 중 오류가 발생했습니다.');
    } finally {
      setLoading(false);
    }
  };

  if (!currentUser) return null;

  return (
    <div className="profile-container">
      <Card className="profile-card">
        <Card.Header>
          <Text as="h5" typography="heading5">프로필 설정</Text>
        </Card.Header>
        
        <Card.Body className="auth-card-body">
          <div className="profile-header mb-4 text-center">
            <ProfileImageUpload 
              currentImage={profileImage}
              onImageChange={handleImageChange}
            />
          </div>

          {error && (
            <Alert color="danger" className="mt-4">
              <AlertCircle className="w-4 h-4" />
              <span>{error}</span>
            </Alert>
          )}

          {success && (
            <Alert color="success" className="mt-4">
              <span>{success}</span>
            </Alert>
          )}

          <form onSubmit={handleSubmit} className="profile-form">
            <FormGroup>
              <Label htmlFor="name">
                이메일
              </Label>
              <Input
                id="email"
                value={currentUser.email}
                disabled
                required
                className="mt-1"
              />
            </FormGroup>
            
            <FormGroup>              
              <Label htmlFor="name">
                이름
              </Label>
              <Input
                id="name"
                value={formData.name}
                onChange={(e) => setFormData(prev => ({ ...prev, name: e.target.value }))}
                placeholder="이름을 입력하세요"
                disabled={loading}
                required
                className="mt-1"
              />
            </FormGroup>
            
            <FormGroup>   
              <Label htmlFor="currentPassword">
                현재 비밀번호
              </Label>
              <Input
                id="currentPassword"
                type="password"
                value={formData.currentPassword}
                onChange={(e) => setFormData(prev => ({ ...prev, currentPassword: e.target.value }))}
                placeholder="현재 비밀번호를 입력하세요"
                disabled={loading}
                className="mt-1"
              />
            </FormGroup>
            
            <FormGroup>   
              <Label htmlFor="newPassword">
                새 비밀번호
              </Label>
              <Input
                id="newPassword"
                type="password"
                value={formData.newPassword}
                onChange={(e) => setFormData(prev => ({ ...prev, newPassword: e.target.value }))}
                placeholder="새 비밀번호를 입력하세요"
                disabled={loading}
                className="mt-1"
              />
            </FormGroup>
            
            <FormGroup>   
              <Label htmlFor="confirmPassword">
                새 비밀번호 확인
              </Label>
              <Input
                id="confirmPassword"
                type="password"
                value={formData.confirmPassword}
                onChange={(e) => setFormData(prev => ({ ...prev, confirmPassword: e.target.value }))}
                placeholder="새 비밀번호를 다시 입력하세요"
                disabled={loading}
                className="mt-1"
              />
            </FormGroup>

            <div className="profile-actions mt-4 text-center">
              <Button
                type="submit"
                variant="primary"
                className="w-full"
                loading={loading}
              >
                {loading ? '저장 중...' : '저장'}
              </Button>
              &nbsp;&nbsp;
              <Button
                variant="text"
                className="w-full"
                onClick={() => router.back()}
                disabled={loading}
              >
                취소
              </Button>
            </div>
          </form>
        </Card.Body>
      </Card>
    </div>
  );
};

export default withAuth(Profile);

<frontend/pages/register.js>
import React, { useState, useRef, useCallback } from 'react';
import { useRouter } from 'next/router';
import { Card } from '@goorm-dev/vapor-core';
import { 
  Button, 
  Input, 
  Text,
  Alert,
  FormGroup,
  Label,
  Modal,
  ModalHeader,
  ModalBody,
  ModalFooter
} from '@goorm-dev/vapor-components';
import { AlertCircle, PartyPopper } from 'lucide-react';
import ReactCanvasConfetti from 'react-canvas-confetti';
import authService from '../services/authService';

const canvasStyles = {
  position: 'fixed',
  pointerEvents: 'none',
  width: '100%',
  height: '100%',
  top: 0,
  left: 0,
  zIndex: 9999
};

const Register = () => {
  const [formData, setFormData] = useState({
    name: '',
    email: '',
    password: '',
    confirmPassword: ''
  });
  const [errors, setErrors] = useState([]);
  const [loading, setLoading] = useState(false);
  const [showSuccessModal, setShowSuccessModal] = useState(false);
  const router = useRouter();
  const refAnimationInstance = useRef(null);

  const getInstance = useCallback((instance) => {
    refAnimationInstance.current = instance;
  }, []);

  const makeShot = useCallback((particleRatio, opts) => {
    refAnimationInstance.current?.({
      ...opts,
      origin: { y: 0.7 },
      particleCount: Math.floor(200 * particleRatio)
    });
  }, []);

  const fireConfetti = useCallback(() => {
    makeShot(0.25, {
      spread: 26,
      startVelocity: 55
    });

    makeShot(0.2, {
      spread: 60
    });

    makeShot(0.35, {
      spread: 100,
      decay: 0.91,
      scalar: 0.8
    });

    makeShot(0.1, {
      spread: 120,
      startVelocity: 25,
      decay: 0.92,
      scalar: 1.2
    });

    makeShot(0.1, {
      spread: 120,
      startVelocity: 45
    });
  }, [makeShot]);

  const validateForm = () => {
    const newErrors = [];
    
    if (!formData.name.trim()) {
      newErrors.push({ field: 'name', message: '이름을 입력해주세요.' });
    }
    
    if (!formData.email.trim()) {
      newErrors.push({ field: 'email', message: '이메일을 입력해주세요.' });
    } else if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(formData.email)) {
      newErrors.push({ field: 'email', message: '올바른 이메일 형식이 아닙니다.' });
    }
    
    if (!formData.password) {
      newErrors.push({ field: 'password', message: '비밀번호를 입력해주세요.' });
    } else if (formData.password.length < 6) {
      newErrors.push({ field: 'password', message: '비밀번호는 6자 이상이어야 합니다.' });
    }
    
    if (formData.password !== formData.confirmPassword) {
      newErrors.push({ field: 'confirmPassword', message: '비밀번호가 일치하지 않습니다.' });
    }

    setErrors(newErrors);
    return newErrors.length === 0;
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    
    if (!validateForm()) {
      return;
    }

    setLoading(true);
    setErrors([]);

    try {
      const { name, email, password } = formData;
      // 회원가입
      await authService.register({ name, email, password });
      
      // 바로 로그인 처리
      await authService.login({ email, password });
      
      // 회원가입 성공 처리
      setShowSuccessModal(true);
      fireConfetti();
      
      // 10초 후 채팅방 목록 페이지로 이동
      setTimeout(() => {
        router.push('/chat-rooms');
      }, 10000);

    } catch (err) {
      console.error('Registration error:', err);
      
      if (err.response?.data?.errors) {
        setErrors(err.response.data.errors);
      } else if (err.response?.data?.message) {
        setErrors([{ message: err.response.data.message }]);
      } else {
        setErrors([{ message: '회원가입 중 오류가 발생했습니다. 잠시 후 다시 시도해주세요.' }]);
      }
    } finally {
      setLoading(false);
    }
  };

  const getFieldError = (fieldName) => {
    return errors.find(error => error.field === fieldName)?.message;
  };

  return (
    <div className="auth-container">
      <ReactCanvasConfetti refConfetti={getInstance} style={canvasStyles} />
      
      <Card className="auth-card">
        <Card.Body className="auth-card-body">
          <div className="auth-header">
            <img src="images/logo.png" className="w-50" alt="Logo" />
            <Text as="h3" typography="heading3">
              회원가입
            </Text>
          </div>

          {errors.length > 0 && (
            <Alert color="danger" className="mt-4">
              <div className="flex items-center gap-2 flex-row">
                <AlertCircle size="18" className="mr-2" />
                {errors.map((error, index) => (
                  <Text key={index} size="sm">
                    {error.message}
                  </Text>
                ))}
              </div>
            </Alert>
          )}

          <form onSubmit={handleSubmit} className="mt-6 space-y-4">
            <FormGroup>
              <Label htmlFor="name" required>이름</Label>
              <Input
                id="name"
                name="name"
                value={formData.name}
                onChange={(e) => setFormData(prev => ({
                  ...prev,
                  name: e.target.value
                }))}
                placeholder="이름을 입력하세요"
                disabled={loading}
                state={getFieldError('name') ? 'error' : undefined}
                required
              />
            </FormGroup>

            <FormGroup>
              <Label htmlFor="email" required>이메일</Label>
              <Input
                id="email"
                name="email"
                type="email"
                value={formData.email}
                onChange={(e) => setFormData(prev => ({
                  ...prev,
                  email: e.target.value
                }))}
                placeholder="이메일을 입력하세요"
                disabled={loading}
                state={getFieldError('email') ? 'error' : undefined}
                required
              />
            </FormGroup>

            <FormGroup>
              <Label htmlFor="password" required>비밀번호</Label>
              <Input
                id="password"
                name="password"
                type="password"
                value={formData.password}
                onChange={(e) => setFormData(prev => ({
                  ...prev,
                  password: e.target.value
                }))}
                placeholder="비밀번호를 입력하세요"
                disabled={loading}
                state={getFieldError('password') ? 'error' : undefined}
                required
              />
            </FormGroup>

            <FormGroup>
              <Label htmlFor="confirmPassword" required>비밀번호 확인</Label>
              <Input
                id="confirmPassword"
                name="confirmPassword"
                type="password"
                value={formData.confirmPassword}
                onChange={(e) => setFormData(prev => ({
                  ...prev,
                  confirmPassword: e.target.value
                }))}
                placeholder="비밀번호를 다시 입력하세요"
                disabled={loading}
                state={getFieldError('confirmPassword') ? 'error' : undefined}
                required
              />
            </FormGroup>

            <div className="mt-4 text-center">
              <Button
                type="submit"
                variant="primary"
                size="lg"
                className="auth-submit-button"
                loading={loading}
                disabled={loading}
              >
                {loading ? '회원가입 중...' : '회원가입'}
              </Button>
            </div>

            <div className="mt-4 text-center">
              <Text size="sm">
                이미 계정이 있으신가요?{' '}
              </Text>
            </div>
            <div className="mt-2 text-center">
              <Button
                size="sm"
                variant="text"
                onClick={() => router.push('/')}
                disabled={loading}
              >
                로그인
              </Button>
            </div>
          </form>
        </Card.Body>
      </Card>

      <Modal
        isOpen={showSuccessModal}
        toggle={() => setShowSuccessModal(false)}
        type="center"
        size="md"
        direction="vertical"
      >
        <ModalHeader toggle={() => setShowSuccessModal(false)}>
          <div className="flex items-center gap-3">
            <PartyPopper className="w-6 h-6 text-primary mr-3" />
            <Text as="span" typography="heading4">
              회원가입 성공
            </Text>
          </div>
        </ModalHeader>
        
        <ModalBody className="text-center py-6">
          <div className="flex flex-col items-center gap-4">
            <Text as="h4" typography="heading4" className="text-success">
              회원가입을 축하합니다!
            </Text>
            <br/>
            <Text size="md">
              10초 후 채팅방 목록으로 이동합니다.
            </Text>
          </div>
        </ModalBody>

        <ModalFooter>
          <Button 
            variant="primary" 
            size="lg" 
            onClick={() => router.push('/chat-rooms')}
            className="w-full"
          >
            채팅방 목록으로 이동
          </Button>
        </ModalFooter>
      </Modal>
    </div>
  );
};

export default Register;

<frontend/services/authService.js>
import axios from 'axios';
import socketService from './socket';
import { Toast } from '../components/Toast';

const API_URL = process.env.NEXT_PUBLIC_API_URL;

console.log('Initializing Auth Service with API URL:', API_URL);

// axios 인스턴스 생성
const api = axios.create({
  baseURL: API_URL,
  timeout: 30000,
  headers: {
    'Content-Type': 'application/json',
    'Accept': 'application/json'
  },
  withCredentials: true
});

// 재시도 설정
const RETRY_CONFIG = {
  maxRetries: 3,
  baseDelay: 1000,
  maxDelay: 5000,
  backoffFactor: 2,
  retryableStatuses: [408, 429, 500, 502, 503, 504],
  retryableErrors: ['ECONNABORTED', 'ETIMEDOUT', 'ENOTFOUND', 'ENETUNREACH', 'ERR_NETWORK']
};

// 유효성 검증 함수
const validateCredentials = (credentials) => {
  if (!credentials || typeof credentials !== 'object') {
    throw new Error('인증 정보가 올바르지 않습니다.');
  }

  const { email, password } = credentials;

  if (!email?.trim()) {
    throw new Error('이메일을 입력해주세요.');
  }

  if (!password) {
    throw new Error('비밀번호를 입력해주세요.');
  }

  if (typeof email !== 'string' || typeof password !== 'string') {
    throw new Error('입력값의 형식이 올바르지 않습니다.');
  }

  return {
    email: email.trim(),
    password: password
  };
};

// 재시도 딜레이 계산
const getRetryDelay = (retryCount) => {
  const delay = RETRY_CONFIG.baseDelay * 
    Math.pow(RETRY_CONFIG.backoffFactor, retryCount) *
    (1 + Math.random() * 0.1);
  return Math.min(delay, RETRY_CONFIG.maxDelay);
};

// 재시도 가능한 에러인지 판단
const isRetryableError = (error) => {
  if (error.code && RETRY_CONFIG.retryableErrors.includes(error.code)) {
    return true;
  }
  return !error.response || RETRY_CONFIG.retryableStatuses.includes(error.response.status);
};

// 요청 인터셉터
api.interceptors.request.use(
  config => {
    // 요청 데이터 검증
    if (!config.data || typeof config.data !== 'object') {
      config.data = {};
    }

    // 설정된 데이터가 문자열이면 파싱 시도
    if (typeof config.data === 'string') {
      try {
        config.data = JSON.parse(config.data);
      } catch (error) {
        console.error('Request data parsing error:', error);
        config.data = {};
      }
    }

    // 인증 토큰 설정
    const user = JSON.parse(localStorage.getItem('user') || '{}');
    if (user?.token) {
      config.headers['x-auth-token'] = user.token;
      if (user.sessionId) {
        config.headers['x-session-id'] = user.sessionId;
      }
    }

    return config;
  },
  error => Promise.reject(error)
);

class AuthService {
  constructor() {
    if (!API_URL) {
      console.warn('API_URL is not defined in environment variables');
    }
  }

  async login(credentials) {
    try {
      const response = await axios.post(`${API_URL}/api/auth/login`, credentials);

      if (response.data?.success && response.data?.token) {
        const userData = {
          id: response.data.user._id,
          name: response.data.user.name,
          email: response.data.user.email,
          profileImage: response.data.user.profileImage,
          token: response.data.token,
          sessionId: response.data.sessionId,
          lastActivity: Date.now()
        };

        localStorage.setItem('user', JSON.stringify(userData));
        window.dispatchEvent(new Event('authStateChange'));
        return userData;
      }

      throw new Error(response.data?.message || '로그인에 실패했습니다.');

    } catch (error) {
      console.error('Login error:', error);

      if (error.response?.status === 401) {
        Toast.error('이메일 주소가 없거나 비밀번호가 틀렸습니다.');
        throw new Error('이메일 주소가 없거나 비밀번호가 틀렸습니다.');
      }

      if (error.response?.status === 429) {
        Toast.error('너무 많은 로그인 시도가 있었습니다. 잠시 후 다시 시도해주세요.');
        throw new Error('너무 많은 로그인 시도가 있었습니다.');
      }

      if (!error.response) {
        Toast.error('서버와 통신할 수 없습니다. 잠시 후 다시 시도해주세요.');
        throw new Error('서버와 통신할 수 없습니다.');
      }

      const errorMessage = error.response?.data?.message || '로그인 중 오류가 발생했습니다.';
      Toast.error(errorMessage);
      throw new Error(errorMessage);
    }
  }


  // logout 메소드 수정
  async logout() {
    try {
      const user = this.getCurrentUser();
      if (user?.token) {
        await api.post('/api/auth/logout');
      }
    } catch (error) {
      console.error('Logout error:', error);
    } finally {
      console.log("??????");
      socketService.disconnect();
      localStorage.removeItem('user');
      // 인증 상태 변경 이벤트 발생
      window.dispatchEvent(new Event('authStateChange'));
      window.location.href = '/';
    }
  }

  // register 메소드 수정
  async register(userData) {
    try {
      const response = await api.post('/api/auth/register', userData);

      if (response.data?.success && response.data?.token) {
        const userInfo = {
          id: response.data.user._id,
          name: response.data.user.name,
          email: response.data.user.email,
          profileImage: response.data.user.profileImage,
          token: response.data.token,
          sessionId: response.data.sessionId,
          lastActivity: Date.now()
        };
        localStorage.setItem('user', JSON.stringify(userInfo));

        // 인증 상태 변경 이벤트 발생
        window.dispatchEvent(new Event('authStateChange'));

        return userInfo;
      }

      throw new Error(response.data?.message || '회원가입에 실패했습니다.');
    } catch (error) {
      console.error('Registration error:', error);
      throw this._handleError(error);
    }
  }
  
  async updateProfile(data) {
    try {
      const user = this.getCurrentUser();
      if (!user?.token) {
        throw new Error('인증 정보가 없습니다.');
      }

      const response = await axios.put(
        `${API_URL}/api/users/profile`,
        data,
        {
          headers: {
            'Content-Type': 'application/json',
            'x-auth-token': user.token,
            'x-session-id': user.sessionId
          }
        }
      );

      if (response.data?.success) {
        // 현재 사용자 정보 업데이트
        const updatedUser = {
          ...user,
          ...response.data.user,
          token: user.token,
          sessionId: user.sessionId
        };
        
        localStorage.setItem('user', JSON.stringify(updatedUser));
        window.dispatchEvent(new Event('userProfileUpdate'));
        
        return updatedUser;
      }

      throw new Error(response.data?.message || '프로필 업데이트에 실패했습니다.');

    } catch (error) {
      console.error('Profile update error:', error);
      
      if (error.response?.status === 401) {
        try {
          const refreshed = await this.refreshToken();
          if (refreshed) {
            return this.updateProfile(data);
          }
        } catch (refreshError) {
          throw new Error('인증이 만료되었습니다. 다시 로그인해주세요.');
        }
      }

      throw this._handleError(error);
    }
  }

  async changePassword(currentPassword, newPassword) {
    try {
      const user = this.getCurrentUser();
      if (!user?.token) {
        throw new Error('인증 정보가 없습니다.');
      }

      const response = await axios.put(
        `${API_URL}/api/users/profile`,
        {
          currentPassword,
          newPassword
        },
        {
          headers: {
            'Content-Type': 'application/json',
            'x-auth-token': user.token,
            'x-session-id': user.sessionId
          }
        }
      );

      if (response.data?.success) {
        return true;
      }

      throw new Error(response.data?.message || '비밀번호 변경에 실패했습니다.');

    } catch (error) {
      console.error('Password change error:', error);

      if (error.response?.status === 401) {
        if (error.response.data?.message?.includes('비밀번호가 일치하지 않습니다')) {
          throw new Error('현재 비밀번호가 일치하지 않습니다.');
        }

        try {
          const refreshed = await this.refreshToken();
          if (refreshed) {
            return this.changePassword(currentPassword, newPassword);
          }
        } catch (refreshError) {
          throw new Error('인증이 만료되었습니다. 다시 로그인해주세요.');
        }
      }

      throw this._handleError(error);
    }
  }  

  getCurrentUser() {
    try {
      const userStr = localStorage.getItem('user');
      if (!userStr) return null;

      const user = JSON.parse(userStr);
      const SESSION_TIMEOUT = 2 * 60 * 60 * 1000;
      
      if (Date.now() - user.lastActivity > SESSION_TIMEOUT) {
        this.logout();
        return null;
      }

      user.lastActivity = Date.now();
      localStorage.setItem('user', JSON.stringify(user));
      return user;
    } catch (error) {
      console.error('Get current user error:', error);
      this.logout();
      return null;
    }
  }

  async verifyToken() {
    try {
      const user = this.getCurrentUser();
      if (!user?.token || !user?.sessionId) {
        throw new Error('No authentication data found');
      }

      // 토큰 검증 상태를 로컬 스토리지에 저장
      const lastVerification = localStorage.getItem('lastTokenVerification');
      const verificationInterval = 5 * 60 * 1000; // 5분

      // 마지막 검증 후 5분이 지나지 않았다면 추가 검증 스킵
      if (lastVerification && Date.now() - parseInt(lastVerification) < verificationInterval) {
        return true;
      }

      const response = await axiosInstance.post('/api/auth/verify-token', {
        headers: {
          'x-auth-token': user.token,
          'x-session-id': user.sessionId
        }
      });

      if (response.data.success) {
        // 토큰 검증 시간 업데이트
        localStorage.setItem('lastTokenVerification', Date.now().toString());
        return true;
      }

      throw new Error(response.data.message || '토큰 검증에 실패했습니다.');
    } catch (error) {
      if (error.response?.status === 401) {
        try {
          await this.refreshToken();
          localStorage.setItem('lastTokenVerification', Date.now().toString());
          return true;
        } catch (refreshError) {
          this.logout();
          throw new Error('세션이 만료되었습니다. 다시 로그인해주세요.');
        }
      }
      throw error;
    }
  }
  
  async refreshToken() {
    try {
      const user = this.getCurrentUser();
      if (!user?.token) throw new Error('인증 정보가 없습니다.');

      const response = await api.post('/api/auth/refresh-token');

      if (response.data.success && response.data.token) {
        const updatedUser = {
          ...user,
          token: response.data.token,
          lastActivity: Date.now()
        };
        localStorage.setItem('user', JSON.stringify(updatedUser));
        return response.data.token;
      }

      throw new Error('토큰 갱신에 실패했습니다.');
    } catch (error) {
      console.error('Token refresh error:', error);
      throw this._handleError(error);
    }
  }

  async checkServerConnection() {
    try {
      const response = await api.get('/health', {
        timeout: 5000,
        retry: 2,
        retryDelay: 1000
      });
      return response.data.status === 'ok';
    } catch (error) {
      console.error('Server connection check failed:', error);
      throw this._handleError(error);
    }
  }

  _handleError(error) {
    if (error.isNetworkError) return error;
    
    if (axios.isAxiosError(error)) {
      if (!error.response) {
        return new Error('서버와 통신할 수 없습니다. 네트워크 연결을 확인해주세요.');
      }

      const { status, data } = error.response;
      const message = data?.message || error.message;

      switch (status) {
        case 400:
          return new Error(message || '입력 정보를 확인해주세요.');
        case 401:
          return new Error(message || '인증에 실패했습니다.');
        case 403:
          return new Error(message || '접근 권한이 없습니다.');
        case 404:
          return new Error(message || '요청한 리소스를 찾을 수 없습니다.');
        case 429:
          return new Error(message || '너무 많은 요청이 발생했습니다. 잠시 후 다시 시도해주세요.');
        case 500:
          return new Error(message || '서버 오류가 발생했습니다. 잠시 후 다시 시도해주세요.');
        default:
          return new Error(message || '요청 처리 중 오류가 발생했습니다.');
      }
    }

    return error;
  }
}

const authService = new AuthService();
export default authService;

<frontend/services/axios.js>
// frontend/services/axios.js
import axios from 'axios';
import authService from './authService';

const API_BASE_URL = process.env.NEXT_PUBLIC_API_URL;

if (!API_BASE_URL) {
  console.warn('Warning: NEXT_PUBLIC_API_URL is not defined in environment variables');
}

// 재시도 설정
const RETRY_CONFIG = {
  maxRetries: 3,
  initialDelayMs: 1000,
  maxDelayMs: 5000,
  backoffFactor: 2,
  retryableStatuses: [408, 429, 500, 502, 503, 504],
  retryableErrors: ['ECONNABORTED', 'ETIMEDOUT', 'ENOTFOUND', 'ENETUNREACH', 'ERR_NETWORK']
};

// 기본 설정으로 axios 인스턴스 생성
const axiosInstance = axios.create({
  baseURL: API_BASE_URL || 'http://localhost:5000',
  timeout: 30000,
  withCredentials: true,
  headers: {
    'Accept': 'application/json',
    'Content-Type': 'application/json'
  }
});

// 재시도 딜레이 계산 함수 
const getRetryDelay = (retryCount) => {
  // 지수 백오프와 약간의 무작위성 추가
  const delay = RETRY_CONFIG.initialDelayMs * 
    Math.pow(RETRY_CONFIG.backoffFactor, retryCount) *
    (1 + Math.random() * 0.1); // 지터 추가
  return Math.min(delay, RETRY_CONFIG.maxDelayMs);
};

// 재시도 가능한 에러인지 판단하는 함수
const isRetryableError = (error) => {
  if (!error) return false;
  
  // 네트워크 에러 코드 확인
  if (error.code && RETRY_CONFIG.retryableErrors.includes(error.code)) {
    return true;
  }
  
  // HTTP 상태 코드 확인
  if (error.response?.status && RETRY_CONFIG.retryableStatuses.includes(error.response.status)) {
    return true;
  }
  
  // 응답이 없는 경우 (네트워크 에러)
  if (!error.response && error.request) {
    return true;
  }
  
  return false;
};

// 요청 취소 토큰 저장소
const pendingRequests = new Map();

// 이전 요청 취소 함수
const cancelPendingRequests = (config) => {
  const requestKey = `${config.method}:${config.url}`;
  const previousRequest = pendingRequests.get(requestKey);
  
  if (previousRequest) {
    previousRequest.cancel('Request canceled due to duplicate request');
    pendingRequests.delete(requestKey);
  }
};

// 요청 인터셉터
axiosInstance.interceptors.request.use(
  async (config) => {
    try {
      // 요청 데이터 검증
      if (config.method !== 'get' && !config.data) {
        config.data = {};
      }

      // 인증 토큰 설정
      const user = authService.getCurrentUser();
      if (user?.token) {
        config.headers['x-auth-token'] = user.token;
        if (user.sessionId) {
          config.headers['x-session-id'] = user.sessionId;
        }
      }

      return config;
    } catch (error) {
      console.error('Request interceptor error:', error);
      return Promise.reject(error);
    }
  },
  (error) => Promise.reject(error)
);

// 응답 인터셉터
axiosInstance.interceptors.response.use(
  (response) => {
    // 성공한 요청 제거
    const requestKey = `${response.config.method}:${response.config.url}`;
    pendingRequests.delete(requestKey);
    
    return response;
  },
  async (error) => {
    const config = error.config || {};
    config.retryCount = config.retryCount || 0;
    
    // 요청이 취소된 경우
    if (axios.isCancel(error)) {
      console.log('Request canceled:', error.message);
      return Promise.reject(error);
    }

    // 재시도 가능한 에러이고 최대 재시도 횟수에 도달하지 않은 경우
    if (isRetryableError(error) && config.retryCount < RETRY_CONFIG.maxRetries) {
      config.retryCount++;
      const delay = getRetryDelay(config.retryCount);
      
      console.log(
        `Retrying request (${config.retryCount}/${RETRY_CONFIG.maxRetries}) ` +
        `after ${Math.round(delay)}ms:`, 
        config.url
      );
      
      try {
        // 딜레이 후 재시도
        await new Promise(resolve => setTimeout(resolve, delay));
        return await axiosInstance(config);
      } catch (retryError) {
        if (config.retryCount >= RETRY_CONFIG.maxRetries) {
          console.error('Max retry attempts reached:', config.url);
        }
        return Promise.reject(retryError);
      }
    }

    // 에러 유형별 처리
    if (!error.response) {
      // 네트워크 오류
      const customError = new Error();
      customError.message = [
        '서버와 통신할 수 없습니다.',
        '네트워크 연결을 확인하고 잠시 후 다시 시도해주세요.',
        error.code ? `(Error: ${error.code})` : ''
      ].filter(Boolean).join(' ');
      
      customError.isNetworkError = true;
      customError.originalError = error;
      customError.status = 0;
      customError.code = error.code || 'NETWORK_ERROR';
      customError.config = config;
      
      customError.retry = async () => {
        try {
          return await axiosInstance(config);
        } catch (retryError) {
          console.error('Manual retry failed:', retryError);
          throw retryError;
        }
      };
      
      throw customError;
    }

    // HTTP 상태 코드별 처리
    const status = error.response.status;
    const errorData = error.response.data;
    
    let errorMessage;
    let shouldLogout = false;
    
    switch (status) {
      case 400:
        errorMessage = errorData?.message || '잘못된 요청입니다.';
        break;
        
      case 401:
        errorMessage = '인증이 필요하거나 만료되었습니다.';
        shouldLogout = true;
        break;
        
      case 403:
        errorMessage = errorData?.message || '접근 권한이 없습니다.';
        break;
        
      case 404:
        errorMessage = errorData?.message || '요청한 리소스를 찾을 수 없습니다.';
        break;
        
      case 408:
        errorMessage = '요청 시간이 초과되었습니다.';
        break;
        
      case 429:
        errorMessage = '너무 많은 요청이 발생했습니다. 잠시 후 다시 시도해주세요.';
        break;
        
      case 500:
        errorMessage = '서버 오류가 발생했습니다. 잠시 후 다시 시도해주세요.';
        break;
        
      case 502:
      case 503:
      case 504:
        errorMessage = '서버가 일시적으로 응답할 수 없습니다. 잠시 후 다시 시도해주세요.';
        break;
        
      default:
        errorMessage = errorData?.message || '예기치 않은 오류가 발생했습니다.';
    }

    // 에러 객체 생성 및 메타데이터 추가
    const enhancedError = new Error(errorMessage);
    enhancedError.status = status;
    enhancedError.code = errorData?.code;
    enhancedError.data = errorData;
    enhancedError.config = config;
    enhancedError.originalError = error;
    enhancedError.retry = async () => {
      try {
        return await axiosInstance(config);
      } catch (retryError) {
        console.error('Manual retry failed:', retryError);
        throw retryError;
      }
    };

    // 401 에러 처리
    if (status === 401) {
      try {
        const refreshed = await authService.refreshToken();
        if (refreshed) {
          // 토큰 갱신 성공 시 원래 요청 재시도
          const user = authService.getCurrentUser();
          if (user?.token) {
            config.headers['x-auth-token'] = user.token;
            return axiosInstance(config);
          }
        }
      } catch (refreshError) {
        console.error('Token refresh failed:', refreshError);
        authService.logout();
        if (typeof window !== 'undefined') {
          window.location.href = '/?error=session_expired';
        }
      }
    }

    throw enhancedError;
  }
);

// 인스턴스 내보내기
export default axiosInstance;

<frontend/services/fileService.js>
import axios, { isCancel, CancelToken } from 'axios';
import authService from './authService';
import { Toast } from '../components/Toast';

class FileService {
  constructor() {
    this.baseUrl = process.env.NEXT_PUBLIC_API_URL;
    this.uploadLimit = 50 * 1024 * 1024; // 50MB
    this.retryAttempts = 3;
    this.retryDelay = 1000;
    this.activeUploads = new Map();

    this.allowedTypes = {
      image: {
        extensions: ['.jpg', '.jpeg', '.png', '.gif', '.webp'],
        mimeTypes: ['image/jpeg', 'image/png', 'image/gif', 'image/webp'],
        maxSize: 10 * 1024 * 1024,
        name: '이미지'
      },
      video: {
        extensions: ['.mp4', '.webm', '.mov'],
        mimeTypes: ['video/mp4', 'video/webm', 'video/quicktime'],
        maxSize: 50 * 1024 * 1024,
        name: '동영상'
      },
      audio: {
        extensions: ['.mp3', '.wav', '.ogg'],
        mimeTypes: ['audio/mpeg', 'audio/wav', 'audio/ogg'],
        maxSize: 20 * 1024 * 1024,
        name: '오디오'
      },
      document: {
        extensions: ['.pdf', '.doc', '.docx', '.txt'],
        mimeTypes: [
          'application/pdf',
          'application/msword',
          'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
          'text/plain'
        ],
        maxSize: 20 * 1024 * 1024,
        name: '문서'
      },
      archive: {
        extensions: ['.zip', '.rar', '.7z'],
        mimeTypes: [
          'application/zip',
          'application/x-rar-compressed',
          'application/x-7z-compressed'
        ],
        maxSize: 50 * 1024 * 1024,
        name: '압축파일'
      }
    };
  }

  async validateFile(file) {
    if (!file) {
      const message = '파일이 선택되지 않았습니다.';
      Toast.error(message);
      return { success: false, message };
    }

    if (file.size > this.uploadLimit) {
      const message = `파일 크기는 ${this.formatFileSize(this.uploadLimit)}를 초과할 수 없습니다.`;
      Toast.error(message);
      return { success: false, message };
    }

    let isAllowedType = false;
    let maxTypeSize = 0;
    let typeConfig = null;

    for (const config of Object.values(this.allowedTypes)) {
      if (config.mimeTypes.includes(file.type)) {
        isAllowedType = true;
        maxTypeSize = config.maxSize;
        typeConfig = config;
        break;
      }
    }

    if (!isAllowedType) {
      const message = '지원하지 않는 파일 형식입니다.';
      Toast.error(message);
      return { success: false, message };
    }

    if (file.size > maxTypeSize) {
      const message = `${typeConfig.name} 파일은 ${this.formatFileSize(maxTypeSize)}를 초과할 수 없습니다.`;
      Toast.error(message);
      return { success: false, message };
    }

    const ext = this.getFileExtension(file.name);
    if (!typeConfig.extensions.includes(ext.toLowerCase())) {
      const message = '파일 확장자가 올바르지 않습니다.';
      Toast.error(message);
      return { success: false, message };
    }

    return { success: true };
  }

  async uploadFile(file, onProgress) {
    const validationResult = await this.validateFile(file);
    if (!validationResult.success) {
      return validationResult;
    }

    try {
      const user = authService.getCurrentUser();
      if (!user?.token || !user?.sessionId) {
        return { 
          success: false, 
          message: '인증 정보가 없습니다.' 
        };
      }

      const formData = new FormData();
      formData.append('file', file);

      const source = CancelToken.source();
      this.activeUploads.set(file.name, source);

      const uploadUrl = this.baseUrl ? 
        `${this.baseUrl}/api/files/upload` : 
        '/api/files/upload';

      const response = await axios.post(uploadUrl, formData, {
        headers: {
          'Content-Type': 'multipart/form-data',
          'x-auth-token': user.token,
          'x-session-id': user.sessionId
        },
        cancelToken: source.token,
        withCredentials: true,
        onUploadProgress: (progressEvent) => {
          if (onProgress) {
            const percentCompleted = Math.round(
              (progressEvent.loaded * 100) / progressEvent.total
            );
            onProgress(percentCompleted);
          }
        }
      });

      this.activeUploads.delete(file.name);

      if (!response.data || !response.data.success) {
        return {
          success: false,
          message: response.data?.message || '파일 업로드에 실패했습니다.'
        };
      }

      const fileData = response.data.file;
      return {
        success: true,
        data: {
          ...response.data,
          file: {
            ...fileData,
            url: this.getFileUrl(fileData.filename, true)
          }
        }
      };

    } catch (error) {
      this.activeUploads.delete(file.name);
      
      if (isCancel(error)) {
        return {
          success: false,
          message: '업로드가 취소되었습니다.'
        };
      }

      if (error.response?.status === 401) {
        try {
          const refreshed = await authService.refreshToken();
          if (refreshed) {
            return this.uploadFile(file, onProgress);
          }
          return {
            success: false,
            message: '인증이 만료되었습니다. 다시 로그인해주세요.'
          };
        } catch (refreshError) {
          return {
            success: false,
            message: '인증이 만료되었습니다. 다시 로그인해주세요.'
          };
        }
      }

      return this.handleUploadError(error);
    }
  }
  async downloadFile(filename, originalname) {
    try {
      const user = authService.getCurrentUser();
      if (!user?.token || !user?.sessionId) {
        return {
          success: false,
          message: '인증 정보가 없습니다.'
        };
      }

      // 파일 존재 여부 먼저 확인
      const downloadUrl = this.getFileUrl(filename, false);
      const checkResponse = await axios.head(downloadUrl, {
        headers: {
          'x-auth-token': user.token,
          'x-session-id': user.sessionId
        },
        validateStatus: status => status < 500,
        withCredentials: true
      });

      if (checkResponse.status === 404) {
        return {
          success: false,
          message: '파일을 찾을 수 없습니다.'
        };
      }

      if (checkResponse.status === 403) {
        return {
          success: false,
          message: '파일에 접근할 권한이 없습니다.'
        };
      }

      if (checkResponse.status !== 200) {
        return {
          success: false,
          message: '파일 다운로드 준비 중 오류가 발생했습니다.'
        };
      }

      const response = await axios({
        method: 'GET',
        url: downloadUrl,
        headers: {
          'x-auth-token': user.token,
          'x-session-id': user.sessionId
        },
        responseType: 'blob',
        timeout: 30000,
        withCredentials: true
      });

      const contentType = response.headers['content-type'];
      const contentDisposition = response.headers['content-disposition'];
      let finalFilename = originalname;

      if (contentDisposition) {
        const filenameMatch = contentDisposition.match(
          /filename\*=UTF-8''([^;]+)|filename="([^"]+)"|filename=([^;]+)/
        );
        if (filenameMatch) {
          finalFilename = decodeURIComponent(
            filenameMatch[1] || filenameMatch[2] || filenameMatch[3]
          );
        }
      }

      const blob = new Blob([response.data], {
        type: contentType || 'application/octet-stream'
      });

      const blobUrl = window.URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = blobUrl;
      link.download = finalFilename;
      link.style.display = 'none';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);

      setTimeout(() => {
        window.URL.revokeObjectURL(blobUrl);
      }, 100);

      return { success: true };

    } catch (error) {
      if (error.response?.status === 401) {
        try {
          const refreshed = await authService.refreshToken();
          if (refreshed) {
            return this.downloadFile(filename, originalname);
          }
        } catch (refreshError) {
          return {
            success: false,
            message: '인증이 만료되었습니다. 다시 로그인해주세요.'
          };
        }
      }

      return this.handleDownloadError(error);
    }
  }

  getFileUrl(filename, forPreview = false) {
    if (!filename) return '';

    const baseUrl = process.env.NEXT_PUBLIC_API_URL || '';
    const endpoint = forPreview ? 'view' : 'download';
    return `${baseUrl}/api/files/${endpoint}/${filename}`;
  }

  getPreviewUrl(file, withAuth = true) {
    if (!file?.filename) return '';

    const baseUrl = `${process.env.NEXT_PUBLIC_API_URL}/api/files/view/${file.filename}`;
    
    if (!withAuth) return baseUrl;

    const user = authService.getCurrentUser();
    if (!user?.token || !user?.sessionId) return baseUrl;

    // URL 객체 생성 전 프로토콜 확인
    const url = new URL(baseUrl);
    url.searchParams.append('token', encodeURIComponent(user.token));
    url.searchParams.append('sessionId', encodeURIComponent(user.sessionId));

    return url.toString();
  }

  getFileType(filename) {
    if (!filename) return 'unknown';
    const ext = this.getFileExtension(filename).toLowerCase();
    for (const [type, config] of Object.entries(this.allowedTypes)) {
      if (config.extensions.includes(ext)) {
        return type;
      }
    }
    return 'unknown';
  }

  getFileExtension(filename) {
    if (!filename) return '';
    const parts = filename.split('.');
    return parts.length > 1 ? `.${parts.pop().toLowerCase()}` : '';
  }

  formatFileSize(bytes) {
    if (!bytes || bytes === 0) return '0 B';
    const units = ['B', 'KB', 'MB', 'GB', 'TB'];
    const i = Math.floor(Math.log(bytes) / Math.log(1024));
    return `${parseFloat((bytes / Math.pow(1024, i)).toFixed(2))} ${units[i]}`;
  }

  getHeaders() {
    const user = authService.getCurrentUser();
    if (!user?.token || !user?.sessionId) {
      return {};
    }
    return {
      'x-auth-token': user.token,
      'x-session-id': user.sessionId,
      'Accept': 'application/json, */*'
    };
  }

  handleUploadError(error) {
    console.error('Upload error:', error);

    if (error.code === 'ECONNABORTED') {
      return {
        success: false,
        message: '파일 업로드 시간이 초과되었습니다.'
      };
    }

    if (axios.isAxiosError(error)) {
      const status = error.response?.status;
      const message = error.response?.data?.message;

      switch (status) {
        case 400:
          return {
            success: false,
            message: message || '잘못된 요청입니다.'
          };
        case 401:
          return {
            success: false,
            message: '인증이 필요합니다.'
          };
        case 413:
          return {
            success: false,
            message: '파일이 너무 큽니다.'
          };
        case 415:
          return {
            success: false,
            message: '지원하지 않는 파일 형식입니다.'
          };
        case 500:
          return {
            success: false,
            message: '서버 오류가 발생했습니다.'
          };
        default:
          return {
            success: false,
            message: message || '파일 업로드에 실패했습니다.'
          };
      }
    }

    return {
      success: false,
      message: error.message || '알 수 없는 오류가 발생했습니다.',
      error
    };
  }

  handleDownloadError(error) {
    console.error('Download error:', error);

    if (error.code === 'ECONNABORTED') {
      return {
        success: false,
        message: '파일 다운로드 시간이 초과되었습니다.'};
    }

    if (axios.isAxiosError(error)) {
      const status = error.response?.status;
      const message = error.response?.data?.message;

      switch (status) {
        case 404:
          return {
            success: false,
            message: '파일을 찾을 수 없습니다.'
          };
        case 403:
          return {
            success: false,
            message: '파일에 접근할 권한이 없습니다.'
          };
        case 400:
          return {
            success: false,
            message: message || '잘못된 요청입니다.'
          };
        case 500:
          return {
            success: false,
            message: '서버 오류가 발생했습니다.'
          };
        default:
          return {
            success: false,
            message: message || '파일 다운로드에 실패했습니다.'
          };
      }
    }

    return {
      success: false,
      message: error.message || '알 수 없는 오류가 발생했습니다.',
      error
    };
  }

  cancelUpload(filename) {
    const source = this.activeUploads.get(filename);
    if (source) {
      source.cancel('Upload canceled by user');
      this.activeUploads.delete(filename);
      return {
        success: true,
        message: '업로드가 취소되었습니다.'
      };
    }
    return {
      success: false,
      message: '취소할 업로드를 찾을 수 없습니다.'
    };
  }

  cancelAllUploads() {
    let canceledCount = 0;
    for (const [filename, source] of this.activeUploads) {
      source.cancel('All uploads canceled');
      this.activeUploads.delete(filename);
      canceledCount++;
    }
    
    return {
      success: true,
      message: `${canceledCount}개의 업로드가 취소되었습니다.`,
      canceledCount
    };
  }

  getErrorMessage(status) {
    switch (status) {
      case 400:
        return '잘못된 요청입니다.';
      case 401:
        return '인증이 필요합니다.';
      case 403:
        return '파일에 접근할 권한이 없습니다.';
      case 404:
        return '파일을 찾을 수 없습니다.';
      case 413:
        return '파일이 너무 큽니다.';
      case 415:
        return '지원하지 않는 파일 형식입니다.';
      case 500:
        return '서버 오류가 발생했습니다.';
      case 503:
        return '서비스를 일시적으로 사용할 수 없습니다.';
      default:
        return '알 수 없는 오류가 발생했습니다.';
    }
  }

  isRetryableError(error) {
    if (!error.response) {
      return true; // 네트워크 오류는 재시도 가능
    }

    const status = error.response.status;
    return [408, 429, 500, 502, 503, 504].includes(status);
  }
}

export default new FileService();

<frontend/services/socket.js>
import { io } from 'socket.io-client';
import { Modal, Alert, Button } from '@goorm-dev/vapor-components';
import { AlertCircle, Timer, ExternalLink, AlertTriangle } from 'lucide-react';
import { Toast } from '../components/Toast';
import authService from './authService';

const CLEANUP_REASONS = {
  DISCONNECT: 'disconnect',
  MANUAL: 'manual',
  RECONNECT: 'reconnect'
};

class SocketService {
  constructor() {
    this.socket = null;
    this.heartbeatInterval = null;
    this.messageHandlers = new Map();
    this.messageQueue = [];
    this.reconnectAttempts = 0;
    this.maxReconnectAttempts = 5;
    this.isReconnecting = false;
    this.connectionPromise = null;
    this.retryDelay = 1000;
    this.duplicateLoginTimeout = 30000;
    this.reactionHandlers = new Set();
    this.connected = false;
  }

  async handleDuplicateLogin(data) {
    try {
      const { deviceInfo = 'Unknown Device', ipAddress = 'Unknown IP' } = data;

      // 전역 이벤트 발생
      const duplicateLoginEvent = new CustomEvent('duplicateLogin', {
        detail: {
          deviceInfo,
          ipAddress,
          timestamp: Date.now()
        }
      });
      window.dispatchEvent(duplicateLoginEvent);

      // 10초 후에 강제 로그아웃 처리
      setTimeout(async () => {
        try {
          if (this.socket?.connected) {
            await this.emit('force_login', {
              token: authService.getCurrentUser()?.token
            });
          }
        } catch (error) {
          console.error('Force login error:', error);
          await authService.logout();
          window.location.href = '/';
        }
      }, 10000);

    } catch (error) {
      console.error('[Socket] Error handling duplicate login:', error);
      await authService.logout();
      window.location.href = '/?error=session_error';
    }
  }

  async connect(options = {}) {
    if (this.connectionPromise) {
      return this.connectionPromise;
    }

    if (this.socket?.connected) {
      console.log('[Socket] Already connected');
      return Promise.resolve(this.socket);
    }

    this.connectionPromise = new Promise((resolve, reject) => {
      try {
        console.log('[Socket] Starting connection...');

        if (this.socket) {
          console.log('[Socket] Cleaning up existing socket before new connection');
          this.cleanup(CLEANUP_REASONS.RECONNECT);
        }

        const socketUrl = process.env.NEXT_PUBLIC_API_URL;
        console.log('[Socket] Connecting to:', socketUrl);

        this.socket = io(socketUrl, {
          ...options,
          transports: ['websocket', 'polling'],
          reconnection: true,
          reconnectionAttempts: this.maxReconnectAttempts,
          reconnectionDelay: this.retryDelay,
          reconnectionDelayMax: 5000,
          timeout: 20000,
          forceNew: true
        });

        this.setupEventHandlers(resolve, reject);

      } catch (error) {
        console.error('[Socket] Setup error:', error);
        this.connectionPromise = null;
        reject(error);
      }
    }).finally(() => {
      this.connectionPromise = null;
    });

    return this.connectionPromise;
  }

  setupEventHandlers(resolve, reject) {
    const connectionTimeout = setTimeout(() => {
      if (!this.socket?.connected) {
        console.error('[Socket] Connection timeout');
        reject(new Error('Connection timeout'));
      }
    }, 30000);

    this.socket.on('connect', () => {
      console.log('[Socket] Connected successfully');
      this.connected = true;
      this.reconnectAttempts = 0;
      this.isReconnecting = false;
      clearTimeout(connectionTimeout);
      this.startHeartbeat();
      resolve(this.socket);
    });

    this.socket.on('disconnect', (reason) => {
      console.log('[Socket] Disconnected:', reason);
      this.connected = false;
      this.cleanup(CLEANUP_REASONS.DISCONNECT);
    });

    this.socket.on('connect_error', (error) => {
      console.error('[Socket] Connection error:', error);
      
      if (error.message === 'Invalid session') {
        authService.refreshToken()
          .then(() => this.reconnect())
          .catch(() => {
            authService.logout();
            reject(error);
          });
        return;
      }

      if (this.reconnectAttempts >= this.maxReconnectAttempts) {
        clearTimeout(connectionTimeout);
        reject(error);
      }
    });

    this.socket.on('duplicate_login', async (data) => {
      console.log('[Socket] Duplicate login detected:', data);
      if (data.type === 'new_login_attempt') {
        await this.handleDuplicateLogin(data);
      } else if (data.type === 'existing_session') {
        console.log('[Socket] Existing session displaced');
        // Modal로 대체되었으므로 Toast 제거
        const duplicateLoginEvent = new CustomEvent('duplicateLogin', {
          detail: {
            deviceInfo: data.deviceInfo,
            ipAddress: data.ipAddress,
            timestamp: Date.now()
          }
        });
        window.dispatchEvent(duplicateLoginEvent);
      }
    });

    this.socket.on('error', (error) => {
      console.error('[Socket] Socket error:', error);
      this.handleSocketError(error);
    });

    this.socket.on('reconnect', (attemptNumber) => {
      console.log(`[Socket] Reconnected after ${attemptNumber} attempts`);
      this.connected = true;
      this.reconnectAttempts = 0;
      this.isReconnecting = false;
      this.processMessageQueue();
    });

    this.socket.on('reconnect_failed', () => {
      console.error('[Socket] Reconnection failed');
      this.cleanup(CLEANUP_REASONS.MANUAL);
      reject(new Error('Reconnection failed'));
    });

    this.socket.on('messageReaction', (data) => {
      console.log('[Socket] Message reaction:', data);
      this.reactionHandlers.forEach(handler => handler(data));
    });
  }

  cleanup(reason = CLEANUP_REASONS.MANUAL) {
    if (reason === CLEANUP_REASONS.DISCONNECT && this.isReconnecting) {
      return;
    }

    console.log(`[Socket] Cleanup started (reason: ${reason})`);

    if (this.heartbeatInterval) {
      clearInterval(this.heartbeatInterval);
      this.heartbeatInterval = null;
    }

    if (reason !== CLEANUP_REASONS.RECONNECT) {
      this.reactionHandlers.clear();
    }

    if (reason !== CLEANUP_REASONS.RECONNECT) {
      this.messageQueue = [];
    }

    if (reason === CLEANUP_REASONS.MANUAL && this.socket) {
      console.log("[Socket] Disconnecting socket during cleanup");
      this.socket.disconnect();
      this.socket = null;
    }

    if (reason === CLEANUP_REASONS.MANUAL) {
      this.reconnectAttempts = 0;
      this.isReconnecting = false;
      this.connectionPromise = null;
      this.connected = false;
    }

    console.log(`[Socket] Cleanup completed (reason: ${reason})`);
  }

  disconnect() {
    this.cleanup(CLEANUP_REASONS.MANUAL);
    if (this.socket) {
      this.socket.disconnect();
      this.socket = null;
    }
  }

  handleConnectionError(error) {
    this.reconnectAttempts++;
    console.error(`Connection error (attempt ${this.reconnectAttempts}/${this.maxReconnectAttempts}):`, error);

    if (error.message.includes('auth')) {
      authService.refreshToken()
        .then(() => this.reconnect())
        .catch(() => authService.logout());
      return;
    }

    if (error.message.includes('websocket error')) {
      if (this.socket) {
        this.socket.io.opts.transports = ['polling', 'websocket'];
      }
    }

    if (this.reconnectAttempts >= this.maxReconnectAttempts) {
      console.error('Max reconnection attempts reached');
      this.cleanup(CLEANUP_REASONS.MANUAL);
      this.isReconnecting = false;
    }
  }

  handleSocketError(error) {
    console.error('Socket error:', error);
    if (error.type === 'TransportError') {
      this.reconnect();
    }
    
    if (typeof window !== 'undefined') {
      window.dispatchEvent(new CustomEvent('socketError', { 
        detail: { error } 
      }));
    }
  }

  startHeartbeat() {
    if (this.heartbeatInterval) {
      clearInterval(this.heartbeatInterval);
    }

    this.heartbeatInterval = setInterval(() => {
      if (this.socket?.connected) {
        this.socket.emit('ping', null, (error) => {
          if (error) {
            console.error('Heartbeat failed:', error);
            this.cleanup(CLEANUP_REASONS.MANUAL);
          } else {
            console.debug('Heartbeat succeeded');
          }
        });
      } else {
        this.cleanup(CLEANUP_REASONS.MANUAL);
      }
    }, 25000);
  }

  getSocket() {
    return this.socket;
  }

  queueMessage(event, data) {
    const message = { event, data, timestamp: Date.now() };
    this.messageQueue.push(message);
    console.log(`Message queued: ${event}`, message);
  }

  processMessageQueue() {
    const now = Date.now();
    const validMessages = this.messageQueue.filter(msg => now - msg.timestamp < 300000);

    let successCount = 0;
    let failureCount = 0;

    while (validMessages.length > 0) {
      const message = validMessages.shift();
      try {
        this.socket.emit(message.event, message.data);
        successCount++;
        console.log(`Queued message sent: ${message.event}`);
      } catch (error) {
        failureCount++;
        console.error(`Error sending queued message (${message.event}):`, error);
      }
    }

    if (successCount + failureCount > 0) {
      console.log(`Message queue processed: ${successCount} succeeded, ${failureCount} failed`);
    }

    this.messageQueue = validMessages;
  }

  async emit(event, data) {
    try {
      if (!this.socket?.connected) {
        await this.connect();
      }
      
      return new Promise((resolve, reject) => {
        if (!this.socket?.connected) {
          reject(new Error('Socket is not connected'));
          return;
        }

        const timeout = setTimeout(() => {
          reject(new Error('Socket event timeout'));
        }, 10000);

        this.socket.emit(event, data, (response) => {
          clearTimeout(timeout);
          if (response?.error) {
            reject(response.error);
          } else {
            resolve(response);
          }
        });
      });
    } catch (error) {
      console.error('Error emitting event:', error);
      this.queueMessage(event, data);
      throw error;
    }
  }

  on(event, callback) {
    if (!this.socket) {
      console.warn('Socket is not initialized. Queuing event handler.');
      this.messageHandlers.set(event, callback);
      return;
    }
    
    this.socket.on(event, callback);
    if (event === 'aiMessageChunk') {
      this.messageHandlers.set('aiMessageChunk', callback);
    }
  }

  off(event, callback) {
    if (!this.socket) {
      this.messageHandlers.delete(event);
      return;
    }
    
    this.socket.off(event, callback);
    if (event === 'aiMessageChunk') {
      this.messageHandlers.delete('aiMessageChunk');
    }
  }

  async reconnect() {
    if (this.isReconnecting) return;

    console.log('Initiating manual reconnection...');
    this.isReconnecting = true;
    this.cleanup(CLEANUP_REASONS.RECONNECT);

    if (this.socket) {
      this.socket.disconnect();
      this.socket = null;
    }

    try {
      await new Promise(resolve => setTimeout(resolve, this.retryDelay));
      await this.connect();
    } catch (error) {
      console.error('Reconnection failed:', error);
      this.isReconnecting = false;
      throw error;
    }
  }

  isConnected() {
    return this.connected && this.socket?.connected;
  }

  getConnectionQuality() {
    if (!this.socket?.connected) return 'disconnected';
    if (this.isReconnecting) return 'reconnecting';
    if (this.socket.conn?.transport?.name === 'polling') return 'poor';
    return 'good';
  }

  async addReaction(messageId, reaction) {
    try {
      const user = authService.getCurrentUser();
      if (!user) {
        throw new Error('Authentication required');
      }

      await this.emit('messageReaction', {
        messageId,
        reaction,
        add: true
      });
    } catch (error) {
      console.error('Add reaction error:', error);
      throw error;
    }
  }

  async removeReaction(messageId, reaction) {
    try {
      const user = authService.getCurrentUser();
      if (!user) {
        throw new Error('Authentication required');
      }

      await this.emit('messageReaction', {
        messageId,
        reaction,
        add: false
      });
    } catch (error) {
      console.error('Remove reaction error:', error);
      throw error;
    }
  }

  onReactionUpdate(handler) {
    if (typeof handler !== 'function') {
      throw new Error('Handler must be a function');
    }
    this.reactionHandlers.add(handler);
    return () => this.reactionHandlers.delete(handler);
  }

  async toggleReaction(messageId, reaction) {
    try {
      const user = authService.getCurrentUser();
      if (!user) {
        throw new Error('Authentication required');
      }

      await this.emit('messageReaction', {
        messageId,
        reaction,
        toggle: true
      });
    } catch (error) {
      console.error('Toggle reaction error:', error);
      throw error;
    }
  }
}

const socketService = new SocketService();

if (typeof window !== 'undefined') {
  window.addEventListener('online', () => {
    console.log('Network is online');
    if (!socketService.isConnected() && !socketService.isReconnecting) {
      socketService.connect();
    }
  });

  window.addEventListener('offline', () => {
    console.log('Network is offline');
    socketService.disconnect();
  });
}

export default socketService;

<frontend/styles/globals.css>
/* Base Reset */
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

html,
body {
  height: 100vh;
  overflow: hidden;
  margin: 0;
  padding: 0;
}

#__next {
  height: 100vh;
  overflow: hidden;
}

/* Main Layout */
.main-content {
  height: 100vh;
  width: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
}

/* Auth Layout */
.auth-container {
  min-height: 100vh;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 1rem;
}

.auth-card {
  width: 100%;
  max-width: 24rem;
}

.auth-card-body {
  padding: 2rem;
}

.auth-header {
  text-align: center;
  margin-bottom: 2rem;
}

.auth-form {
  display: flex;
  flex-direction: column;
  gap: 1.5rem;
}

.form-item {
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
}

.auth-submit-button {
  width: 100%;
  margin-top: 0.5rem;
}

.auth-footer {
  margin-top: 1.5rem;
  text-align: center;
}

.auth-alert {
  margin-bottom: 1.5rem;
}

.alert-wrapper {
  display: flex;
  gap: 0.75rem;
}

.alert-suggestion {
  margin-top: 0.5rem;
}

/* Navigation */
.global-nav {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  z-index: 1000;
}

.nav-row {
  display: flex;
  align-items: center;
  height: 56px;
  padding: 0 1rem;
}

.nav-buttons {
  display: flex;
  gap: 1.5rem;
}

/* Chat Room Layout */
.chat-container {
  height: 100vh;
  width: 100vw;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 1.5rem;
}

.chat-room-card {
  width: 100%;
  max-width: 1000px;
  height: calc(100vh - 10rem);
  margin: 0 auto;
  display: flex;
  flex-direction: column;
  border-radius: 0.5rem;
  box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
}

.chat-room-header {
  padding: 1rem 1.5rem;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.chat-room-title {
  font-size: 1.25rem;
  font-weight: 600;
}

.chat-room-body {
  flex: 1;
  overflow: hidden;
  position: relative;
}

.chat-messages {
  position: absolute;
  inset: 0;
}

/* Message List Styles with Improved Scrolling */
.message-list {
  display: flex;
  flex-direction: column;
  gap: 1rem;
  padding: 1rem;
  height: 100%;
  overflow-y: auto;
  overflow-x: hidden;
  scroll-behavior: smooth;
  -webkit-overflow-scrolling: touch;
}

/* Last Message Styles */
.last-message {
  scroll-margin-bottom: 1rem;
}

.empty-messages {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100%;
  color: var(--text-secondary);
  text-align: center;
  gap: 0.5rem;
}

.scroll-anchor {
  float: left;
  clear: both;
}

/* Webkit Scrollbar Styling */
::-webkit-scrollbar {
  width: 6px;
}

::-webkit-scrollbar-track {
  background: transparent;
}

::-webkit-scrollbar-thumb {
  background: rgba(0, 0, 0, 0.2);
  border-radius: 3px;
}

.messages {
  display: flex;
  flex-direction: column;
  margin: 0.5rem 0;
}

.message-group {
  display: flex;
  flex-direction: column;
  max-width: 70%;
  margin: 0.5rem 0;
}

.message-group.mine {
  align-self: flex-end;
  margin-right: 0;
}

.message-group.yours {
  align-self: flex-start;
  margin-left: 0;
}

.message-sender-info {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  margin-bottom: 0.25rem;
  width: 100%; 
}

.mine .message-sender-info {
  flex-direction: row-reverse;
  justify-content: flex-end;
  align-self: flex-end;
  width: auto;
}

.sender-name {
  font-size: 0.875rem;
  font-weight: 500;
}

/* Message Bubble Styles */
.message-bubble {
  position: relative;
  padding: 1rem;
  border-radius: 1rem;
  max-width: 100%;
  word-wrap: break-word;
}

.message-mine {
  background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
  color: white;
  border-bottom-right-radius: 0.25rem;
}

.message-mine:after {
  content: '';
  position: absolute;
  right: -0.5rem;
  bottom: 0;
  width: 1rem;
  height: 1rem;
  background: #2563eb;
  clip-path: polygon(0 0, 0% 100%, 100% 100%);
}

.message-other {
  background-color: #f3f4f6;
  color: #111827;
  border-bottom-left-radius: 0.25rem;
}

.message-other:after {
  content: '';
  position: absolute;
  left: -0.5rem;
  bottom: 0;
  width: 1rem;
  height: 1rem;
  background: #f3f4f6;
  clip-path: polygon(100% 0, 0% 100%, 100% 100%);
}

.message-ai {
  background: linear-gradient(135deg, #7c3aed 0%, #6d28d9 100%);
  color: white;
  border-bottom-left-radius: 0.25rem;
}

.message-ai:after {
  content: '';
  position: absolute;
  left: -0.5rem;
  bottom: 0;
  width: 1rem;
  height: 1rem;
  background: linear-gradient(225deg, #7c3aed 0%, #6d28d9 100%);
  clip-path: polygon(100% 0, 0% 100%, 100% 100%);
}

.message-system {
  align-self: center;
  background-color: rgba(209, 213, 219, 0.05);
  color: rgba(255, 255, 255, 0.4);
  padding: 0.5rem 1rem;
  border-radius: 1rem;
  font-size: 0.875rem;
  margin: 0.5rem 0;
  text-align: center;
  max-width: 80%;
  backdrop-filter: blur(8px);
}

.message-footer {
  display: flex;
  align-items: center;
  justify-content: flex-end;
  gap: 0.25rem;
  margin-top: 0.25rem;
  padding: 0 0.5rem;
}

.message-time {
  font-size: 0.75rem;
  opacity: 0.5;
}

.message-system .message-time {
  font-size: 0.7rem;
  opacity: 0.5;
  margin-top: 0.25rem;
  text-align: center;
}

.mine .message-time {
  color: rgba(255, 255, 255, 0.7);
}

.read-status {
  display: flex;
  align-items: center;
}

/* Message Content Styles */
.message-content {
  position: relative;
  font-size: 0.9375rem;
  line-height: 1.5;
}

.message-content .list-none {
  list-style: none;
  margin-left: -1.5rem; 
}

.message-content .list-none input[type="checkbox"] {
  margin-right: 0.5rem;
}

.message-mine .message-content,
.message-ai .message-content {
  color: white;
}

/* Markdown Content Styles */
.message-content .md-heading {
  font-weight: 600;
  margin: 1rem 0 0.5rem;
  line-height: 1.3;
}

.message-content .md-h1 {
  font-size: 1.5rem;
}

.message-content .md-h2 {
  font-size: 1.25rem;
}

.message-content .md-h3 {
  font-size: 1.125rem;
}

.message-content .md-list, .message-content .contains-task-list {
  margin: 0.5rem 0;
  padding-left: 1.5rem;
}

.message-content .md-list-item, .message-content .task-list-item {
  margin: 0.25rem 0;
}

/* Code blocks */
.message-content pre[class*="language-"] {
  margin: 0.5rem 0;
  padding: 1rem;
  border-radius: 0.375rem;
  background: rgba(0, 0, 0, 0.2) !important;
  font-size: 0.875rem !important;
  line-height: 1.4 !important;
  overflow-x: auto;
}

.message-mine pre[class*="language-"] {
  background: rgba(0, 0, 0, 0.3) !important;
}

.message-content code:not([class*="language-"]) {
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 
    "Liberation Mono", "Courier New", monospace;
  padding: 0.2rem 0.4rem;
  border-radius: 0.25rem;
  font-size: 0.875em;
  background: rgba(0, 0, 0, 0.05);
}

.message-mine code:not([class*="language-"]) {
  background: rgba(0, 0, 0, 0.2);
  color: #fff;
}

/* Blockquotes */
.message-content .md-blockquote {
  margin: 0.5rem 0;
  padding: 0.5rem 1rem;
  border-left: 4px solid rgba(0, 0, 0, 0.1);
  background: rgba(0, 0, 0, 0.05);
  border-radius: 0.25rem;
}

.message-mine .md-blockquote {
  border-left-color: rgba(255, 255, 255, 0.2);
  background: rgba(255, 255, 255, 0.1);
}

/* Links */
.message-content .md-link {
  color: #0066cc;
  text-decoration: none;
  border-bottom: 1px solid rgba(0, 102, 204, 0.4);
  transition: border-color 0.2s ease;
}

.message-mine .md-link {
  color: #9fc3ff;
  border-bottom-color: rgba(159, 195, 255, 0.4);
}

.message-content .md-link:hover {
  border-bottom-color: currentColor;
}

/* Images */
.message-content .md-image {
  max-width: 100%;
  height: auto;
  border-radius: 0.375rem;
  margin: 0.5rem 0;
}

/* Tables */
.message-content .md-table-wrapper {
  overflow-x: auto;
  margin: 0.5rem 0;
}

.message-content .md-table {
  width: 100%;
  border-collapse: collapse;
  font-size: 0.875em;
}

.message-content .md-table th,
.message-content .md-table td {
  padding: 0.5rem;
  border: 1px solid rgba(0, 0, 0, 0.1);
  text-align: left;
}

.message-mine .md-table th,
.message-mine .md-table td {
  border-color: rgba(255, 255, 255, 0.2);
}

.message-content .md-table th {
  background: rgba(0, 0, 0, 0.05);
  font-weight: 600;
}

.message-mine .md-table th {
  background: rgba(255, 255, 255, 0.1);
}

/* Text formatting */
.message-content .md-bold {
  font-weight: 600;
}

.message-content .md-italic {
  font-style: italic;
}

/* Syntax highlighting custom styles */
.message-content .linenumber {
  color: rgba(127, 127, 127, 0.8);
  min-width: 2.5em;
  padding-right: 1em;
  text-align: right;
  user-select: none;
}

.message-content .token.comment,
.message-content .token.prolog,
.message-content .token.doctype,
.message-content .token.cdata {
  color: #8b949e;
}

.message-content .token.punctuation {
  color: #c9d1d9;
}

.message-content .token.selector,
.message-content .token.tag {
  color: #7ee787;
}

.message-content .token.property,
.message-content .token.boolean,
.message-content .token.number,
.message-content .token.constant,
.message-content .token.symbol,
.message-content .token.attr-name,
.message-content .token.deleted {
  color: #79c0ff;
}

.message-content .token.string,
.message-content .token.char,
.message-content .token.attr-value,
.message-content .token.builtin,
.message-content .token.inserted {
  color: #a5d6ff;
}

.message-content .token.operator,
.message-content .token.entity,
.message-content .token.url,
.message-content .language-css .token.string,
.message-content .style .token.string {
  color: #d2a8ff;
}

.message-content .token.atrule,
.message-content .token.keyword {
  color: #ff7b72;
}

.message-content .token.function,
.message-content .token.class-name {
  color: #d2a8ff;
}

.message-content .token.regex,
.message-content .token.important,
.message-content .token.variable {
  color: #ffa198;
}

/* Markdown Toolbar */
.markdown-toolbar {
  display: flex;
  gap: 0.25rem;
  border-radius: 0.375rem;
  background-color: var(--background-alternative);
  overflow-x: auto;
  scrollbar-width: none;
  -ms-overflow-style: none;
}

.markdown-toolbar::-webkit-scrollbar {
  display: none;
}

.toolbar-button {
  padding: 0.375rem;
  border: none;
  background: transparent;
  color: var(--text-secondary);
  border-radius: 0.25rem;
  cursor: pointer;
  transition: all 0.2s ease;
}

.toolbar-button:hover {
  background-color: transparent !important;
  color: var(--text-primary);
}

.toolbar-button:disabled {
  background-color: transparent !important;
}

/* File Upload */
input[type="file"] {
  display: none;
}

/* File Action Buttons */
.file-message img, .file-message video {
  max-width: 300px;
}

.file-action-button {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  padding: 0.5rem 0.75rem;
  border: none;
  background-color: transparent;
  color: inherit;
  font-size: 0.875rem;
  border-radius: 0.375rem;
  cursor: pointer;
  transition: background-color 0.2s ease;
}

.file-action-button:hover {
  background-color: rgba(0, 0, 0, 0.05);
}

.message-mine .file-action-button {
  color: white;
}

.message-mine .file-action-button:hover {
  background-color: rgba(255, 255, 255, 0.1);
}

.file-preview-list {
  display: flex;
  gap: 1rem;
  overflow-x: auto;
  padding-bottom: 0.5rem;
  -webkit-overflow-scrolling: touch;
  scrollbar-width: thin;
}

.file-preview-list::-webkit-scrollbar {
  height: 6px;
}

.file-preview-list::-webkit-scrollbar-track {
  background: var(--background-normal);
  border-radius: 3px;
}

.file-preview-list::-webkit-scrollbar-thumb {
  background: var(--border-color);
  border-radius: 3px;
}

.file-preview-item {
  flex: 0 0 260px;
  width: 260px;
  border: 1px solid rgba(255,255,255,0.1);
  border-radius: 0.375rem;
  overflow: hidden;
  background: rgba(0,0,0,0.15);
}

.file-preview-item img {
  width: 100%;
  max-height: 75%;
}

.file-preview-content {
  position: relative;
  padding: 0.75rem;
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
}

.remove-button {
  position: absolute;
  top: 0.5rem;
  right: 0.5rem;
  opacity: 0;
  transition: opacity 0.2s ease;
  padding: 0.25rem;
  border-radius: 0.25rem;
  background: var(--background-overlay);
  color: var(--text-secondary);
}

.file-preview-content:hover .remove-button {
  opacity: 1;
}

.remove-button:hover {
  background: var(--danger-light);
  color: var(--danger);
}

.file-limit-warning {
  margin-top: 0.5rem;
  padding: 0.5rem;
  border-radius: 0.25rem;
  background: var(--warning-light);
  color: var(--warning);
  display: flex;
  align-items: center;
  gap: 0.5rem;
  font-size: 0.75rem;
}

.preview-icon-wrapper {
  flex-direction: column;
  gap: 0.5rem;
}

.file-type {
  font-size: 0.75rem;
  color: var(--text-secondary);
  margin-top: 0.25rem;
}

.file-preview {
  width: 100px;
}

.file-name {
  font-size: 0.875rem;
  font-weight: 500;
  color: var(--text-primary);
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.file-size {
  font-size: 0.75rem;
  color: var(--text-secondary);
  margin-top: 0.25rem;
}

/* Chat Input Container Styles */
.chat-input {
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
  width: 100%;
  background: var(--surface-color);
  border-radius: 0.5rem;
  position: relative;  
}

/* First Layer: Markdown Toolbar */
.chat-input-toolbar {
  display: flex;
  align-items: center;
}

.chat-input-toolbar .markdown-toolbar {
  display: flex;
  gap: 0.25rem;
  overflow-x: auto;
  scrollbar-width: none;
  -ms-overflow-style: none;
}

.chat-input-toolbar .markdown-toolbar::-webkit-scrollbar {
  display: none;
}

/* Second Layer: Text Input Area */
.chat-input-main {
  display: flex;
  justify-content: center;
  align-items: center;
  position: relative; 
  width: 100%;  
}

.chat-input-textarea {
  width: 100%;
  resize: none;
  border: 1px solid var(--border-color);
  border-radius: 0.375rem;
  padding: 0.625rem;
  line-height: 1.5;
  background-color: var(--background-normal);
  color: #fff;
  transition: all 0.2s ease-in-out;
  overflow-y: hidden;
}

.chat-input-textarea:focus {
  outline: none;
  border-color: var(--primary-color);
  box-shadow: 0 0 0 2px var(--primary-color-alpha);
}

.chat-input-textarea:disabled {
  background-color: var(--background-disabled);
  cursor: not-allowed;
}

/* Third Layer: Action Buttons */
.chat-input-actions {
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: relative;
}

.chat-input-actions-left {
  display: flex;
  gap: 0.25rem;
  align-items: center;
}

/* 멘션 스타일 */
.mention {
  display: inline-block;
  padding: 2px 4px;
  margin: 0 2px;
  border-radius: 4px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s ease;
  text-decoration: none;
}

/* 일반 메시지에서의 멘션 스타일 */
.message-other .mention {
  background-color: rgba(88, 101, 242, 0.15);
  color: rgb(88, 101, 242);
}

.message-mine .mention {
  background-color: rgba(255, 255, 255, 0.2);
  color: #ffffff;
}

/* AI 멘션 특별 스타일 */
.message-other .mention-bot {
  background-color: rgba(88, 101, 242, 0.15);
  color: rgb(88, 101, 242);
}

.message-mine .mention-bot {
  background-color: rgba(255, 255, 255, 0.25);
  color: #ffffff;
}

/* 호버 효과 */
.mention:hover {
  background-color: rgba(88, 101, 242, 0.5);
}

.message-mine .mention:hover {
  background-color: rgba(255, 255, 255, 0.5);
}

/* Mention Styles */
.mention-dropdown {
  position: absolute;
  bottom: 100%;
  left: 0;
  right: 0;
  max-height: 200px;
  overflow-y: auto;
  background: var(--background-normal);
  border: 1px solid var(--border-color);
  border-radius: 0.5rem;
  margin-bottom: 0.5rem;
  box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
  z-index: 1000;
  animation: slideDown 0.2s ease-out;
}

.mention-item {
  display: flex;
  align-items: center;
  padding: 0.5rem 0.75rem;
  cursor: pointer;
  transition: background-color 0.2s ease;
  border-radius: 0.25rem;
  margin: 0.125rem;
}

.mention-item:hover,
.mention-item.active {
  background-color: var(--background-alternative);
}

.mention-item-content {
  display: flex;
  align-items: center;
  gap: 0.75rem;
  width: 100%;
}

.mention-info {
  display: flex;
  flex-direction: column;
  min-width: 0;
  flex: 1;
}

.mention-name {
  font-weight: 500;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.mention-badge {
  font-size: 0.75rem;
  border-radius: 9999px;
  padding: 0.125rem 0.5rem;
  max-width: 200px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.mention-badge.user {
  background-color: rgb(from var(--primary-hover) r g b / 10%);
  color: var(--primary-hover);
}

.mention-badge.ai {
  background-color: rgb(from var(--success-hover) r g b / 10%);
  color: var(--success-hover);
}

/* Animations */
@keyframes slideDown {
  from {
    opacity: 0;
    transform: translateY(-4px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.created-at {
  font-size: 85%;
}

.input-actions {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding-top: 0.25rem;
}

.action-buttons-left {
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.action-buttons-right {
  display: flex;
  align-items: center;
}

.send-button {
  padding: 0.5rem 1rem;
}

/* File Message Styles */
.message-mine .file-size {
  color: rgba(255, 255, 255, 0.7);
}

.file-actions {
  display: flex;
  gap: 0.5rem;
  border-top: 1px solid rgba(0, 0, 0, 0.1);
}

.message-mine .file-actions {
  border-top-color: rgba(255, 255, 255, 0.1);
}

.action-button {
  align-items: center;
  border: 1px solid rgba(255,255,255,0.1);
  padding: 7px 4px;
  background: transparent;
  border-radius: 0.375rem;
  color: inherit;
  font-size: 0.75rem;
  cursor: pointer;
  transition: background-color 0.2s;
  margin: 2px;
}

.action-button span {
  white-space: nowrap;
}

.action-button svg {
  width: 16px;
  height: 16px;
}

.bg-transparent-pattern {
  background-image: 
    linear-gradient(45deg, rgba(200,200,200,0.5) 25%, transparent 25%, transparent 75%, rgba(200,200,200,0.5) 75%), 
    linear-gradient(45deg, rgba(200,200,200,0.5) 25%, transparent 25%, transparent 75%, rgba(200,200,200,0.5) 75%);
  background-size: 20px 20px; /* 패턴 크기 */
  background-position: 0 0, 10px 10px;
}

/* 토스트 진행바 스타일 */
.Toastify__progress-bar--warning {
  background: linear-gradient(to right, rgba(255, 255, 255, 0.7), rgba(255, 255, 255, 0.7));
}

/* 중복 로그인 토스트 스타일 */
.duplicate-login-toast {
  background-color: #FFA726 !important;
  color: white;
}

.duplicate-login-toast .Toastify__progress-bar {
  height: 4px;
  background: rgba(255, 255, 255, 0.2);
}

.duplicate-login-toast .Toastify__progress-bar-theme--light {
  background: rgba(255, 255, 255, 0.7);
}

/* 카운트다운 애니메이션 */
@keyframes countdown {
  from {
    width: 100%;
  }
  to {
    width: 0%;
  }
}

pre {
  color: white;
}

/* 코드 블록 내 복사 버튼 스타일 */
.group:hover button {
  opacity: 1;
}

.group button {
  right: 0.5rem;
  top: 0.5rem;
  padding: 0.5rem;
  border-radius: 0.375rem;
  background-color: rgba(31, 41, 55, 0.5);
  transition: all 0.2s ease;
  z-index: 10;
  cursor: pointer;
}

.group button:hover {
  background-color: rgba(31, 41, 55, 0.8);
}

.group button svg {
  width: 1rem;
  height: 1rem;
  color: rgba(255, 255, 255, 0.8);
  transition: all 0.2s ease;
}

.group button:hover svg {
  color: rgba(255, 255, 255, 1);
}

/* 복사 성공 시 체크 아이콘 스타일 */
.group button .text-green-400 {
  color: #4ade80;
}

/* 코드 블록 스타일 개선 */
.group pre {
  margin: 0.5rem 0 !important;
  padding: 2.5rem 1rem 1rem !important;
  border-radius: 0.5rem !important;
  background-color: #1a1a1a !important;
}

/* 메시지 버블 내 리액션 버튼 스타일 수정 */
.message-actions-wrapper {
  display: flex;
  flex-direction: column;
  margin-top: 0.25rem;
  position: relative;
}

.emoji-picker {
  position: absolute;
  bottom: 100%;
}

.emoji-picker-wrapper {
  position: absolute;
  bottom: 100%;
  z-index: 1000;
  animation: fadeIn 0.2s ease-out;  
}

.mine .emoji-picker-wrapper {
  right: -32px;
}

.emoji-picker-container {
  background-color: var(--background-normal);
  border-radius: 0.5rem;
  box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
}

/* 애니메이션 추가 */
@keyframes fadeIn {
  from {
    opacity: 0;
    transform: translateY(4px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

/* Style adjustments for different message types */
.message-mine .message-actions-wrapper {
  align-items: flex-end;
}

.message-other .message-actions-wrapper {
  align-items: flex-start;
}

.message-mine .emoji-picker-wrapper {
  left: auto;
  right: 0;
}

/* Reaction badges */
.message-reactions {
  display: flex;
  flex-wrap: wrap;
  gap: 5px;
  margin-top: 0.5rem;
}

.reaction-badge {
  display: inline-flex;
  align-items: center;
  padding: 0 5px;
  border-radius: 10px;
  background-color: var(--background-alternative);
  border: 1px solid var(--border-color);
  font-size: 0.75rem;
  transition: all 0.2s ease;
  cursor: pointer;
  height: 24px;
}

.reaction-badge:hover {
  background-color: var(--background-hover);
}

.reaction-badge.active {
  background-color: var(--primary-light);
  border-color: var(--primary);
  color: var(--primary);
}

/* 타이핑 인디케이터 애니메이션 */
.typing-indicator {
  display: flex;
  gap: 4px;
  padding: 8px 0;
}

.typing-indicator span {
  width: 6px;
  height: 6px;
  background: rgba(255, 255, 255, 0.5);
  border-radius: 50%;
  animation: typing 1s infinite ease-in-out;
}

.typing-indicator span:nth-child(2) {
  animation-delay: 0.2s;
}

.typing-indicator span:nth-child(3) {
  animation-delay: 0.4s;
}

@keyframes typing {
  0%, 100% { transform: translateY(0); }
  50% { transform: translateY(-4px); }
}

/* Accessibility */
.sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border-width: 0;
}

.loading-messages {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 0.5rem;
  padding: 1rem;
  background: var(--background-alternative);
  border-radius: 0.5rem;
  margin-bottom: 1rem;
}

.message-history-end {
  text-align: center;
  padding: 0.5rem;
  margin-bottom: 1rem;
  color: var(--text-secondary);
}

.global-nav {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  z-index: 1000;
  background-color: var(--background-normal);
}

.container-fluid {
  width: 100%;
  margin-right: auto;
  margin-left: auto;
}

.nav-row {
  display: grid;
  grid-template-columns: auto 1fr auto;
  align-items: center;
  height: 4rem;
  gap: 1rem;
}

.nav-logo {
  display: flex;
  align-items: center;
}

.nav-menu {
  display: flex;
  justify-content: center;
}

.nav-user {
  display: flex;
  justify-content: flex-end;
  align-items: center;
}

.nav-auth {
  display: flex;
  align-items: center;
  gap: 1rem;
}

.profile-card {
  min-width: 400px;
}

<frontend/utils/colorUtils.js>
// utils/colorUtils.js

// 전역 색상 캐시 맵
const globalColorCache = new Map();

// AI 에이전트용 고정 색상
const AI_COLORS = {
  wayneAI: {
    backgroundColor: '#0084ff',
    color: '#FFFFFF'
  },
  consultingAI: {
    backgroundColor: '#00C853',
    color: '#FFFFFF'
  }
};

// 사용자 색상 팔레트
const USER_COLORS = [
  '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', 
  '#FFEEAD', '#D4A5A5', '#9B5DE5', '#F15BB5',
  '#00BBF9', '#00F5D4', '#738276', '#A6D8D4'
];

// AI 아바타 스타일 가져오기
export const getAIAvatarStyles = (aiName) => {
  if (!aiName) return AI_COLORS.wayneAI; // 기본값

  const formattedName = aiName.toLowerCase();
  
  if (formattedName === 'wayneai') {
    return AI_COLORS.wayneAI;
  }
  if (formattedName === 'consultingai') {
    return AI_COLORS.consultingAI;
  }
  
  // 알 수 없는 AI의 경우 기본값 반환
  return AI_COLORS.wayneAI;
};

// 이메일로부터 고유한 색상 생성
export const generateColorFromEmail = (email) => {
  if (!email) return '#0084ff';

  // 캐시된 색상이 있는지 확인
  if (globalColorCache.has(email)) {
    return globalColorCache.get(email);
  }

  // AI 계정 처리
  if (email.endsWith('@wayne.ai')) {
    globalColorCache.set(email, AI_COLORS.wayneAI.backgroundColor);
    return AI_COLORS.wayneAI.backgroundColor;
  }
  if (email.endsWith('@consulting.ai')) {
    globalColorCache.set(email, AI_COLORS.consultingAI.backgroundColor);
    return AI_COLORS.consultingAI.backgroundColor;
  }

  // 해시 생성
  let hash = 0;
  for (let i = 0; i < email.length; i++) {
    hash = ((hash << 5) - hash) + email.charCodeAt(i);
    hash = hash & hash;
  }

  // 색상 선택
  const color = USER_COLORS[Math.abs(hash) % USER_COLORS.length];
  globalColorCache.set(email, color);
  
  return color;
};

// 배경색에 따른 텍스트 색상 계산
export const getContrastTextColor = (backgroundColor) => {
  if (!backgroundColor) return '#000000';
  
  // RGB 변환
  const r = parseInt(backgroundColor.slice(1, 3), 16);
  const g = parseInt(backgroundColor.slice(3, 5), 16);
  const b = parseInt(backgroundColor.slice(5, 7), 16);
  
  // YIQ 명도 계산
  const yiq = ((r * 299) + (g * 587) + (b * 114)) / 1000;
  return yiq >= 128 ? '#000000' : '#FFFFFF';
};

// 이메일에 대한 일관된 아바타 스타일 반환
export const getConsistentAvatarStyles = (email) => {
  if (!email) return {};
  const backgroundColor = generateColorFromEmail(email);
  const color = getContrastTextColor(backgroundColor);
  return { backgroundColor, color };
};

// 현재 캐시된 모든 색상 가져오기
export const getAllCachedColors = () => {
  return new Map(globalColorCache);
};

// 캐시 초기화 (필요한 경우에만 사용)
export const clearColorCache = () => {
  globalColorCache.clear();
};

// AI 색상 가져오기 (이름으로)
export const getAIColorByName = (aiName) => {
  if (!aiName) return null;
  
  const formattedName = aiName.toLowerCase();
  return AI_COLORS[formattedName] || null;
};

// 사용자 정의 색상 설정 (캐시에 추가)
export const setCustomColor = (identifier, color) => {
  if (!identifier || !color) return false;
  
  try {
    globalColorCache.set(identifier, color);
    return true;
  } catch (error) {
    console.error('Error setting custom color:', error);
    return false;
  }
};

// 색상 유효성 검사
export const isValidColor = (color) => {
  if (!color) return false;
  
  // HEX 색상 코드 검증
  const hexRegex = /^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/;
  return hexRegex.test(color);
};

<frontend/utils/encryption.js>
// frontend/utils/encryption.js
import CryptoJS from 'crypto-js';

export class Encryption {
  static getEncryptionKey() {
    const key = process.env.NEXT_PUBLIC_ENCRYPTION_KEY;
    if (!key) {
      console.warn('Encryption key not found in environment variables');
      return 'default-key-for-development-only';
    }
    return key;
  }

  static getSalt() {
    const salt = process.env.NEXT_PUBLIC_PASSWORD_SALT;
    if (!salt) {
      console.warn('Password salt not found in environment variables');
      return 'default-salt-for-development-only';
    }
    return salt;
  }

  static encrypt(text) {
    if (!text) return text;
    try {
      return CryptoJS.AES.encrypt(
        text.toString(),
        this.getEncryptionKey()
      ).toString();
    } catch (error) {
      console.error('Encryption error:', error);
      throw new Error('암호화 중 오류가 발생했습니다.');
    }
  }

  static hashPassword(password) {
    if (!password) throw new Error('비밀번호가 필요합니다.');
    
    try {
      // PBKDF2 (Password-Based Key Derivation Function 2)
      return CryptoJS.PBKDF2(
        password,
        this.getSalt(),
        {
          keySize: 256/32, // 256 비트 키 생성
          iterations: 10000  // 반복 횟수
        }
      ).toString();
    } catch (error) {
      console.error('Password hashing error:', error);
      throw new Error('비밀번호 해싱 중 오류가 발생했습니다.');
    }
  }
}

// 환경 변수 유효성 검사
(() => {
  if (!process.env.NEXT_PUBLIC_ENCRYPTION_KEY) {
    console.warn('WARNING: NEXT_PUBLIC_ENCRYPTION_KEY is not set in environment variables');
  }
  if (!process.env.NEXT_PUBLIC_PASSWORD_SALT) {
    console.warn('WARNING: NEXT_PUBLIC_PASSWORD_SALT is not set in environment variables');
  }
})();

<goorm.manifest>
{"author":"sungtae_ryu_aq4ch80i6","name":"BootcampChat","type":"nodejs","detailedtype":"default","description":"","date":"2024-10-22T07:32:32.000Z","plugins":{"goorm.plugin.nodejs":[{"plugin.nodejs.main":"main","plugin.nodejs.source_path":"./","plugin.nodejs.run_option":"","plugin.nodejs.run_on":"console","plugin.nodejs.log_path":"./server.log","name":"nodejs"}]},"is_user_plugin":false,"storage":"container","project_domain":[{"id":"sungtae_ryu_aq4ch80i6","url":"bootcampchat-fe.run.goorm.site","port":"3000"}],"show_preview_btn":true,"author_email":"wayne.ryu@goorm.io","author_name":"류성태","ignore_patterns":[],"visibility":2}

<run.sh>
#!/bin/bash

# 실행할 서비스 목록
services=("MongoDB" "Redis" "Backend" "Frontend")

# 백엔드 및 프론트엔드 경로 설정
BACKEND_DIR="./backend"
FRONTEND_DIR="./frontend"

# 로그 파일 경로
LOG_DIR="./logs"

# 데이터 디렉토리 경로
DATA_DIR="$HOME/data/db"

# PM2 프로세스 이름 설정
PM2_MONGODB_NAME="mongo-server"
PM2_REDIS_NAME="redis-server"
PM2_BACKEND_NAME="backend-server"
PM2_FRONTEND_NAME="frontend-server"

# 명령어 인자 확인
if [ $# -eq 0 ] || [ $# -gt 2 ]; then
  echo "사용법: ./run.sh {start|stop|restart|status} [mode]"
  echo "mode 옵션: dev (기본값) | prod"
  echo "예시:"
  echo "  ./run.sh start         # 개발 모드로 시작"
  echo "  ./run.sh start prod    # 프로덕션 모드로 시작"
  exit 1
fi

# 실행 모드 설정 (두 번째 인자가 없으면 dev로 설정)
MODE=${2:-dev}

# 시스템 상태 체크 함수
check_system_status() {
  echo "시스템 상태를 확인합니다..."
  
  # MongoDB 포트 (27017) 확인
  if lsof -i:27017 >/dev/null 2>&1; then
    echo "경고: MongoDB 포트(27017)가 이미 사용 중입니다."
  fi
  
  # Redis 포트 (6379) 확인
  if lsof -i:6379 >/dev/null 2>&1; then
    echo "경고: Redis 포트(6379)가 이미 사용 중입니다."
  fi
  
  # 디스크 공간 확인
  DISK_SPACE=$(df -h "$DATA_DIR" | awk 'NR==2 {print $4}')
  echo "사용 가능한 디스크 공간: $DISK_SPACE"
}

# 함수 정의
start_services() {
  echo "서비스를 시작합니다... (모드: $MODE)"
  
  check_system_status

  # 데이터 디렉토리 확인 및 생성
  if [ ! -d "$DATA_DIR" ]; then
    echo "데이터 디렉토리가 존재하지 않습니다. 생성합니다: $DATA_DIR"
    mkdir -p "$DATA_DIR"
    # 권한 설정
    chmod 755 "$DATA_DIR"
  else
    echo "데이터 디렉토리가 이미 존재합니다: $DATA_DIR"
  fi

  # 로그 디렉토리 생성
  mkdir -p $LOG_DIR

  # MongoDB 시작
  if ! pm2 list | grep -q "$PM2_MONGODB_NAME"; then
    echo "MongoDB를 시작합니다..."
    pm2 start mongod --name "$PM2_MONGODB_NAME" -- \
      --dbpath "$DATA_DIR" \
      --bind_ip 0.0.0.0 \
      --logpath "$LOG_DIR/mongodb.log" \
      --logappend
  else
    echo "MongoDB가 이미 실행 중입니다."
  fi

  # Redis 시작
  if ! pm2 list | grep -q "$PM2_REDIS_NAME"; then
    echo "Redis를 시작합니다..."
    pm2 start redis-server --name "$PM2_REDIS_NAME" -- \
      --bind 0.0.0.0 \
      --loglevel notice \
      --dir "$LOG_DIR" \
      --daemonize no
  else
    echo "Redis가 이미 실행 중입니다."
  fi

  # 백엔드 시작
  if ! pm2 list | grep -q "$PM2_BACKEND_NAME"; then
    echo "백엔드 서버를 시작합니다... (모드: $MODE)"
    cd "$BACKEND_DIR"
    NODE_ENV=$MODE pm2 start server.js --name "$PM2_BACKEND_NAME" \
      --log "$LOG_DIR/backend.log" \
      --error "$LOG_DIR/backend-error.log"
    cd ..
  else
    echo "백엔드 서버가 이미 실행 중입니다."
  fi

  # 프론트엔드 시작
  if ! pm2 list | grep -q "$PM2_FRONTEND_NAME"; then
    echo "프론트엔드 서버를 시작합니다... (모드: $MODE)"
    cd "$FRONTEND_DIR"
    
    if [ "$MODE" = "prod" ]; then
      echo "프론트엔드 프로덕션 빌드를 시작합니다..."
      npm run build
      pm2 start npm --name "$PM2_FRONTEND_NAME" \
        --log "$LOG_DIR/frontend.log" \
        --error "$LOG_DIR/frontend-error.log" \
        -- start
    else
      pm2 start npm --name "$PM2_FRONTEND_NAME" \
        --log "$LOG_DIR/frontend.log" \
        --error "$LOG_DIR/frontend-error.log" \
        -- run dev -- -p 3000
    fi
    
    cd ..
  else
    echo "프론트엔드 서버가 이미 실행 중입니다."
  fi

  echo "모든 서비스가 시작되었습니다."
  pm2 list
}

stop_services() {
  echo "서비스를 중지합니다..."

  for service in "$PM2_FRONTEND_NAME" "$PM2_BACKEND_NAME" "$PM2_REDIS_NAME" "$PM2_MONGODB_NAME"; do
    if pm2 list | grep -q "$service"; then
      echo "$service 중지 중..."
      pm2 stop "$service"
      pm2 delete "$service"
    fi
  done

  echo "모든 서비스가 중지되었습니다."
  pm2 list
}

restart_services() {
  echo "서비스를 재시작합니다... (모드: $MODE)"

  pm2 restart "$PM2_MONGODB_NAME"
  pm2 restart "$PM2_REDIS_NAME"
  
  cd "$BACKEND_DIR"
  NODE_ENV=$MODE pm2 restart "$PM2_BACKEND_NAME"
  cd ..
  
  cd "$FRONTEND_DIR"
  if [ "$MODE" = "prod" ]; then
    echo "프론트엔드 프로덕션 빌드를 다시 시작합니다..."
    npm run build
    pm2 restart "$PM2_FRONTEND_NAME"
  else
    pm2 restart "$PM2_FRONTEND_NAME"
  fi
  cd ..

  echo "모든 서비스가 재시작되었습니다."
  pm2 list
}

status_services() {
  echo "서비스 상태를 확인합니다..."
  pm2 list
  
  echo "\n포트 사용 현황:"
  echo "MongoDB (27017):" $(lsof -i:27017 | grep LISTEN || echo "미사용")
  echo "Redis (6379):" $(lsof -i:6379 | grep LISTEN || echo "미사용")
  echo "Backend (5000):" $(lsof -i:5000 | grep LISTEN || echo "미사용")
  echo "Frontend (3000):" $(lsof -i:3000 | grep LISTEN || echo "미사용")
}

# 명령어 처리
case "$1" in
  start)
    start_services
    ;;
  stop)
    stop_services
    ;;
  restart)
    restart_services
    ;;
  status)
    status_services
    ;;
  *)
    echo "사용법: ./run.sh {start|stop|restart|status} [mode]"
    echo "mode 옵션: dev (기본값) | prod"
    exit 1
    ;;
esac

